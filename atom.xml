<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JDDFE</title>
  
  <subtitle>just do devFE</subtitle>
  <link href="https://blog.jddfe.com/atom.xml" rel="self"/>
  
  <link href="https://blog.jddfe.com/"/>
  <updated>2021-06-29T06:53:13.828Z</updated>
  <id>https://blog.jddfe.com/</id>
  
  <author>
    <name>jddfer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端安全之跨站脚本攻击（XSS）防御</title>
    <link href="https://blog.jddfe.com/posts/1746/"/>
    <id>https://blog.jddfe.com/posts/1746/</id>
    <published>2021-01-28T22:41:53.000Z</published>
    <updated>2021-06-29T06:53:13.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是跨站脚本攻击（XSS）"><a href="#什么是跨站脚本攻击（XSS）" class="headerlink" title="什么是跨站脚本攻击（XSS）"></a>什么是跨站脚本攻击（XSS）</h2><p>跨站脚本（Cross Site Scripting，XSS）指攻击者在页面插入恶意代码，当其他用户访问时，浏览会器解析并执行这些代码，达到窃取用户身份、钓鱼、传播恶意代码等行为。一般我们把 XSS 分为<strong>反射型</strong>、<strong>存储型</strong>、<strong>DOM型</strong> 3 种类型。</p><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 也叫“非持久型 XSS”，是指攻击者将恶意代码通过请求提交给服务端，服务端返回的内容，也带上了这段 XSS 代码，最后导致浏览器执行了这段恶意代码。</p><p>反射型 XSS 攻击方式需要诱导用户点击链接，攻击者会伪装该链接（例如短链接），当用户点击攻击者的链接后，攻击者便可以获取用户的 cookie 身份信息。</p><p>案例：<br>服务端直接输出参数内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> php</span><br><span class="line">$input = $_GET[<span class="string">&quot;param&quot;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;div&gt;&quot;</span>.$input.<span class="string">&quot;&lt;/div&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>恶意代码链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.a.com&#x2F;test.php?param&#x3D;&lt;srcipt src&#x3D;&quot;xss.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>存储型 XSS 也叫“持久型XSS”，会把用户输入的数据存储在服务端，这种XSS具有很强的稳定性。</p><p>案例：<br>比如攻击者在一篇博客下留言，留言包含恶意代码，提交到服务端后被存储到数据库。所有访问该博客的用户，在加载出这条留言时，会在他们的浏览器中执行这段恶意的代码。</p><h3 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h3><p>DOM 型 XSS 是一种特殊的反射型 XSS，它也是非持久型 XSS。相比于反射型 XSS，它不需要经过服务端，而是改变页面 DOM 来达到攻击。同样，这种攻击方式也需要诱导用户点击。</p><p>案例：</p><p>目标页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> search = <span class="keyword">new</span> URLSearchParams(location.search)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.write(<span class="string">&quot;hello, &quot;</span> + search.get(<span class="string">&#x27;name&#x27;</span>) + <span class="string">&#x27;!&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>恶意代码链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.a.com&#x2F;test.index?name&#x3D;&lt;srcipt src&#x3D;&quot;xss.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h2><ul><li>参数验证，不符合要求的数据不要存入数据库</li><li>对特殊字符转义，如”&lt;”、”&gt;”、”/“、”&amp;”等</li><li>避免使用eval、new Function动态执行字符串的方法</li><li>避免使用 innerHTML、document.write 直接将字符串输出到HTML</li><li>把一些敏感的 cookie 设置为 http only，避免前端访问 cookie</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是跨站脚本攻击（XSS）&quot;&gt;&lt;a href=&quot;#什么是跨站脚本攻击（XSS）&quot; class=&quot;headerlink&quot; title=&quot;什么是跨站脚本攻击（XSS）&quot;&gt;&lt;/a&gt;什么是跨站脚本攻击（XSS）&lt;/h2&gt;&lt;p&gt;跨站脚本（Cross Site Script</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端安全 XSS" scheme="https://blog.jddfe.com/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8-XSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue知识汇总</title>
    <link href="https://blog.jddfe.com/posts/34562/"/>
    <id>https://blog.jddfe.com/posts/34562/</id>
    <published>2021-01-07T20:09:20.000Z</published>
    <updated>2021-06-29T06:07:29.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对MVVM模式的理解"><a href="#对MVVM模式的理解" class="headerlink" title="对MVVM模式的理解"></a>对MVVM模式的理解</h2><p>MVVM 对应 3个组成部分，Model（模型）、View（视图） 和 ViewModel（视图模型）。 </p><p>1）View 是用户在屏幕上看到的结构、布局和外观，也称UI。<br>2）ViewModel 是一个绑定器，能和 View 层和 Model 层进行通信。<br>3）Model 是数据和逻辑。</p><p>View 不能和 Model 直接通信，它们只能通过 ViewModel 通信。<br>Model 和 ViewModel 之间的交互是双向的，ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，<br>因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p><blockquote><p>严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 在组件提供了 $refs 这个属性，让 Model 可以直接操作 View，违反了这一规定。</p></blockquote><h2 id="Vue的渲染流程"><a href="#Vue的渲染流程" class="headerlink" title="Vue的渲染流程"></a>Vue的渲染流程</h2><p>流程主要分为三个部分：</p><p>1）模板编译，parse 解析模板生成抽象语法树（AST）；optimize 标记静态节点，在后续页面更新时会跳过静态节点；<br>   generate 将AST转成 render 函数，render 函数用于构建 VNode。<br>2）构建VNode（虚拟dom），构建过程使用 createElement 构建 VNode，<br>   createElement 也是自定义 render 函数时接受到的第一个参数。<br>3）VNode转真实dom，patch 函数负责将 VNode 转换成真实dom，<br>   核心方法是createElm，递归创建真实dom树，最终渲染到页面上。</p><p><img src="2021-01-08T121438.png" alt="2021-01-08T121438"></p><h2 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h2><ol><li>beforeCreate: 在实例创建之前调用，由于实例还未创建，所以无法访问实例上的 data、computed、method等。</li><li>created: 在实例创建完成后调用，这时已完成数据的观测，可以获取数据和更改数据，但还无法与dom进行交互，如果想要访问dom，可以使用 vm.$nextTick。此时可以对数据进行更改，不会触发 updated。</li><li>beforeMount: 在挂载之前调用，这时的模板已编译完成并生成render函数，准备开始渲染。在此时也可以对数据进行更改，不会触发 updated。</li><li>mounted: 在挂载完成后调用，真实的dom挂载完毕，可以访问到dom节点，使用 $refs 属性对dom进行操作。</li><li>beforeUpdate: 在更新之前调用，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，在当前阶段进行更改数据，不会造成重渲染。</li><li>updated： 在更新完成之后调用，组件dom已完成更新。要注意的是避免在此期间更改数据，这可能会导致死循环。</li><li>beforeDestroy： 在实例销毁之前调用，这时实例还可以被使用，一般这个周期内可以做清除计时器和取消事件监听的工作。</li><li>destroyed： 在实例销毁之后调用，这时已无法访问实例。当前实例从父实例中被移除，观测被卸载，所有事件监听器呗移除，子实例也统统被销毁。</li></ol><h2 id="Vue-父组件和子组件生命周期执行顺序"><a href="#Vue-父组件和子组件生命周期执行顺序" class="headerlink" title="Vue 父组件和子组件生命周期执行顺序"></a>Vue 父组件和子组件生命周期执行顺序</h2><p>1、渲染过程<br>  1)父组件 beforeCreate<br>  2)父组件 created<br>  3)父组件 beforeMount<br>  4)子组件 beforeCreate<br>  5)子组件 created<br>  6)子组件 beforeMount<br>  7)子组件 mounted<br>  8)父组件 mounted</p><p>子组件早于父组件挂载，因为创建节点树时使用的是递归，子组件会先被创建完成，<br>最后才是整个父节点创建完成。</p><p>2、更新过程<br>  1）父组件 beforeUpdate<br>  2）子组件 beforeUpdate<br>  3）子组件 updated<br>  4）父组件 updated</p><p>3、销毁过程<br>  1）父组件 beforeDestroy<br>  2）子组件 beforeDestroy<br>  3）子组件 destroyed<br>  4）父组件 destroyed</p><h2 id="data为什么要求是函数"><a href="#data为什么要求是函数" class="headerlink" title="data为什么要求是函数"></a>data为什么要求是函数</h2><p>当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，<br>因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，<br>则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，<br>我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。</p><p>Vue 构造实例使用的是同一个构造函数，data 直接使用对象会导致实例的共享引用，<br>即组件间的状态会相互影响。通常发生共享引用，都是组件复用的情况。<br>使用函数返回一个对象，由于是不同引用，自然可以避免这个问题发生。</p><h2 id="组件通信方式"><a href="#组件通信方式" class="headerlink" title="组件通信方式"></a>组件通信方式</h2><ul><li>props/emit</li><li>$children/$parent</li><li>ref</li><li>$attrs/$listeners</li><li>provide/inject</li><li>eventBus</li><li>vuex</li></ul><h2 id="Vue-的5种指令"><a href="#Vue-的5种指令" class="headerlink" title="Vue 的5种指令"></a>Vue 的5种指令</h2><p>1）v-if<br>2）v-for<br>3）v-show<br>4）v-html<br>5）v-model</p><h2 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h2><p>v-if 会让条件块内元素或组件适当地被销毁和重建。<br>v-show 的元素或组件一开始就被渲染，只是简单的进行css切换。<br>相比之下，v-if 会带来更高的切换消耗，所以频繁切换使用 v-show，不常切换则使用 v-if。</p><h2 id="v-model的理解"><a href="#v-model的理解" class="headerlink" title="v-model的理解"></a>v-model的理解</h2><p>v-model 是属性 value 和 input 事件的语法糖。内部默认将 value 作为值，<br>使用 $emit 触发 input 事件更新属性，从而实现双向绑定。<br>而自定义双向绑定可以定义组件的 model 选项设置 prop 和 event 来实现。</p><h2 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h2><p>双向绑定是视图变化会反映到数据，数据变化会反映到视图，<br>v-model 就是个很好理解的例子。其实主要考查的还是响应式原理，<br>响应式原理共包括3个主要成员，Observer 负责监听数据变化，<br>Dep 负责依赖收集，Watcher 负责数据或视图更新，我们常说的收集依赖就是收集 Watcher。</p><p><img src="2021-01-08T140701.png" alt="2021-01-08T140701"><br>响应式原理主要工作流程如下：<br>1）Observer 内使用 Object.defineProperty 劫持数据，为其设置 set 和 get。<br>2）每个数据都会有自己的 dep。数据取值触发 get 函数，调用 dep.depend 收集依赖；<br>   数据更新触发 set 函数，调用 dep.notify 通知 Watcher 更新。<br>3）Watcher 接收到更新的通知，将这些通知加入到一个异步队列中，<br>   并且进行去重处理，等到所有同步操作完成后，再一次性更新视图。</p><h2 id="Vue-中-的-key-有什么作用"><a href="#Vue-中-的-key-有什么作用" class="headerlink" title="Vue 中 的 key 有什么作用"></a>Vue 中 的 key 有什么作用</h2><p>key 是每个 VNode 的唯一标识，依靠 key 能够在 diff 算法执行时更快的找到对应的 VNode，提高 diff 速度。<br>key 能保证元素之间的状态独立，在更新后状态不被复用，<br>避免一些意外的结果。就像输入框在复用的情况下，即使元素更新，<br>输入框的内容依旧没有刷新，这是因为 Vue 默认是使用“就地复用”的策略，<br>会尽可能减少创建和销毁的过程。</p><h2 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h2><p>1）computed 依赖 data 的改变而改变，computed 有返回值；watch 观测 data，<br>   执行对应的函数。<br>2）computed 有缓存功能，重复取值不会执行求值函数。<br>3）computed 依赖收集在页面渲染时触发，watch 依赖收集在页面渲染前触发。<br>4）computed 更新需要“渲染Watcher”的配合，computed 更新只是设置 dirty，<br>   需要页面渲染触发 get 重新求值</p><h2 id="Vue-中的-computed-是如何实现缓存的"><a href="#Vue-中的-computed-是如何实现缓存的" class="headerlink" title="Vue 中的 computed 是如何实现缓存的"></a>Vue 中的 computed 是如何实现缓存的</h2><p>“计算属性Watcher”会带有一个 dirty 的属性，在初始化取值完成后，会将求值结果缓存起来，<br>并把 dirty 设置为 false。只要依赖属性不更新，dirty 永远为 false，<br>重复取值也不会再去执行求值函数，而是直接返回缓存结果，从而实现缓存。<br>相反，依赖属性更新会将“计算属性 Watcher”的 dirty 设置为 true，<br>在页面渲染对计算属性取值时，再次触发求值函数更新计算属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(target, key, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        const watcher &#x3D; this._computedWatchers &amp;&amp; this._computedWatchers[key]</span><br><span class="line">        &#x2F;&#x2F; 计算属性缓存</span><br><span class="line">        if (watcher.dirty) &#123;  </span><br><span class="line">            &#x2F;&#x2F; 计算属性求值</span><br><span class="line">            watcher.evaluate()  </span><br><span class="line">        &#125;</span><br><span class="line">        return watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="子组件为什么不能直接更改props？什么是单向数据流？"><a href="#子组件为什么不能直接更改props？什么是单向数据流？" class="headerlink" title="子组件为什么不能直接更改props？什么是单向数据流？"></a>子组件为什么不能直接更改props？什么是单向数据流？</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，<br>但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>子组件不能更改 props 是因为要遵循单向数据流的原则。<br>单向数据流只允许数据由父组件传递给子组件，数据只能由父组件更新。<br>当数据传递到多个子组件，而子组件能够在其内部更新数据时，<br>在主观上很难知道是哪个子组件更新了数据，导致数据流向不明确，从而增加应用调试的难度。<br>但子组件更新父组件数据的场景确实存在，有3种方法可以使用：</p><p>1）子组件 emit，父组件接受自定义事件。这种方法最终还是由父组件进行修改，<br>   子组件只是起到一个通知的作用。<br>2）子组件自定义双向绑定，设置组件的 model 选项为组件添加自定义双向绑定。<br>3）.sync 属性修饰符，它是第一种方法的语法糖，在传递属性添加上该修饰符，<br>   子组件内可调用 this.$emit(‘update:属性名’, value) 更新属性。</p><h2 id="Vue-如何检测数组更新"><a href="#Vue-如何检测数组更新" class="headerlink" title="Vue 如何检测数组更新"></a>Vue 如何检测数组更新</h2><p>Vue 内部重写数组原型链，当数组发生变化时，除了执行原生的数组方法外，<br>还会调用 dep.notify 通知 Watcher 更新。触发数组更新的方法共7种：</p><p>1)push<br>2)pop<br>3)shift<br>4)unshift<br>5)splice<br>6)sort<br>7)reverse</p><h2 id="keep-alive-是如何实现的？"><a href="#keep-alive-是如何实现的？" class="headerlink" title="keep-alive 是如何实现的？"></a>keep-alive 是如何实现的？</h2><p>keep-alive 是 Vue 的内置组件，同时也是一个抽象组件，不会作为元素被渲染到页面上。<br>它用于组件缓存。当组件切换时会将组件的VNode缓存起来，<br>等待下次重新激活时，再将缓存的组件VNode取出来渲染，从而实现缓存。</p><p>常用的两个属性 include 和 exclude，支持字符串、正则和数组的形式，<br>允许组件有条件的进行缓存。还有 max 属性，用于设置最大缓存数。</p><p>两个生命周期 activated 和 deactivated，在组件激活和失活时触发。</p><p>keep-alive 的缓存机制运用LRU(Least Recently Used)算法</p><h2 id="说一下-nextTick-的原理"><a href="#说一下-nextTick-的原理" class="headerlink" title="说一下 nextTick 的原理"></a>说一下 nextTick 的原理</h2><p>在下次 dom 更新结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。<br>根据执行环境分别尝试采用：</p><p>1)Promise<br>2)MutationObserver<br>3)setImmediate<br>4)setTimeout</p><p>nextTick 主要用于内部 Watcher 的异步更新，<br>对外我们可以使用 Vue.nextTick 和 vm.$nextTick。在 nextTick 中可以获取更新完成的 dom。</p><h2 id="对比-Vue3-和-Vue2-x"><a href="#对比-Vue3-和-Vue2-x" class="headerlink" title="对比 Vue3 和 Vue2.x"></a>对比 Vue3 和 Vue2.x</h2><p>1)使用 Proxy 代替 Object.defineProperty<br>2)新增 Composition API<br>3)模板允许多个根节点</p><h2 id="Vue3-为什么使用-Proxy-代替-Object-definedProperty"><a href="#Vue3-为什么使用-Proxy-代替-Object-definedProperty" class="headerlink" title="Vue3 为什么使用 Proxy 代替 Object.definedProperty"></a>Vue3 为什么使用 Proxy 代替 Object.definedProperty</h2><p>Object.definedProperty 只能检测到属性的获取和设置，对于新增和删除是没办法检测的。<br>在数据初始化时，由于不知道哪些数据会被用到，Vue 是直接递归观测全部数据，<br>这会导致性能多余的消耗。</p><p>Proxy 劫持整个对象，对象属性的增加和删除都能检测到。Proxy 并不能监听到内部深层的对象变化，<br>因此 Vue 3.0 的处理方式是在 getter 中去递归响应式，只有真正访问到的内部对象才会变成响应式，<br>而不是无脑递归，在很大程度上提升了性能。</p><h2 id="路由懒加载是如何实现的"><a href="#路由懒加载是如何实现的" class="headerlink" title="路由懒加载是如何实现的"></a>路由懒加载是如何实现的</h2><p>路由懒加载是性能优化的一种手段，在编写代码时可以使用 import() 引入路由组件，<br>使用懒加载的路由会在打包时单独出来成一个 js 文件，可以使用 webpackChunkName 自定义包名。<br>在项目上线后，懒加载的 js 文件不会在第一时间加载，而是在访问到对应的路由时，<br>才会动态创建 script 标签去加载这个 js 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path:&#39;users&#39;,</span><br><span class="line">  name:&#39;users&#39;,</span><br><span class="line">  component:()&#x3D;&gt; import(&#x2F;*webpackChunkName: &quot;users&quot;*&#x2F; &#39;@&#x2F;views&#x2F;users&#39;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue路由钩子函数"><a href="#Vue路由钩子函数" class="headerlink" title="Vue路由钩子函数"></a>Vue路由钩子函数</h2><p>1、全局钩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1&gt; beforeEach （路由进入前调用）</span><br><span class="line">const router &#x3D; new VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2&gt; beforeResolve (2.5.0 新增) 在所有组件内守卫和异步组件被解析之后调用</span><br><span class="line"></span><br><span class="line">router.beforeResolve((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line"> &#x2F;&#x2F; ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3&gt; afterEach 路由在确认后调用</span><br><span class="line"></span><br><span class="line">router.afterEach((to, from) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、路由独享钩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; beforeEnter 路由进入前调用，beforeEnter 在 beforeEach 之后执行</span><br><span class="line"></span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;foo&#39;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、组件钩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1）beforeRouteEnter 路由确认前调用，组件实例还没被创建，不能获取组件实例 this</span><br><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;&#x2F; 可以通过回调访问实例</span><br><span class="line">    next(vm &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; vm 为组件实例</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2）beforeRouteUpdate (2.2 新增) 路由改变时调用，可以访问组件实例</span><br><span class="line"></span><br><span class="line">beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3）beforeRouteLeave 离开该组件的对应路由时调用，可以访问组件实例 this</span><br><span class="line"></span><br><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue-router的原理"><a href="#vue-router的原理" class="headerlink" title="vue-router的原理"></a>vue-router的原理</h2><p>vue-router 原理是更新视图而不重新请求页面。vue-router 共有3种模式：<br>hash模式、history模式、abstract模式。</p><p>1、hash模式<br>hash 模式使用 hashchange 监听地址栏的 hash 值的变化，加载对应的页面。<br>每次的 hash 值变化后依然会在浏览器留下历史记录，<br>可以通过浏览器的前进后退按钮回到上一个页面。</p><p>2、history模式<br>history 模式基于History Api实现，使用 popstate 监听地址栏的变化。<br>使用 pushState 和 replaceState 修改 url，而无需加载页面。<br>但是在刷新页面时还是会向后端发起请求，需要后端配合将资源定向回前端，交由前端路由处理。</p><p>3、abstract<br>不涉及和浏览器地址的相关记录。通过数组维护模拟浏览器的历史记录栈。</p><h2 id="vuex-怎么跨模块调用"><a href="#vuex-怎么跨模块调用" class="headerlink" title="vuex 怎么跨模块调用"></a>vuex 怎么跨模块调用</h2><p>跨模块调用是指当前命名空间模块调用全局模块或者另一个命名空间模块。<br>在调用 dispatch 和 commit 时设置第三个参数为 {root：true}。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    namespaced: true,</span><br><span class="line">    actions: &#123;</span><br><span class="line">      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用自己的action</span><br><span class="line">        dispatch(&#39;someOtherAction&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someOtherAction&#39;</span><br><span class="line">        &#x2F;&#x2F; 调用全局的action</span><br><span class="line">        dispatch(&#39;someOtherAction&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someOtherAction&#39;</span><br><span class="line">        &#x2F;&#x2F; 调用其他模块的action</span><br><span class="line">        dispatch(&#39;user&#x2F;someOtherAction&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;user&#x2F;someOtherAction&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vuex-如何实现持久化"><a href="#vuex-如何实现持久化" class="headerlink" title="vuex 如何实现持久化"></a>vuex 如何实现持久化</h2><p>vuex存储的状态在页面刷新后会丢失，使用持久化技术能保证页面刷新后状态依然存在。</p><p>1）使用本地存储配合，设置 state 同时设置 storage，在刷新后再初始化 vuex<br>2）vuex-persistedstate 插件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对MVVM模式的理解&quot;&gt;&lt;a href=&quot;#对MVVM模式的理解&quot; class=&quot;headerlink&quot; title=&quot;对MVVM模式的理解&quot;&gt;&lt;/a&gt;对MVVM模式的理解&lt;/h2&gt;&lt;p&gt;MVVM 对应 3个组成部分，Model（模型）、View（视图） 和 Vi</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue 学习笔记" scheme="https://blog.jddfe.com/tags/vue-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一个快速，零配置的 Web 应用打包工具 📦</title>
    <link href="https://blog.jddfe.com/posts/8237/"/>
    <id>https://blog.jddfe.com/posts/8237/</id>
    <published>2020-12-20T21:13:38.000Z</published>
    <updated>2021-06-29T04:01:49.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="🚀-宣布-Parcel：一个快速，零配置的-Web-应用打包工具-📦"><a href="#🚀-宣布-Parcel：一个快速，零配置的-Web-应用打包工具-📦" class="headerlink" title="🚀 宣布 Parcel：一个快速，零配置的 Web 应用打包工具 📦"></a>🚀 宣布 Parcel：一个快速，零配置的 Web 应用打包工具 📦</h2><blockquote><p>原文：<a href="https://hackernoon.com/announcing-parcel-a-blazing-fast-zero-configuration-web-application-bundler-feac43aac0f1">🚀 Announcing Parcel: A blazing fast, zero configuration web application bundler 📦</a></p><p>译者：<a href="https://github.com/neal1991">neal1991</a></p><p>welcome to star my <a href="https://github.com/neal1991/articles-translator/">articles-translator</a>, providing you advanced articles translation. Any suggestion, please issue or contact <a href="mailto:bing@stu.ecnu.edu.cn">me</a></p><p>LICENSE: <a href="https://opensource.org/licenses/MIT">MIT</a></p></blockquote><p>今天，我非常高兴地宣布 Parcel，一个快速，零配置的 Web 应用程序打包工具，我对于该工具的工作已经持续了几个月。 去 <a href="https://github.com/parcel-bundler/parcel">Github</a>上看看吧！</p><p>为了解决我在 Browserify 和 Webpack 等现有模块打包工具中遇到的两个主要问题：<strong>性能</strong>和<strong>配置经验</strong>，我开始研究 Parcel。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>🚀 <strong>非常快</strong>的打包时间 - 多核编译，以及文件系统缓存，这样即使在重新启动后也能快速重建。</li><li>📦对于 JS, CSS, HTML, 图片以及文件资源以及其它支持<a href="https://parceljs.org/assets.html">开箱即用</a>，<strong>不需要安装插件</strong>。</li><li>🐠在需要时使用 Babel，PostCSS 和 PostHTML <strong>自动</strong><a href="https://parceljs.org/transforms.html"><strong>转换</strong></a><strong>模块</strong> - 甚至是node_modules。</li><li>✂️ <strong>零配置</strong><a href="https://parceljs.org/code_splitting.html">代码分割</a>使用动态import() 语句。</li><li>🔥内置支持<a href="https://parceljs.org/hmr.htm">热加载</a></li><li>🚨 友好的错误日志体验 - 语法高亮显示的代码帧有助于查明问题。</li></ul><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>我被激发建立一个新的打包工具的第一个原因是性能。 我已经在数千个模块上做了一些相当大的应用程序，并且总是对现有打包工具的速度感到失望。 大型应用程序可能需要几分钟才能完成，这在开发过程中尤其令人沮丧</p><p>许多打包工具专注于快速增量重新构建性能，这是很好的。 但是，最初的构建性能对于开发和生产/ CI 构建也非常重要。</p><p>Parcel 通过使用工作进程<strong>并行编译代码</strong>，利用现代多核处理器解决了这个问题。 这导致了初始构建的巨大加速。 它还有一个文件系统缓存，可以保存每个文件的编译结果，以便更快的后续启动。</p><!-- ![Based on a reasonably sized app, containing 1726 modules, 6.5M uncompressed. Built on a 2016 MacBook Pro with 4 physical CPUs.](https://cdn-images-1.medium.com/max/2000/1*t8afejIByMpoZKSs-URTIQ.png) --><p><img src="202012210514.png" alt="202012210514"></p><h3 id="零配置体验"><a href="#零配置体验" class="headerlink" title="零配置体验"></a>零配置体验</h3><p>我建立Parcel的第二个原因是帮助解决管理配置的痛苦。大多数其它打包工具都是围绕着配置文件以及大量的插件建立起来的，为了使事情顺利进行，看到 500 行以上的应用程序配置并不罕见。</p><p>这种配置不仅繁琐耗时，而且很难正确使用，并且必须针对每个应用程序进行复制。通常情况下，这可能导致次优化的应用程序转到到生产。</p><p>Parcel 被设计为<strong>零配置</strong>：只需将它指向你的应用程序的入口点，它就能正确工作。 Parcel 支持 JS，CSS，HTML，图片，文件资源等等 - 不需要任何插件。</p><p>Parcel 的零配置体验也涉及到文件格式。当 Parcel 检测到 .babelrc，.postcssrc 等时，也会自动应用像 Babel，PostCSS 和 PostHTML 这样的<strong>转换</strong>。这甚至适用于仅用于该模块的 node_modules 中的第三方代码，因此应用程序作者不需要知道如何构建他们导入的每个模块，并且构建不会减慢不必要地在每个文件上运行 Babel。</p><p>最后，还支持代码分割和热模块重新加载等高级打包功能。在生产模式下，Parcel 自动启用缩小，未来还会进行其他优化，如 tree-shaking。</p><h3 id="未来架构"><a href="#未来架构" class="headerlink" title="未来架构"></a>未来架构</h3><p>启动一个新项目的一个好处是，我能够为 Parcel 设计一个更加现代化的架构，这个架构更加可扩展，更灵活，同时无需用户配置，并支持<strong>代码拆分</strong>和<strong>热加载</strong>等高级功能。</p><p>大多数打包工具主要关注 JavaScript，并支持其他格式。例如，默认情况下，其他文件类型通常会内嵌到JavaScript 文件中，并使用额外的插件和 hack 将其再次提取到单独的文件中。</p><p>在 Parcel 中，任何类型的文件都可以成为一等公民。添加代表输入文件的新资源类型和将类似类型的资源组合到输出文件中的打包工具很容易。</p><p>例如，分析和生成 CSS 代码的 CSS 资源类型和将 CSS 资源组合成最终打包的 CSS Packager。 JS，HTML 等存在类似的类型。这样，Parcel 完全是<strong>文件类型无关</strong>的。</p><p>你可以阅读更多关于<a href="https://parceljs.org/how_it_works.html">Parcel 如何在网站上工作</a>的信息。</p><h3 id="试试把"><a href="#试试把" class="headerlink" title="试试把"></a>试试把</h3><p>Parcel  刚刚开始，但许多应用程序已经开箱即用并且零配置！ 所以试试看吧 - 删除你的webpack/browserify配置，卸载这些插件，然后尝试Parcel。😎</p><p>欢迎向我反馈！ 你可以在Twitter上找到我<a href="https://twitter.com/devongovett">@devongovett</a>。</p><ul><li><p><a href="https://parceljs.org/">网站和文档</a></p></li><li><p><a href="https://github.com/parcel-bundler/parcel">Github</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;🚀-宣布-Parcel：一个快速，零配置的-Web-应用打包工具-📦&quot;&gt;&lt;a href=&quot;#🚀-宣布-Parcel：一个快速，零配置的-Web-应用打包工具-📦&quot; class=&quot;headerlink&quot; title=&quot;🚀 宣布 Parcel：一个快速，零配</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="工具" scheme="https://blog.jddfe.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>送给 ES6 开发者的7个hack</title>
    <link href="https://blog.jddfe.com/posts/60300/"/>
    <id>https://blog.jddfe.com/posts/60300/</id>
    <published>2020-12-19T21:13:38.000Z</published>
    <updated>2020-12-21T10:21:20.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://medium.com/dailyjs/7-hacks-for-es6-developers-4e24ff425d0b">7 Hacks for ES6 Developers</a></p><p>译者：<a href="https://github.com/neal1991">neal1991</a></p><p>welcome to star my <a href="https://github.com/neal1991/articles-translator/">articles-translator</a>, providing you advanced articles translation. Any suggestion, please issue or contact <a href="mailto:bing@stu.ecnu.edu.cn">me</a></p><p>LICENSE: <a href="https://opensource.org/licenses/MIT">MIT</a></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/9900/1*xmqGcZXL4t7mJoG1SBvErA.jpeg"></p><p>关注原来的 <a href="https://hackernoon.com/javascript-hacks-for-hipsters-624d50c76e8e">JavaScript hacks</a>，上面有一些新的好东西。<em>2018 使用 JavaScript 写代码真的又变得有意思了！</em></p><p><img src="https://cdn-images-1.medium.com/max/2000/1*4877k4Hq9dPdtmvg9hnGFA.jpeg"></p><h2 id="Hack-1-—-交换变量"><a href="#Hack-1-—-交换变量" class="headerlink" title="Hack #1 — 交换变量"></a>Hack #1 — 交换变量</h2><p>使用数组结构来交换值</p><pre><code>let a = &#39;world&#39;, b = &#39;hello&#39;[a, b] = [b, a]console.log(a) // -&gt; helloconsole.log(b) // -&gt; world// 是的，很神奇</code></pre><h2 id="Hack-2-—-使用解构的-Async-Await"><a href="#Hack-2-—-使用解构的-Async-Await" class="headerlink" title="Hack #2 — 使用解构的 Async/Await"></a>Hack #2 — 使用解构的 Async/Await</h2><p>再说一遍，数组结构真的很棒。通过和 async/await 以及 promise 结合可以让复杂的流程变得简单。</p><pre><code>const [user, account] = await Promise.all([  fetch(&#39;/user&#39;),  fetch(&#39;/account&#39;)])</code></pre><h2 id="Hack-3-—-调试"><a href="#Hack-3-—-调试" class="headerlink" title="Hack #3 — 调试"></a>Hack #3 — 调试</h2><p>对于那些喜欢使用 console.logs 来调试的人来说，现在有一些特别酷的（并且我也听说过 console.table）：</p><pre><code>const a = 5, b = 6, c = 7console.log(&#123; a, b, c &#125;)// 输出优雅的对象:// &#123;//    a: 5,//    b: 6,//    c: 7// &#125;</code></pre><h2 id="Hack-4-—-一行搞定一切"><a href="#Hack-4-—-一行搞定一切" class="headerlink" title="Hack #4 — 一行搞定一切"></a>Hack #4 — 一行搞定一切</h2><p>对于数组操作，语法可以非常紧凑</p><pre><code>// 寻找最大值const max = (arr) =&gt; Math.max(...arr);max([123, 321, 32]) // outputs: 321// 对数组求和const sum = (arr) =&gt; arr.reduce((a, b) =&gt; (a + b), 0)sum([1, 2, 3, 4]) // output: 10</code></pre><h2 id="Hack-5-—-数组拼接"><a href="#Hack-5-—-数组拼接" class="headerlink" title="Hack #5 — 数组拼接"></a>Hack #5 — 数组拼接</h2><p>拓展操作符可以用来代替 concat：</p><pre><code>const one = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]const two = [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]const three = [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;]// 老方法 #1const result = one.concat(two, three)// 老方法 #2const result = [].concat(one, two, three)// 新方法const result = [...one, ...two, ...three]</code></pre><h2 id="Hack-6-—-克隆"><a href="#Hack-6-—-克隆" class="headerlink" title="Hack #6 — 克隆"></a>Hack #6 — 克隆</h2><p>轻松克隆数组和对象：</p><pre><code>const obj = &#123; ...oldObj &#125;const arr = [ ...oldArr ]</code></pre><p>注意：这会产生一个浅克隆。</p><h2 id="Hack-7-—-命名参数"><a href="#Hack-7-—-命名参数" class="headerlink" title="Hack #7 — 命名参数"></a>Hack #7 — 命名参数</h2><p>通过结构让函数以及函数函数调用更具有可读性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getStuffNotBad = <span class="function">(<span class="params">id, force, verbose</span>) =&gt;</span> &#123;</span><br><span class="line">  ...do stuff</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getStuffAwesome = <span class="function">(<span class="params">&#123; id, name, force, verbose &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  ...do stuff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在代码的其它某个地方... 到底什么是 true, true?</span></span><br><span class="line">getStuffNotBad(<span class="number">150</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在代码的其他某个地方.. I ❤ JS!!!</span></span><br><span class="line">getStuffAwesome(&#123; <span class="attr">id</span>: <span class="number">150</span>, <span class="attr">force</span>: <span class="literal">true</span>, <span class="attr">verbose</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/2048/1*ZrJKJqBsksWd-8uKM9OvgA.png"></p><p><strong>已经全部知道了？</strong></p><p>你是一个真正的黑客，让我们继续在 Twitter上的谈话你还可以看看我的 <a href="https://toriihq.com/">Torii</a> 教学，我们让“SaaS 头痛”消失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://medium.com/dailyjs/7-hacks-for-es6-developers-4e24ff425d0b&quot;&gt;7 Hacks for ES6 Developers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a </summary>
      
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="https://blog.jddfe.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号业务域名、JS接口安全域名、网页授权三者作用</title>
    <link href="https://blog.jddfe.com/posts/11988/"/>
    <id>https://blog.jddfe.com/posts/11988/</id>
    <published>2020-12-06T21:57:39.000Z</published>
    <updated>2020-12-21T10:11:56.219Z</updated>
    
    <content type="html"><![CDATA[<p>首先，这三者都是用来做网页开发的，需要具备网页开发技能。</p><p>1、业务域名</p><p>业务域名不仅在公众号中存在，在微信小程序中也存在设置的地方。业务域名的设置是微信保障了该公众号所开发的网页是合法的（微信认为合法）。如果不设置，当输入框聚焦时，微信会弹出警告提示！像这样：</p><p><img src="2020-12-07T135857.png" alt="2020-12-07T135857"></p><p>如果在微信小程序中，当你使用内置webview想打开H5时，如果不设置业务域名，连网页也打不开。</p><p>2、JS安全域名</p><p>微信有一套JSSDK，在html中引入JSSDK可以调用相机，录音等API，如果不设置的话，你的网页也调不了这些API。</p><p>3、网页授权域名</p><p>当你需要获取用户信息时，就需要用到网页授权了。设置网页授权域名，当用户同意授权弹出框时，你就能调用获取用户信息的API，而如果不设置，你最多也只能拿到用户的openid（用户在微信的唯一标识）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先，这三者都是用来做网页开发的，需要具备网页开发技能。&lt;/p&gt;
&lt;p&gt;1、业务域名&lt;/p&gt;
&lt;p&gt;业务域名不仅在公众号中存在，在微信小程序中也存在设置的地方。业务域名的设置是微信保障了该公众号所开发的网页是合法的（微信认为合法）。如果不设置，当输入框聚焦时，微信会弹出警告</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="微信公众号" scheme="https://blog.jddfe.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>蛋壳爆雷还未跑路，某银行为啥慌了？</title>
    <link href="https://blog.jddfe.com/posts/60230/"/>
    <id>https://blog.jddfe.com/posts/60230/</id>
    <published>2020-11-25T00:50:30.000Z</published>
    <updated>2020-11-26T15:06:45.297Z</updated>
    
    <content type="html"><![CDATA[<p>最近，长租公寓蛋壳公寓出现资金链断裂，讨薪、跑路…目漫天的传闻也将成为真相。随着蛋壳爆雷，将引发了一场剧烈的地震。</p><p>无数打工人被坑，有的人甚至大半夜下着雨被房东从家里赶出来，行李全部丢在马路上，场面极为凄惨。</p><p>房东也好不到哪去，网上的视频，一个被坑的房东带着锁匠，想把自己房子的锁换掉，把租客赶走。租客报警，警察赶到阻止，警告胆敢换锁的话，房东和锁匠可能面临治安拘留，房东站在那里顿时懵了……</p><p>蛋壳不仅坑了打工人和房东，连银行也被牵扯进来。</p><blockquote><p>转自微博 - 通货朋仗</p></blockquote><p><img src="2020-11-25T165438.png" alt="2020-11-25T165438"></p><p><img src="2020-11-25T212751.png" alt="2020-11-25T212751"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近，长租公寓蛋壳公寓出现资金链断裂，讨薪、跑路…目漫天的传闻也将成为真相。随着蛋壳爆雷，将引发了一场剧烈的地震。&lt;/p&gt;
&lt;p&gt;无数打工人被坑，有的人甚至大半夜下着雨被房东从家里赶出来，行李全部丢在马路上，场面极为凄惨。&lt;/p&gt;
&lt;p&gt;房东也好不到哪去，网上的视频，一个被</summary>
      
    
    
    
    <category term="吃瓜" scheme="https://blog.jddfe.com/categories/%E5%90%83%E7%93%9C/"/>
    
    
    <category term="蛋壳公寓爆雷" scheme="https://blog.jddfe.com/tags/%E8%9B%8B%E5%A3%B3%E5%85%AC%E5%AF%93%E7%88%86%E9%9B%B7/"/>
    
    <category term="微众银行" scheme="https://blog.jddfe.com/tags/%E5%BE%AE%E4%BC%97%E9%93%B6%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>亚洲巨骗案之“一马币案”（二）</title>
    <link href="https://blog.jddfe.com/posts/14885/"/>
    <id>https://blog.jddfe.com/posts/14885/</id>
    <published>2020-11-20T23:21:46.000Z</published>
    <updated>2020-11-26T15:12:49.907Z</updated>
    
    <content type="html"><![CDATA[<p><img src="2020-11-21T141056.png" alt="2020-11-21T141056"></p><p>接上篇，讲到刘马扁费了好半天劲，结果一分钱没捞到，不得不另找财路，</p><p>当时，全东南亚的目光都在关注[依斯干达经济特区]，就跟我们现在的粤港澳大湾区差不多。无数的地产开发商都在摩拳擦掌，想要参与其中，大赚一笔。</p><p>刚好，刘马扁听说有两家建筑公司的资金链断裂，正准备出售。于是他立刻想到低价买下这俩家公司，然后自己参与开发【依斯干达经济特区】，主意虽然好，但是买公司首先要有钱。苦撑两年的刘马扁，连租办公室的贷款都还没还，信用记录不良，银行也不愿意再贷款给他。怎么才能从银行那里搞到启动资金呢？</p><p>他准备再利用一次自己的权贵人脉。因为这种高段位的操作，普通人可能一辈子也接触不到。</p><p><img src="2020-11-26T222031.png" alt="2020-11-26T222031"></p><p>首先，刘马扁在英属维京群岛注册了一家公司——【阿布达比科威特大马投资公司】，简称ADKMIC。（Abu Dhabi-Kuwait-Malaysia Investment Corporation）</p><p>接着他把这家公司的干股送给了欧泰巴、科威特和马来西亚的官员。因为干股是无偿赠送的，能够享受公司的分红，所以欧泰巴等人欣然接受。接下来，刘马扁就偷偷地把这些人列为公司股东。这么做的目的，是为了外界以为这家公司背景深厚。果然，刘马扁再去银行贷款，就轻松地贷到了几百万美元。于是他用部分贷款，买下了那两家建筑公司，同时通过他的【赢吨集团】又借了一笔钱，在【依斯干达特区】买下了一块土地。这块空土地，紧挨着【穆巴达拉基金】计划开发的地方。</p><p>这样一来，刘马扁看起来，就不只是一个赚佣金的买办，而是共同投资人。当然刘马扁买这些公司和土地，不是自己用来开发。刘马扁真正的计划，是找一个冤大头，高价接盘他这两家刚买来的建筑公司。奔着这个目的，他又开始了一系列的骚操作。首先，他在印度洋上的塞舌尔小岛，注册了两家空壳公司。一家叫做【ADIA投资公司】，另一家叫做【KIA投资公司】。而全球两大主权基金——阿布扎比投资管理局和科威特投资管理局，它们的简称也同样是ADIA和KIA。(Abu Dhabi Investment Authority；Kuwait Investment Authority)。</p><p><img src="2020-11-26T222242.png" alt="2020-11-26T222242"></p><p>这样，就会让人误以为，这两家公司和中东的两大主权基金有关。但实际上它们只是两家空壳公司。这时候，有很多亿万富翁就会问了：维尔京群岛和开曼群岛不是避税天堂吗，刘马扁为什么要去塞舌尔注册公司呢？原来刘马扁发现，这个印度洋上的塞舌尔小岛，不仅一样可以避税，还可以发行不记名的实体股票。</p><p>在设立【ADIA投资公司】时，刘马扁总共只发行了一张不记名实体股票，价值1美元。什么意思呢？也就是说，这张股票在谁的手上，谁就拥有这家公司。这种不记名实体股票，能够神不知鬼不觉地变更公司股权。不记名股票，在很多国家和地区都已经被禁止了，包括开曼群岛。但是在塞舌尔，还可以发行。</p><p>目光回到马来西亚，刘马扁不是贷款买了两家建筑公司吗？他把ADIA和KIA，这两家看起来和中东主权基金有关的投资公司，分别设为了两家建筑公司的股东。于是，在外人眼里，科威特皇室、马来西亚官员、阿联酋外交官以及两大主权基金，全都是刘马扁的合伙人。到这一步，刘马扁的精心布局已经全部完成。万事俱备，只欠韭菜。刘马扁要找的韭菜，是那种非常有钱，但对资本套路并不熟悉的人。</p><p>没多久，刘马扁就找到了合适的目标，马来西亚砂拉越州的高官——泰益．玛末。（Taib Mahmud）71岁的泰益，靠着林业发家，是马来西亚最有钱的人之一。刘马扁放出风声，说穆巴达拉基金在投资「依斯干达特区」之后，正在马来西亚寻找其他投资机会。而泰益，正好一直想找人投资砂拉越州的油棕提炼厂，于是联系上了刘马扁。刘马扁忽悠泰益说，“未来中东的投资者也许会想投资砂拉越州”，让他先买下刘马扁的建设公司以表诚意。</p><p>几个月后，刘马扁的【赢吨公司】正式将名下持有的土地，转让给泰益。还有刘马扁低价买来的建筑公司，也一并卖给了泰益。这笔交易，不仅让刘马扁大赚1.1个亿，美金，而且还让他获得了泰益旗下公司的股份。27岁，本科毕业才三年的刘马扁一战成名。赚了钱的他立马买了一辆黑色法拉利。就在他春风得意时，华尔街也注意到了他。</p><p>2008年金融危机席卷全球，由于美国经济疲软、股市冷清，高盛于是越发地看好亚洲。高盛亚洲的东南亚负责人——提姆·莱斯纳，已经在马来西亚布局十年。他通过高盛在马来西亚的另一名员工——吴崇华（Roger Ng），认识了刘马扁。莱斯纳胃口很大，而刘马扁正好也在寻找下一个机会。两人一拍即合。刘马扁觉得自己机关算尽、精心布局，才赚了一亿美元，而卡尔杜恩执掌百亿美金，享有巨大的权力和地位，轻轻松松就能日进斗金。</p><p><img src="2020-11-26T104929.png" alt="2020-11-26T104929"></p><p>于是，刘马扁心想，不如自己也借着高盛的投行背景，在马来西亚搞一个主权基金。事情又回到了原点，钱从哪里来？还记不记得前面说过，穆巴达拉基金的资金是用石油做担保，在国际市场上募集来的。于是刘马扁准备照虎画猫，他把目光看向了马来西亚外海、拥有丰富油田与天然气的登嘉楼州。不过登嘉楼州是米占苏丹的地盘儿，（Alexandra Milchan），所以刘马扁必须先搞定他。</p><p><img src="2020-11-26T223745.png" alt="2020-11-26T223745"></p><p>于是刘马扁故技重施，通过米占的姐姐，把(ADKMIC )公司的干股送给了米占。然后刘马扁向米占提议，可以仿照穆巴达拉基金的模式，成立主权基金。为了说服米占，刘马扁说自己认识高盛的银行家，能够通过高盛募集大笔的资金。之后刘马扁带着莱斯纳和吴崇华，到吉隆坡晋见米占苏丹。他们给这个项目取了个代号，叫做【冠冕计划】。</p><p>2009年二月，「登嘉楼投资机构」正式成立，简称TIA。（Terengganu Investment Authority）在明面上，刘马扁是TIA的投资顾问，但实际上，他才是背后的操盘手。刘马扁原计划，以登嘉楼州未来的石油收入作为抵押，发行十四亿美元的【伊斯兰债券】。但是就在定案之前，米占苏丹却突然反悔。他觉得管理团队还没有完全确定，不用着急发行债券。可是刘马扁怕煮熟的鸭子飞了，照样发行了债券。于是米占苏丹警告刘马扁赶紧收手，否则就撤销基金。同时，金融圈也开始盛传，刘马扁坑骗过砂拉越州的部长泰益，致使米占苏丹越发地不信任刘马扁。</p><p>就在刘马扁功亏一篑之际，事情却突然发生了转机。</p><p><img src="2020-11-26T224013.png" alt="2020-11-26T224013"></p><p>原来就在米占苏丹发难的一个月前，副首相纳吉布赢得了大选，成为了马来西亚的新总理。纳吉布上任后宣称，要在数年内让马来西亚跻身发达国家，因此需要庞大的资金支持。于是刘马扁再次向纳吉布提议建立主权基金，而且他还提出了一个让纳吉布无比心动的建议：可以利用这个基金来募集政治献金。也就说，纳吉布可以用这笔基金来回馈选民和政治盟友，从而为纳吉布赢得支持。谁支持我，我就给谁投钱。为了进一步获取纳吉布的信任，刘马扁还为纳吉布引荐了沙特王子图尔基（Turki Bin Abdullah）。</p><p>最终，一家全新的马来西亚主权基金成立，取名为【一个马来西亚发展有限公司】，简称“一马公司”（1MDB）。（1 Malaysia Development Berhad）</p><p>一马公司成立之初唯一的资金来源，就是米占苏丹的TIA（登嘉楼投资机构）。TIA在刘马扁的操作下，发行了十四亿美元的伊斯兰债券，这笔钱全部转入联邦政府手中。也就是说，偿还这笔债券的责任，会落到一马公司的头上，而米占苏丹则不赚不亏被踢出局。</p><p>堂堂的苏丹，就这样成了刘马扁的打工人。完成收购后，刘马扁向纳吉布保证：未来，一马公司将会吸引中东资金投入，也会募集到国际游资。但是纳吉布并不知道，和图尔基王子的见面，也是刘马扁的精心设计。其实，刘马扁和图尔基王子才刚认识不久。在大多数人的印象里，阿拉伯国家的王子都特别的有钱。但实际上沙特当时的国王——阿卜杜拉有二十个孩子，图尔基王子只是其中并不受宠的一个。</p><p>他曾经是沙特的空军飞行员，退伍之后开始经商，但并没有赚到钱。图尔基有一家石油勘探公司——【沙乌地石油国际】（PetroSaudi International），简称PSI。他希望能利用自己王子的身份，到别的国家争取石油勘探权。但是PSI其实也是一家空壳公司，并没有做成过几笔生意。和欧泰巴一样，图尔基王子也是刘马扁最需要的人，有身份、有地位，但是骨子里特别需要钱。</p><p>而刘马扁就是擅长找到这些人，并利用他们的身份为自己背书。刘马扁让图尔基花五十万美金，在地中海上租下了一艘豪华游轮（Alfa Nero），邀请纳吉布一家登船度假。在游轮上，图尔基与纳吉布当即拟定了一份合作备忘录。几天之后，图尔基用沙特的官方信纸，写了一封信给纳吉布，正式提出双方共同的投资方案：PSI将以名下资产——在土库曼与阿根廷的油田开发权，总值二十五亿美元，与一马公司共同投资。而一马公司，则投入十亿美元。</p><p><img src="2020-11-26T225226.png" alt="2020-11-26T225226"></p><p>但实际上，PSI公司所谓的土库曼油田位于里海，和阿塞拜疆存在纠纷，根本不值25亿美元。十亿美元的大单谈成后，刘马扁开始为一马公司招兵买马。总理纳吉布出任一马公司的顾问团主席，拥有董事会成员的任命权和公司的决策权。然后纳吉布对刘马扁充分授权，让刘马扁安排了许多他自己的人马。虽然整个一马公司的组织名单里并没有刘马扁，但是大家都知道，刘马扁才是这家公司的实际决策者。接着，为了通过和PSI的合作开发案，刘马扁和PSI公司的人展开了行动。</p><p>他们先去摩根大通在瑞士的一家小分行，开了一个账户，作为PSI与一马公司的合作户头。然后他们又找到了前雷曼兄弟的分析师，曾任职美国能源部的爱德华．莫尔斯（Edward Morse）。仅用两天时间，莫尔斯就给出了一份分析报告。</p><p>结论是，PSI公司的资产估值高达36亿美元！</p><p>当然，这份2天就出炉的报告，让莫尔斯自己拿到十万美元佣金。不只是莫尔斯，刘马扁找来的所有专业人士全都乐于配合。没办法，有钱就是可以为所欲为。最后，董事会提案通过，一马公司将投资十亿美元与PSI合作开发油田。一般来说，规模如此庞大的投资计划，少则数个月，多则要一年以上才能完成。但是，从图尔基王子在八月下旬写信给纳吉布算起，刘马扁只花了一个月，就完成了这个数十亿美元的合资案。</p><p>到这里，刘马扁已经成为了东南亚资本圈里的风云人物，但是刘马扁却还不满足。</p><p><img src="2020-11-26T225401.png" alt="2020-11-26T225401"></p><p>2009年9月，德意志银行马来西亚分行的主管，给马来西亚央行打了一个电话。德意志银行发现，一马公司的汇款十分可疑。因为一马公司的十亿美元，应当直接汇入与PSI在瑞士共同开设的户头。但是，现在有一笔7亿美元的巨款，被要求汇入顾资银行苏黎世分行，而且只提供账号，没有户名。按照一马公司的说法，这个户头也属于PSI。这笔7亿的汇款，是为了偿还先前欠PSI的钱。很快，马来西亚央行回复，可以放行，只要钱最后是进到PSI的相关户口就没有问题。于是，在当天下午，一马公司的十亿美金被汇出。三亿美金汇到了摩根大通的瑞士分行，另一笔七亿美元则汇到了顾资银行的神秘账户。</p><blockquote><p>顾资银行（Coutts Bank），是一家专门服务最顶级、最富有客户的私人银行。</p></blockquote><p>7亿美金汇入的神秘账户属于一家登记在塞舌尔的公司——Good Star。Good Star的唯一股东，就是刘马扁。实际上根本没有什么7亿美元的欠款，Good Star公司也是一个月前才成立的，这一切都是刘马扁用来套现的诡计。7亿美元到手后，刘马扁立马开始分赃。他先以“委托私募基金投资”的名义，分两笔打给了参与合谋的PSI高管，共计一亿五千三百万，其中图尔基王子分得七千七百万美元。然后，刘马扁当然要回报总理纳吉布。他给纳吉布的老婆罗斯玛买了数千万美金的珠宝，还在伦敦、洛杉矶、纽约购买豪宅给纳吉布的家人享用。其中一座（Park Laurel）就在纽约中央公园旁边，面积高达七千七百平米。这些豪宅统统记在纳吉布的继子，刘马扁的好兄弟——里查的名下。而纳吉布也从来都不过问刘马扁的资金来源，一旦有人问起，纳吉布就撇得一干二净。</p><p>显然，刘马扁已经成了纳吉布的白手套。给同伙分完钱后，刘马扁手上还剩下大把的现金。但是他并不满足，他要把钱带到美国，供他挥霍、结交名流、然后继续新的冒险。</p><p>当时，已经有大批的外国官员，用贪污来的钱在美国购置资产，引起了美国监管部门的注意。为了安全起见，刘马扁先开设了一个ＩＯＬＴＡ（音译：艾欧塔）信托账户。（Interest On Lawyer Trust Accounts）这种账户的好处是，律师不会像银行一样对客户进行尽职调查，还会依法对客户的汇款细节进行保密。</p><blockquote><p>ＩＯＬＴＡ账户，是美国律师事务所大约从三十年前开始，专门为客户开设的一种账户，通过这个账户替客户存放短期资金。</p></blockquote><p>因此外界只能看到律师事务所的名称，查不到资金的真正来源。这简直就是为刘马扁这样的，专门准备的洗钱工具!刘马扁为了开ＩＯＬＴＡ账户，找上了谢尔曼·思特灵律师事务所（Shearman &amp; Sterling）。这家律师事务所位于纽约曼哈顿，是全美最顶级的律师事务所。但他们平常的业务都是大型企业并购，根本就看不上刘马扁这种小角色。于是刘马扁又故技重施，声称自己和马来西亚以及中东的主权基金都有关系，准备在美国进行投资。果然，谢尔曼律师事务所的态度立马转变，替他开设了ＩＯＬＴＡ账户。</p><p>之后的一年里，刘马扁累计将三亿六千九百万美元，转入自己的ＩＯＬＴＡ账户。并且在这段时间里，刘马扁和他的哥们儿尽情地挥霍，喝酒、赌博、买私人飞机、租豪华游艇、招待好莱坞巨星。包括让小甜甜布兰妮大跳生日艳舞。</p><p>刘马扁挥金如土，为的就是吸引最有钱、最有名的人，好进一步扩大自己的人脉。刘马扁有名媛情结，从大学时代起，就对一位名媛深深着迷。有钱之后，刘马扁在第一时间就与她结交。</p><p><img src="2020-11-26T225640.png" alt="2020-11-26T225640"></p><p>这位名媛就是帕里斯·希尔顿，希尔顿酒店集团的继承人，真正的名媛。</p><p>老司机们都知道她，懂的都懂，不多介绍。</p><p>刘马扁得知，希尔顿的好朋友——乔伊·麦克法兰，曾经拍过几部低成本电影，正准备成立一家电影制作公司。于是，刘马扁就和他的好兄弟提供资金，成立了红岩电影（Red Granite Pictures），正式进军好莱坞。这家公司对外宣称创始人是里查·阿兹和乔伊·麦克法兰，当然刘马扁又一次隐藏在幕后操盘。他们的第一部电影，就是著名的R级片《华尔街之狼》，由大导演马丁·斯科塞斯执导，小李子主演，这部电影的预算高达1亿美元！</p><p><img src="2020-11-26T225823.png" alt="2020-11-26T225823"></p><p><img src="2020-11-26T225854.png" alt="2020-11-26T225854"></p><p>小李子过生日时，刘马扁送了他毕加索的画和马龙·白兰度的奥斯卡奖杯。</p><p>除了搞电影，刘马扁还准备做音乐。刘马扁成立了一家【红春】音乐制作公司（Red Spring），打算找最好的音乐人替萧亚轩制作专辑，让萧亚轩红到美国。他花了三百万美元，请著名音乐人法瑞尔·威廉姆斯为萧亚轩写了三首曲子，并且和萧亚轩合拍ＭＶ。</p><p>另外，他还花四百万美元请艾莉西亚·凯斯（Alicia Keys）和她的老公史监制这张专辑，协助萧亚轩打开美国市场。不过，尽管刘马扁准备了一千两百万美元的预算，萧亚轩最后并没有做完这张专辑。</p><p>刘马扁十分享受这种置身权贵，无所不能的感觉，但这需要源源不断的金钱来维系。他和同伙在两年间，从一马公司陆续捞走了二十亿美元。但大部分钱都被瓜分，然后拿去挥霍。</p><p>等到《华尔街之狼》快要开机，刘的钱已经不够烧了，他必须想办法再弄一笔钱。雪上加霜的是，有钱之后的刘马扁过于高调，引起了图尔基王子的不满。刘马扁和PSI公司的关系也闹僵了，于是他不得不物色新的同伙。就在这时，刘马扁突然看到一则新闻：有一个集团要卖酒店，买家竞争激烈，其中一家引入了中东基金——阿尔巴投资。</p><blockquote><p>这个阿尔巴投资的背后，是阿布达比的另一家主权基金——国际石油公司（International Petroleum Investment Company），简称IPIC。</p></blockquote><p>IPIC的资产高达七百亿美元，总经理卡登在金融圈里以爱吃回扣出名。刘马扁得到消息之后，立马故意参与到饭店的竞购中，成功通过关系结交到了卡登。卡登虽然不像欧泰巴和图尔基王子一样缺钱，但是他却更加贪婪。而刘马扁这次要联合卡登布一个更大的局，从一马公司榨出更多的钱。</p><p><img src="2020-11-26T230050.png" alt="2020-11-26T230050"></p><p>2012年3月，刘马扁和自己的“老”搭档，高盛的莱斯纳、吴崇华，飞往阿布扎比，见到了地表最有钱的人之一：曼苏尔亲王（Sheikh Mansour Bin Zayed）。他是英超曼城足球队的老板，也是IPIC的董事长，身价高达四百亿美元，跟一个百度的市值差不多。许多华尔街的大银行都隔三差五地拜访IPIC，但从来没有人能见到曼苏尔亲王。多亏了刘马扁的新朋友卡登，从中牵线，他们才能艰难地见到曼苏尔亲王。</p><p>接下来，刘马扁三人向曼苏尔亲王讲述了他们的计划。高盛打算替一马公司发行三十五亿美元的公司债，并拿笔钱来投资世界各地的的火力发电厂。买下这些发电厂之后，一马公司将为这些发电厂另外成立一家公司，并且在马来西亚上市。买壳，装修，卖壳，上市割韭菜。这样一通操作下来，预估能够赚到五十亿美元！</p><p>而刘马扁一行人来这的目的，就是希望ＩＰＩＣ能为这批公司债提供担保，好让其他投资者放心投资。如果ＩＰＩＣ同意，将来就能以非常优惠的价格认购即将上市的公司股票。曼苏尔亲王十分信任卡登，虽然大型投资案都是由他亲自拍板，但一般只要过了卡登这一关就行，就不需要再提交董事会讨论。在刘马扁等人晋见以前，卡登已经提前和曼苏尔亲王通过气了，因此曼苏尔亲王同意为一马公司提供担保。</p><p>不过这个计划依然是刘马扁精心设计的骗局。醉翁之意不在酒，刘马扁和卡登等人的真正目的，才不是投资什么火力发电厂。他们只是想从一马公司捞钱。</p><p>根据刘马扁的计划，一马公司将发行17.5亿美元的十年期债券，而高盛将从中收取高达1.9亿美元的承销费。这个数字高的就只剩两个字——离谱！按照业界常见的行情，应该是一百万美元左右。而这一笔案子，高盛的收益是正常情况的一百九十倍！之所以会收取这么高的承销费，主要是因为，刘马扁希望高盛先以自有资金买下全部债券，然后高盛再去另外找买主。换言之，一马公司将可以很快拿到钱，而高盛将承担所有的风险。之所以这么做，原因也很简单，刘马扁能够最快速地搞到钱。</p><p>这项离谱的计划，引起了高盛内部的激烈讨论。最后在莱斯纳的极力游说下，得到了高盛总裁盖瑞·康恩（Gary Cohn）的力挺。高盛之所以会最终通过这个案子，其实有一个心照不宣的理由。那就是，这笔交易会大大拉高盛亚洲部那一年的业绩和奖金。所有人都是精明鬼，只有马来西亚的股民是替死鬼。</p><p>2012年五月二十一日，高盛将17.5亿美元汇入一马公司能源部的账户里。隔天，一笔五亿六千万美元的款项，被汇入了一家注册在英属维京群岛的【阿尔巴投资】公司。一马公司声称，这笔巨款是付给IPIC作为提供担保的费用。</p><p>是不是感觉，这味道有点熟悉。没错，刘马扁又一次故技重施!</p><p>这个【阿尔巴投资】（Aabar Investment Ltd.）公司跟IPIC根本没有关系，它其实是刘马扁在两个月前成立的。刘马扁故意把名字取得跟真正的阿尔巴投资公司「Aabar Investments PJS」差不多，并且还把卡登和曼苏尔亲王的名字列在股东名单中。</p><p>这就是刘马扁的惯用伎俩，谎称自己获得了中东主权基金的投资，从而蒙骗一马公司共同投资。然后成立名字相似的空壳公司，最后把一马公司的资金转走。只不过这一次和卡登联手，刘马扁玩的规模更大。</p><p><img src="2020-11-26T230225.png" alt="2020-11-26T230225"></p><p>为了确保不引起外界注意，他们将这笔巨款又转入了瑞士的「安勤私人银行」（Falcon Private Bank）。而这家银行，就是卡登自己的私人银行！是卡登在金融危机期间，向美国AIG集团买下的。</p><p>五个月后，高盛梅开二度，再次替一马公司发行17.5亿美元的公司债，这一次高盛收取的佣金为1.14亿美元。刘马扁还是一模一样，把资金转走。这两笔大生意，让莱斯纳在2012年赚了一千万美元，成为高盛收入最高的员工之一。不过这只是小钱，接下来两年，刘马扁和同伙总共瓜分了十四亿美元，其中有超过两亿美元流入莱斯纳和他亲戚的账户，而卡登也分到了四亿。</p><p><img src="2020-11-26T230403.png" alt="2020-11-26T230403"></p><p>不过，纸终究保不住火。刘马扁满世界的高调挥霍，《华尔街之狼》的无预算上限拍摄，早就传回了马来西亚，传遍了大街小巷。其实早在高盛第一次替一马公司发行债券时，吉隆坡就爆发了十万人的反贪大游行。从高空鸟瞰，整个市中心都被穿着黄色Ｔ恤的群众淹没。示威群众高举着纳吉布老婆罗斯玛的画像，大声质问买珠宝的钱从哪里来的？只不过当时，可怜的马来人，还以为一马公司在投资“绿色”能源，投资高科技产业。他们不知道，刘马扁早用五鬼搬运之法，将一马公司和马来人的未来偷偷搬空。</p><blockquote><p>一马弊案最后如何败露？调查此事的检察官为什么会被埋进水里？刘马扁现在又躲在何处？</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;2020-11-21T141056.png&quot; alt=&quot;2020-11-21T141056&quot;&gt;&lt;/p&gt;
&lt;p&gt;接上篇，讲到刘马扁费了好半天劲，结果一分钱没捞到，不得不另找财路，&lt;/p&gt;
&lt;p&gt;当时，全东南亚的目光都在关注[依斯干达经济特区]，就跟我们现在</summary>
      
    
    
    
    <category term="吃瓜" scheme="https://blog.jddfe.com/categories/%E5%90%83%E7%93%9C/"/>
    
    
    <category term="一马币案" scheme="https://blog.jddfe.com/tags/%E4%B8%80%E9%A9%AC%E5%B8%81%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>亚洲巨骗案之“一马币案”（一）</title>
    <link href="https://blog.jddfe.com/posts/21156/"/>
    <id>https://blog.jddfe.com/posts/21156/</id>
    <published>2020-11-20T21:13:38.000Z</published>
    <updated>2020-11-26T15:14:59.681Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自B站-阿牛读财</p></blockquote><p>今天这个瓜，内容实在过于丰富，涉及颇多名词和名人，所以还吃瓜的小伙伴们搬好小板凳，换个舒服的姿势，慢慢品尝。</p><p>这个是一桩震惊世界的金融大案 —— “一马币案”，不仅让资本界的一些人慌了阵脚，连一向虚荣繁华的好莱坞电影圈，都纷纷退出了群聊，不想和它沾上关系。从马来西亚前总理<strong>纳吉布</strong>，排到了奥斯卡奖的得主<strong>小李子</strong>，以及名媛<strong>帕利斯·希尔顿</strong>和澳洲名模<strong>米兰达·可儿</strong>等一众名利场女性。</p><p><img src="2020-11-21T141056.png" alt="2020-11-21T141056"></p><p>一马币案钱权交易玩弄人心，瞒天过海金蝉脱壳，这是一个比电影还要精彩的真实故事。</p><p><img src="2020-11-21T133844.png" alt="2020-11-21T133844"></p><p>案中的男主是一名马来西亚华裔金融家——刘特佐Jho Low，祖籍广东揭阳的马来西亚华人，是个不折不扣的富二代。</p><p>故事开始，从刘上学、发展人脉到发家史，了解整个案件。为了方便，以下将主角称为刘马扁。</p><p>1998年，17岁的刘马扁被父亲送到哈罗公学读高中。哈罗公学是腐国最好的私立学校之一，英国首相丘吉尔诗人拜伦前印度总理尼赫鲁签。约旦国王侯赛因一事都毕业于哈罗公学。</p><p><img src="2020-11-21T141246.png" alt="2020-11-21T141246"></p><p>刘马扁在哈罗的成绩平淡无奇，但接受过刘马扁的人都对他的交际能力刮目相看。刘马扁一开学就结识了文莱和科威特的皇室成员，还通过社区联谊和一个大学生成为了好朋友。这个大学生叫做里查·阿兹，是未来刘马扁打进马来西亚政要圈的金钥匙。因为里查·阿兹的爸爸是马来西亚的教育部长（这是一个从拼爹到坑爹的故事）。</p><p><img src="2020-11-21T141357.png" alt="2020-11-21T141357"></p><p>之前我们就介绍过，刘马扁在马来西亚还算是个富二代，但是来到了哈罗公学之后，他才发现人比人气死人自己几千万的家族财富还不够别人的零头，自己综合实力不行，那就只能跪舔，在努力融入上流圈子的过程中，刘马扁开始尝到了权势的甜豆。有一次他不知道从哪弄来了文莱大使馆的信纸，伪造出一封皇室预定座位的信件，交给伦敦一家顶级夜总会。这家夜总会信以为真。于是当晚刘马扁成功带着几个同学混入会所和店里的嫩模狂欢了一夜。自此以后，刘马扁就学会借助别人的身份地位来为自己达成目的，也就是狗仗人势。从哈罗毕业后，刘马扁被送到美国常春藤名校。宾夕法尼亚大学就读于闻名世界的沃顿商学院，沃顿商学院和哈罗公学一样，大多数学生都是富二代，并且培养了一批金融巨鳄和国际骗徒。比如巴菲特和川普。</p><p><img src="2020-11-21T141518.png" alt="2020-11-21T141518"></p><p>尝过权势甜头的刘马扁，进入沃顿的主要精力也不在学习上，而是开始变本加厉的培养人脉。据说当时川普的女儿伊万卡也在沃顿商学院读书，刘马扁就写信邀请伊万卡一起去川普的赌场玩，不过被伊朗卡拒绝，因为她说她才不想参合他爸爸的鸟赌场。为了打响自己的名头，刘马扁经常给学院的院刊沃顿期刊投稿，但其实这些文章都是刘马扁超来的。他一字不漏的抄袭华尔街的分析报告竟然也没有人发现，毕竟那个时候还没有普及查重系统。就这样，并没有多少真才实学的刘马扁因为在院刊上发表了许多文章，甚至在圈内被视为投资高手。</p><p><img src="2020-11-21T141711.png" alt="2020-11-21T141711"></p><p>2003年，刘马扁申请了GAP YEAR，他的同学一般都利用GAP YEAR去做做慈善，四处游玩或者勤工俭学体验生活。只有刘马扁直接拜托几位阿拉伯土豪同学为他安排了一趟中东旅行。他跟着这些土豪专门拜访中东最有钱的家族势力，最庞大的企业目的只有一个。为了结交当地的巨贾政要，苦心钻研的成果是刘马扁认识了一个大人物，阿联酋的先进外交官欧泰巴。欧泰巴的父亲是阿联酋的第一任石油部长，也是阿联酋的开国元勋。曾经六次担任OPEC主席。不过，欧泰巴虽然出身豪门能力出众，但是他本人的地位比较尴尬，因为欧泰巴的父亲有四个老婆生了一打孩子给他的钱并不多。</p><p><img src="2020-11-21T140908.png" alt="2020-11-21T140908"></p><p>作为一个外交官赚不到太多钱，欧泰巴还要经常打顶和王室的关系，因此开销巨大并不太懂商业的欧泰巴。当时满脑子想的都是怎么利用自己的人脉，私下里赚些外快。可以说欧泰巴刚好就是刘马扁最需要的那种人，有钱有势，有影响力，有人脉，但是需要赚更多的钱。刘马扁看穿了欧泰巴想要赚钱的心态，于是跟他大谈东南亚，尤其是马来西亚有多少投资机会，但其实当时的刘马扁完全没有做过生意，在马来西亚的商机也没有半点门路。在刘马扁的忽悠下，欧泰巴又把刘马扁引荐给了一位真正的大佬卡尔杜恩。和欧泰巴相比卡尔杜恩更年轻，更有权势也更野心勃勃，因为他管理着阿布扎比的一只主权基金——穆巴达拉。</p><blockquote><p>什么是主权基金主权基金？</p><blockquote><p><em>可以简单粗暴的理解为国库之主权。国家政府所设立的用来长期投资的金融资产或者基金，一般由专门的政府投资机构管理。主权基金的钱一般来源于国家盈余，外汇储备，自然资源出口，英语等等，可以说是真正意义上的“国家队”。</em></p></blockquote></blockquote><blockquote><p>题外话：</p><blockquote><p>阿联酋最富的酋长国不是迪拜，而是阿布扎比]，阿联酋九成的石油产量都是出自阿布扎比，阿布扎比的国家队就是穆巴达拉和其他中东国家的主权基金不同，穆巴达拉不是拿政府卖石油赚的钱去投资，而是以石油做担保，从国际金融市场上募资，然后回头投资自己的国家。在阿布达比投资，房地产，半导体等产业协助阿布扎比进行经济转型。<br>阿布扎比现在也是一带一路上重要的节点。</p></blockquote></blockquote><p>说回刘马扁。</p><p>他看着不到三十岁的卡尔杜恩掌握着富可敌国的国家资源。当然羡慕嫉妒恨。在阿布扎比的所见所闻，让刘马扁明白了另一个道理，想成功狗仗人势伏低做小根本不够，还需要步子迈得更大，路子的更野。从中东返回学校之后，刘马扁到了人生的十字路口。</p><p>一般来说，沃顿的本科生到了大四就要开始找工作了，要么去华尔街加入高盛、麦肯锡这样的大型投行或者咨询公司，要么就回家继承家产。</p><p>但是开了天眼的刘马扁明白，打工人员挣不了大钱，只有像卡尔多那样掌握国家资源才能一夜暴富。</p><p><img src="2020-11-21T143603.png" alt="2020-11-21T143603"></p><p>于是，刘马扁在英属维京群岛注册了自己的第一家公司。赢顿集团（Wynton group），年纪轻轻的他准备忽悠中东的金主，通过赢顿集团来投资马来西亚人。</p><p>虽然刘马扁只是做了一个空壳公司，但是他明白在哈罗公学和沃顿积累的人脉就是他的本钱。</p><p><img src="2020-11-21T143921.png" alt="2020-11-21T143921"></p><p>2005年，刘马扁从沃顿毕业返回大马之后的第一件事就是在吉隆坡地标建筑双子星大楼为自己的赢顿集团租下了整层办公室。当然租办公室的钱是刘马扁找银行贷的，还记得有一个部长爸爸的里查·阿兹吗？通过里查·阿兹的牵线，刘马扁成功认识了纳吉布的弟弟和老婆，搭上了纳吉布家族。</p><p><img src="2020-11-21T144247.png" alt="2020-11-21T144247"></p><p>纳吉布家族是马来西亚的政治世家，纳吉布的父亲和姨丈都当过总理。</p><p>不过对于已经当上副总理的纳吉布来说，刘马扁这种小年轻根本入不了他的法眼。纳吉布家族也看不起刘马扁。转机出现在2007年，为了争取总理之位，纳吉布需要为第二年的大选准备政绩。而这时，马来西亚的主权基金国库控股打算找人合伙一起来开发马来西亚南部临近新加坡的一块土地，他们希望把这块地发展成足以抗衡新加坡的金融中心。这个计划叫做伊斯干达经济特区（相当于马来西亚的深圳特区）。</p><p><img src="2020-11-21T144723.png" alt="2020-11-21T144723"></p><p>刘马扁预感自己的机会来了，如果他能够帮大马主权基金国库控股找到合伙人，就能从中赚到一大笔佣金。</p><p>刘马扁赶紧写了一份电子邮件给欧泰巴，向他详细介绍了伊斯干达经济特区计划，让欧泰巴去联系卡尔杜恩，引入穆巴达拉基金。之后，他又赶紧安排国库控股的主管飞到阿布扎比与欧泰巴等人见面。</p><p><img src="2020-11-21T145019.png" alt="2020-11-21T145019"></p><p>在刘马扁贺欧泰巴的引荐之下，穆巴达拉欣欣决定投资五亿美金参与开发。依斯干达经济特区这次成功的撮合对刘马扁来说是一箭三雕。</p><ul><li>第一，向纳吉布家族证明了自己有能力从中东找来资金。</li><li>第二，向欧泰巴和卡尔杜恩证明了马来西亚的确有投资机会。</li><li>第三，刘能够从中获得一大笔佣金。</li></ul><p>但是刘马扁没有想到的是，国库控股由专业团队管理，直接拒绝了他的中介佣金。刘马扁也找不到任何能捞一笔的机会。至此，刘马扁学到了第三课。光会当舔狗，人脉NB也不行，自己攒的局还得自己做主才行。</p><p>下一篇：<a href="/posts/14885/" title="亚洲巨骗案之“一马币案”（二）">亚洲巨骗案之“一马币案”（二）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文整理自B站-阿牛读财&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天这个瓜，内容实在过于丰富，涉及颇多名词和名人，所以还吃瓜的小伙伴们搬好小板凳，换个舒服的姿势，慢慢品尝。&lt;/p&gt;
&lt;p&gt;这个是一桩震惊世界的金融大案 —— “一马币案”，不仅让</summary>
      
    
    
    
    <category term="吃瓜" scheme="https://blog.jddfe.com/categories/%E5%90%83%E7%93%9C/"/>
    
    
    <category term="一马币案" scheme="https://blog.jddfe.com/tags/%E4%B8%80%E9%A9%AC%E5%B8%81%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>老人言</title>
    <link href="https://blog.jddfe.com/posts/7970/"/>
    <id>https://blog.jddfe.com/posts/7970/</id>
    <published>2020-11-19T20:29:48.000Z</published>
    <updated>2020-11-23T04:20:27.800Z</updated>
    
    <content type="html"><![CDATA[<p>荒田无人耕，一耕有人争；</p><p>肚里无食无人知，身上无衣无人欺；</p><p>合伙租船船会漏，两家喂驴驴会瘦</p><blockquote><p>更新于 2020-11-20</p></blockquote><hr><p>知者不言，言者不知。</p><p>智者语迟，愚者话多。</p><p>人不贵在牙尖嘴硬，而贵在耳聪目明。</p><blockquote><p>摘自道德经，更新于 2020-11-21</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;荒田无人耕，一耕有人争；&lt;/p&gt;
&lt;p&gt;肚里无食无人知，身上无衣无人欺；&lt;/p&gt;
&lt;p&gt;合伙租船船会漏，两家喂驴驴会瘦&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更新于 2020-11-20&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;知者不言，言者不知。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="每日最佳" scheme="https://blog.jddfe.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%80%E4%BD%B3/"/>
    
    
    <category term="道德经" scheme="https://blog.jddfe.com/tags/%E9%81%93%E5%BE%B7%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>假如互联网大佬们去摆摊</title>
    <link href="https://blog.jddfe.com/posts/14122/"/>
    <id>https://blog.jddfe.com/posts/14122/</id>
    <published>2020-11-17T20:50:14.000Z</published>
    <updated>2020-11-18T04:56:46.137Z</updated>
    
    <content type="html"><![CDATA[<p>假如互联网大佬们去摆摊…</p><p>时光如果倒流，英雄莫问出处</p><blockquote><p>转自微博-我是K董</p></blockquote><p><img src="2020-11-18T125307.JPG" alt="2020-11-18T125307"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假如互联网大佬们去摆摊…&lt;/p&gt;
&lt;p&gt;时光如果倒流，英雄莫问出处&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转自微博-我是K董&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;2020-11-18T125307.JPG&quot; alt=&quot;2020-11-18T125</summary>
      
    
    
    
    <category term="每日最佳" scheme="https://blog.jddfe.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%80%E4%BD%B3/"/>
    
    
    <category term="每日最佳" scheme="https://blog.jddfe.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%80%E4%BD%B3/"/>
    
    <category term="全民摆摊" scheme="https://blog.jddfe.com/tags/%E5%85%A8%E6%B0%91%E6%91%86%E6%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>基金投资新手入门科普宝典</title>
    <link href="https://blog.jddfe.com/posts/56721/"/>
    <id>https://blog.jddfe.com/posts/56721/</id>
    <published>2020-11-14T15:06:10.000Z</published>
    <updated>2020-11-17T12:54:33.343Z</updated>
    
    <content type="html"><![CDATA[<p>网上关于基金投资教学的文章有很多，但都太过于专业，太过于繁琐，今天就用简单直白的内容重新认识基金。</p><p><strong>直接告诉你 怎么买、买多少、怎么卖</strong></p><p>开始前先了解下基金的分类</p><h2 id="基金的分类"><a href="#基金的分类" class="headerlink" title="基金的分类"></a>基金的分类</h2><p>注：以下提到的收益率为有专业操作经验的普通投资者的近一年预估收益率。</p><ul><li><strong>货币型基金：</strong>是以银行存款，短期债券保本型产品为主的类型，一般收益在 2.5%-3.5% 低风险，比如我们常用的余额宝和天天基金的活期宝，适合1年内的资金打理，随取随用。</li><li><strong>债券型基金：</strong>成分80%以上是国债和企业债，收益在6%-8%，中风险，纯债基金100%投资于债券，不碰股票。特点是波动小，收益比较稳定。适合1-2年资金的打理。</li><li><strong>混合型基金：</strong>成分现金、债券、股票都有，进可攻退可守，非常灵活，收益在10%-13%中高风险</li><li><strong>股票型基金：</strong>成分80%以上是股票，收益在12%-30%+，高风险。</li><li><strong>指数型基金（被动型基金）：</strong>不主动寻求取得超越市场的表现，而是试图复制指数的表现。一般选取特定的指数作为跟踪的对象，因此通常又被称为“指数型基金”。相当于在股票市场上，把每种股票都买一点，最后追求一个市场平均收益率的基金。</li><li><strong>ＥＴＦ：</strong>交易型开放指数基金，通常又称为“交易所交交易基金”，是一种在交易所上市交易的、基金份额可变的一种开放式基金。</li><li><strong>ＬＯＦ：</strong>上市开放式基金，是一种既可以在场外市场进行基金份额申购赎回，又可以在交易所（场内市场）进行基金份额交易和基金反而二申购或赎回的开放式基金。是我国对证券投资基金的一种本土化创新。</li></ul><h5 id="国内的一些指数"><a href="#国内的一些指数" class="headerlink" title="国内的一些指数"></a>国内的一些指数</h5><ul><li>上证50指数：就是把上交所规模最大、流动性最好的50家公司的股票组合在一起。</li><li>沪深300指数：就是把上交所和深交所前300只规模最大、流动最好的300家公司的股票组合在一起。</li><li>中证500指数：把沪深300指数的前300家大公司排除，剩下的大公司中再选前500只规模最大、流动最好的500家公司的股票统计起来的股票组合在一起。</li><li>上证红利指数：从上交所的股票中，挑选现金分红最高的 50 家公司股票组合在一起。 时间越长，分红越高。</li><li>创业板指数：限制了成分股的数量，只从创业板上市公司中，挑选出规模最大、流动性最好的100只股票。</li></ul><p>接下来直接进入主题，这里就不介绍平台和开户相关前提了</p><h2 id="一、怎么买？"><a href="#一、怎么买？" class="headerlink" title="一、怎么买？"></a>一、怎么买？</h2><p>基金投资的第一步就是选到优秀并且适合自己的基金，上面介绍了基金的分类了，那接下来直接说说如何选基金。</p><p>长期投资建议：<strong>混合型基金和股票型基金，其次债券型基金</strong></p><p>接下来，解释一下原因：</p><h4 id="（1）货币型基金"><a href="#（1）货币型基金" class="headerlink" title="（1）货币型基金"></a>（1）货币型基金</h4><p><strong>首先排除掉余额宝等货币型基金，因为收益率过低，甚至跑不赢通货膨胀，不予考虑。</strong></p><h4 id="（2）债券型基金"><a href="#（2）债券型基金" class="headerlink" title="（2）债券型基金"></a>（2）债券型基金</h4><p>债券型基金在一年期内，取得正收益率的概率大于股票型基金，但是<strong>其长期和平均收益率要远低于股票型基金</strong>。</p><p>如果选择长期投资<strong>自然是股票型基金更适合。</strong></p><h4 id="（3）主动型与被动型基金"><a href="#（3）主动型与被动型基金" class="headerlink" title="（3）主动型与被动型基金"></a>（3）主动型与被动型基金</h4><p>取舍了股票型和债券型，我们接下来看看<strong>股票型基金、混合型基金（二者统称为主动型基金）与指数基金（被动型基金）的对比。</strong></p><blockquote><p>巴菲特说过：“一个什么都不懂的投资者，通过定投指数型基金，就可以战胜大多数的专业投资者。”</p></blockquote><p>这句话确实是金玉良言，但是那是在美国的市场上。</p><p><strong>美国市场处于机构博弈的状态</strong>，就是基金和基金打架，能从中脱颖而出，战胜大盘平均成绩的基金自然是不多；</p><p>但是<strong>在中国市场上，是机构和散户博弈</strong>，目前市场上<strong>近7成的交易量由散户提供</strong>，那些基金工作机构相对于散户来说，处于信息和技术层面的绝对优势，</p><p>我们再看看数据统计：</p><p><img src="https://pic2.zhimg.com/50/v2-34f455f4e76229506ce0f1c25d115726_hd.jpg?source=1940ef5c"></p><p><img src="https://pic2.zhimg.com/80/v2-34f455f4e76229506ce0f1c25d115726_1440w.jpg?source=1940ef5c"></p><p>被许多人吹捧的指数型基金的年化收益率甚至低于债券基金，并且风险（波动率）还要更大。</p><p><strong>如果在中国你选择了指数基金，那就是实实在在的损失掉了一部分收益。</strong></p><p>好了，现在我们知道自己要买的是股票型基金和混合型基金了，那么接下来我们该怎么细选呢？</p><p><strong>毕竟这两种基金可有将近4000多只，我们怎么样才能选到那些能给我们带来长期稳定收益的基金呢？</strong></p><p><strong>既然说了是最直白的教程，那在这里就应该直接给大家一份名单，直截了当的告诉你，哪些基金是“陈年好基”</strong></p><p>我在这篇回答里，为你<strong>直接列举了中国最优秀的基金经理和他们的代表基金（全部都是经过5年以上牛熊市考验的老牌基金，长期平均年化收益率15%以上）</strong>，并且附有自主选择基金的方法：</p><p>链接：<a href="https://www.zhihu.com/question/373427508/answer/1467901892">国内优秀基金经理及其代表基金推荐</a></p><h4 id="（4）购买方式"><a href="#（4）购买方式" class="headerlink" title="（4）购买方式"></a>（4）购买方式</h4><p>好了，选择好基金后，我们就要开始购买了，那哪种购买方式最适合我们呢？</p><p>在讲这个问题前，我们要简单的说一下定投的原理：</p><p><strong>为了你更好地理解，请你陪我算一道很简单的计算题。</strong></p><blockquote><p>假如我们去菜市场买西红柿，每次买3000元，买三次。第一次买的价格是1.5元1斤，第二次是1元1斤，第三次是0.5元一斤  </p><p>问：买完3次后，你手中的西红柿成本是几元1斤？  </p><p>你可能就要说1元对吧，<strong>那让我们来仔细算算这笔账，一共买了3次，花了9000元，第一次买了2000斤，第二次买了3000斤，第三次买了6000斤</strong>  </p><p>细心的朋友到这里就发现了，<strong>实际上我们花了9000元，却买了11000斤西红柿。</strong>  </p><p><strong>当西红柿回到1元1斤时，总的来说虽然西红柿的价格没有上涨，但我们还是可以净赚2000元，</strong></p></blockquote><p><strong>这就是定投的魔力。</strong></p><p><img src="https://pic3.zhimg.com/50/v2-6dd9958c364f3ad01123764b4c126d25_hd.jpg?source=1940ef5c"></p><p><img src="https://pic3.zhimg.com/80/v2-6dd9958c364f3ad01123764b4c126d25_1440w.jpg?source=1940ef5c"></p><p>定投好处就在于<strong>①可以在低位时吸收更多筹码②克服人追涨杀跌的天性，规定买入时间。</strong></p><p>注意事项：</p><p>1、基金的选择和蔬菜一样也讲究荤素搭配、营养全面，我们不能只吃一样，<strong>建议你持有4-8只，就可以避免因为一个基金出现问题，而影响我们整体的收益率。</strong></p><p>2、<strong>不要买支付宝等软件主页面上推荐的基金</strong>，被推荐的基金都是在近期涨幅很大，看起来很诱人的基金，但是近期涨幅过大并不是好事，说明两个问题：</p><ul><li><p>①基金经理风格偏激进  </p></li><li><p>②该基金最近处于高位，后期很大可能跌落。所以一般购买这类基金，有很大的概率是当了接盘侠。</p></li></ul><h2 id="二、买多少"><a href="#二、买多少" class="headerlink" title="二、买多少"></a>二、买多少</h2><p>那么<strong>我们究竟应该买入多少呢？</strong>为了充分考虑到所有人，这里我分情况来说，请大家直接看适合自己的那部分即可。</p><p><strong>1、学生</strong></p><p>从现在开始，给自己定一个长期目标，明确标出每个月需要攒下来的钱。然后每月通过兼职或者从生活费中节省下来该金额。</p><p><strong>很多人会说学生不可以理财，钱少不可以理财，现在理财看似只能赚个几十，并且还有一定风险。</strong></p><p><strong>但其实不然，如果你能从现在开始积累理财经验，那这对你的后半生会是一个取之不尽的财富。</strong></p><p><strong>毕竟劳动无法致富，普通人财务自由的最佳方式，就是早点开始理财。</strong></p><p><strong>2、上班族</strong></p><p>将自己收入的10%攒下来，定投到你的基金组合当中，</p><p>如果你想拥有被动收入，并在未来的某一天脱离这种早出晚归的上班生活的话，建议你从现在开始播种理财。</p><p>同样的给自己列一个计划表，有了计划，我们才能一步一步的去实践。</p><p><strong>3、有一定/目标压力的人群</strong></p><p><strong>明确该目标的预算</strong>，然后根据这个数额，来决定每月定投金额以及定投时间。</p><p><strong>定投频率：两周一次最佳</strong>，每日一投会因为买入时间间隔过短，所以起不到摊低成本的作用，经数据测算，两周一投是收益率最高的方式。</p><p>注意事项：</p><p>1、短期内要用到的钱不能用于投资。</p><p>2、定投贵在坚持，每一次定投都是你在向财务自由迈步。</p><h2 id="三、怎么卖"><a href="#三、怎么卖" class="headerlink" title="三、怎么卖"></a>三、怎么卖</h2><blockquote><p><strong>俗话说：“会买的是徒弟，会卖的才是师傅。”</strong></p></blockquote><p>如何把握卖出时机的确是基金投资中，最难掌握的一步，但是不用害怕，这个时候我们已经有了收益，需要做的就是落袋为安，把那个数字转换成实实在在的钱罢了。</p><p><strong>下面有几种方法请大家查收，从简单到困难。</strong></p><h3 id="（1）目标收益率法"><a href="#（1）目标收益率法" class="headerlink" title="（1）目标收益率法"></a><strong>（1）目标收益率法</strong></h3><p>在我们入市之前，给自己定下一个目标收益率（15%或者20%），</p><p>当定投的持有收益率达到目标收益率时，卖出20%-30%，然后继续投资。<strong>简单粗暴，适合小白操作。</strong></p><h3 id="（2）估值表法则"><a href="#（2）估值表法则" class="headerlink" title="（2）估值表法则"></a><strong>（2）估值表法则</strong></h3><p>支付宝上对于基金估值的判断会有一个红绿灯来表示：</p><p><img src="https://pic2.zhimg.com/50/v2-b0733a6fbf4ef36ac2ba7a18c4aced75_hd.jpg?source=1940ef5c"></p><p>（图中基金不作投资参考）</p><p><strong>除了指数红绿灯，在支付宝上还可以找到专业机构看法参考：</strong></p><p><img src="https://pic1.zhimg.com/50/v2-9c8f5432a620a2247d8b7d6078e05f23_hd.jpg?source=1940ef5c"></p><p><img src="https://pic1.zhimg.com/80/v2-9c8f5432a620a2247d8b7d6078e05f23_1440w.jpg?source=1940ef5c"></p><p>（图中基金不做投资参考）</p><p>参考基金估值和机构的看法，来决定是否止盈</p><p>但是<strong>止盈并不是全部卖出</strong>，假设后面有一个大牛市，那么全部卖出就吃不到后面的收益，建议每次止盈**酌情卖出20%、30%**等</p><h3 id="（3）市场形势止盈法"><a href="#（3）市场形势止盈法" class="headerlink" title="（3）市场形势止盈法"></a><strong>（3）市场形势止盈法</strong></h3><p><strong>这个是老基民的方法了，要求个人理财者把握好大的方向：</strong></p><p><strong>知道目前市场是牛是熊、市场上的基金是便宜还是贵。如果实在不知道的呢，我建议上证指数2900点以下多买，3300点附近部分卖出。</strong></p><p>更进一阶的可以不只分析大盘，也可以分析自己所投资的行业，分别从政策、技术、资金等方面判断市场所处位置，上涨的可能性大还是跌的可能性大。</p><p><strong>如果现在不会这种方法，不用担心，在市场上度过一年之后，你就会有自己的看法。</strong></p><blockquote><p>本文整理自知乎-<strong>吴机长</strong>的回答</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网上关于基金投资教学的文章有很多，但都太过于专业，太过于繁琐，今天就用简单直白的内容重新认识基金。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接告诉你 怎么买、买多少、怎么卖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开始前先了解下基金的分类&lt;/p&gt;
&lt;h2 id=&quot;基金的分类&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="懂理财" scheme="https://blog.jddfe.com/categories/%E6%87%82%E7%90%86%E8%B4%A2/"/>
    
    
    <category term="基金" scheme="https://blog.jddfe.com/tags/%E5%9F%BA%E9%87%91/"/>
    
    <category term="定投" scheme="https://blog.jddfe.com/tags/%E5%AE%9A%E6%8A%95/"/>
    
    <category term="投资" scheme="https://blog.jddfe.com/tags/%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>防抖、节流及应用场景</title>
    <link href="https://blog.jddfe.com/posts/49523/"/>
    <id>https://blog.jddfe.com/posts/49523/</id>
    <published>2020-11-11T14:27:28.000Z</published>
    <updated>2020-11-17T12:54:33.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><blockquote><p>事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p></blockquote><p>防抖，顾名思义，防止抖动，什么叫抖动，事件被高频触发，想象你在用鼠标点击按钮操纵一个小人让他有跳跃的动作，你狂点鼠标，小人狂跳，这就是最直观的抖动现象。</p><p>直接上代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* fn [function] 需要防抖的函数</span></span><br><span class="line"><span class="comment">* delay [number] 毫秒，防抖期限值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span> <span class="comment">// 借助闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时</span></span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          fn.call(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h2><blockquote><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p></blockquote><p>简单的可以理解为指定时间间隔只执行一次任务。</p><p>直接看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> valid = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="title">if</span>(<span class="params">valid</span>)</span>&#123;</span><br><span class="line">        valid = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 工作时间，执行函数并且在间隔期内把状态位设为无效</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          fn.call(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">          valid = <span class="literal">true</span>;</span><br><span class="line">      &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：节流函数并不止上面这种实现方案,例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么你可能会困惑，防抖也有时间间隔，节流还是时间间隔，它俩啥区别？</p><p>上结论：</p><p>防抖：超过指定时间间隔，不论点击多少次都只执行一次。</p><p>节流：指定时间间隔只执行一次，执行频率不受操作频率影响，但会把所有的都执行完。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>防抖：</p><p>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。<br>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</p><p>节流：</p><p>鼠标不断点击触发，mousedown(单位时间内只触发一次)<br>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;防抖-debounce&quot;&gt;&lt;a href=&quot;#防抖-debounce&quot; class=&quot;headerlink&quot; title=&quot;防抖(debounce)&quot;&gt;&lt;/a&gt;防抖(debounce)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;事件被触发n秒后再执行回调，如果在这n</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="防抖" scheme="https://blog.jddfe.com/tags/%E9%98%B2%E6%8A%96/"/>
    
    <category term="节流" scheme="https://blog.jddfe.com/tags/%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 双线部署到 Coding 和 GitHub 并实现全站 HTTPS</title>
    <link href="https://blog.jddfe.com/posts/39593/"/>
    <id>https://blog.jddfe.com/posts/39593/</id>
    <published>2020-11-09T14:56:25.000Z</published>
    <updated>2020-11-17T13:07:00.693Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub pages是GitHub提供的一项静态站点托管网页，这里就不过多介绍，由于国内网络原因，访问延迟100-300ms，当然这还是在网络较好的时候，在网络差的情况下会很难加载完全网页，令人头疼，于是，针对这个问题做个大致的解决方案，记录分享下。</p><p>本文主要从双线部署和实现https自定义域名两个点做分享，并记录一下其中遇到的坑。</p><p>所谓双线部署就是将博客同时发布到 Coding 和 Github，博客发布到 Coding 来提升国内访问速度，并可以提交百度收录，GitHub 禁止了百度的爬取，当然可以通过其他方案来解决收录问题，这里就不过多介绍了，感兴趣的可以网上找一下。</p><h2 id="实现双线部署"><a href="#实现双线部署" class="headerlink" title="实现双线部署"></a>实现双线部署</h2><p>首先，你要将 Hexo 成功部署到了 GitHub Pages，如果还没有，可以参考之前的博文专门的教程<a href="/posts/42939/" title="Hexo5分钟搞定你的个人博客">Hexo5分钟搞定你的个人博客</a></p><p>在成功部署到了 GitHub 后，那么就简单了，关键点就在于发布配置多配置个 Coding 代码库。</p><p>上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: </span><br><span class="line">    coding: https:&#x2F;&#x2F;e.coding.net&#x2F;团队名&#x2F;项目名&#x2F;代码库.git</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;昵称&#x2F;代码库.git</span><br></pre></td></tr></table></figure><h4 id="创建-Coding-项目"><a href="#创建-Coding-项目" class="headerlink" title="创建 Coding 项目"></a>创建 Coding 项目</h4><p>进入 <a href="https://coding.net/">Coding</a> 官网，点击登录（如果首次使用，需要创建团队-创建用户-完成注册，安装步骤完成）</p><p><img src="2020-11-11T002543.png" alt="2020-11-11T002543"></p><h5 id="进入后创建项目，选择-DevOps-项目-（比较关键，决定后面能否静态部署）"><a href="#进入后创建项目，选择-DevOps-项目-（比较关键，决定后面能否静态部署）" class="headerlink" title="进入后创建项目，选择 DevOps 项目 （比较关键，决定后面能否静态部署）"></a>进入后创建项目，选择 <code>DevOps 项目</code> （比较关键，决定后面能否静态部署）</h5><h5 id="创建完项目后，新建仓库"><a href="#创建完项目后，新建仓库" class="headerlink" title="创建完项目后，新建仓库"></a>创建完项目后，新建仓库</h5><h5 id="重点这里，新建静态网站"><a href="#重点这里，新建静态网站" class="headerlink" title="重点这里，新建静态网站"></a>重点这里，新建静态网站</h5><p><img src="2020-11-11T003205.png" alt="2020-11-11T003205"></p><p>这里有三种方式：</p><ul><li>代码来源-现有仓库，网站类型-静态网站</li><li>代码来源-现有仓库，网站类型-Hexo/Jekyll</li><li>代码来源-示例仓库，网站类型-Hexo/Jekyll</li></ul><p>区别在于是在本地构建编译，还是云构建编译。最终都是把编译后的代码部署到服务。</p><p>好，到此，上面双部署就算完成。</p><h2 id="自定义域名并HTTPS"><a href="#自定义域名并HTTPS" class="headerlink" title="自定义域名并HTTPS"></a>自定义域名并HTTPS</h2><h4 id="Github-自定义域名"><a href="#Github-自定义域名" class="headerlink" title="Github 自定义域名"></a>Github 自定义域名</h4><p>在 Settings -&gt; GitHub Pages 直接配置 Custom domain。这里要注意一定要在 hexo项目source下新建一个 CNAME 文件，内容为你自定义的域名，解决每次发布的时候 Custom domain 会被重置的问题。</p><h4 id="Coding-自定义域名"><a href="#Coding-自定义域名" class="headerlink" title="Coding 自定义域名"></a>Coding 自定义域名</h4><p>静态网站 -&gt; 自定义域名。</p><p><img src="2020-11-11T004326.png" alt="2020-11-11T004326"></p><p>配置同时需要生产SSL证书，并且需要做域名解析的配置。</p><p>至此，我们的 Hexo 博客就成功双线部署到 Coding Pages 和 GitHub Pages 了，并且也实现了全站 HPPTS。完成配置后你会明显发现速度的变化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GitHub pages是GitHub提供的一项静态站点托管网页，这里就不过多介绍，由于国内网络原因，访问延迟100-300ms，当然这还是在网络较好的时候，在网络差的情况下会很难加载完全网页，令人头疼，于是，针对这个问题做个大致的解决方案，记录分享下。&lt;/p&gt;
&lt;p&gt;本文</summary>
      
    
    
    
    <category term="折腾不止" scheme="https://blog.jddfe.com/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
    <category term="Hexo" scheme="https://blog.jddfe.com/tags/Hexo/"/>
    
    <category term="Github Page" scheme="https://blog.jddfe.com/tags/Github-Page/"/>
    
  </entry>
  
  <entry>
    <title>闭包为什么会占用内存</title>
    <link href="https://blog.jddfe.com/posts/28448/"/>
    <id>https://blog.jddfe.com/posts/28448/</id>
    <published>2016-09-03T14:16:54.000Z</published>
    <updated>2020-11-17T12:54:33.349Z</updated>
    
    <content type="html"><![CDATA[<p>在试图弄清这个问题之前，先要理解<a href="/posts/49976/" title="栈内存堆内存和预处理">栈内存堆内存和预处理</a></p><h2 id="占用内存，不会销毁的闭包实例"><a href="#占用内存，不会销毁的闭包实例" class="headerlink" title="占用内存，不会销毁的闭包实例"></a>占用内存，不会销毁的闭包实例</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>例1的图示</p><p><img src="T162925.png" alt="T162925"></p><p><strong>未被占用的堆内存才会被销毁</strong></p><p>所以，正如图中椭圆形关键点中说明的那样，堆内存xxxfff111被返回给了全局变量f，而全局变量只有在窗口关闭的时候才会销毁，<strong>因此堆内存xxxfff111将一直被占用而不会销毁</strong>，定义它的局部作用域A也不会被销毁。</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    oDiv.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>这段代码的特点是：私有作用域给dom元素的事件绑定一个方法。</p><p>例2的图示：</p><p><img src="T163019.png" alt="T163019"></p><p>正如图中椭圆形关键点所说，标签对象的属性里面会自带一个onclick的属性，未被赋值时其值为null。那么，在自执行函数执行的时候，其创建的作用域所占用的堆内存xxxfff111同样也会被全局的堆内存xxxfff000占用（这里要注意，是堆内存占用堆内存），所以堆内存xxxfff111和栈内存A都不会被销毁。</p><h2 id="不占用内存，立即销毁的实例"><a href="#不占用内存，立即销毁的实例" class="headerlink" title="不占用内存，立即销毁的实例"></a>不占用内存，立即销毁的实例</h2><p>只需要将例1稍作修改。</p><h3 id="例3："><a href="#例3：" class="headerlink" title="例3："></a>例3：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    var num &#x3D; 100;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn();&#x2F;&#x2F;主要修改在这里</span><br></pre></td></tr></table></figure><p>例3的图示</p><p><img src="T163106.png" alt="T163106"></p><p>由于在函数fn中，xxxfff111是被return的，所以栈内存A的预解释不会处理xxxfff111，它只在fn函数执行的时候才会生成，而函数fn的栈内存A每次被执行之后都会被销毁。</p><h2 id="暂时占用内存，延时销毁的闭包实例"><a href="#暂时占用内存，延时销毁的闭包实例" class="headerlink" title="暂时占用内存，延时销毁的闭包实例"></a>暂时占用内存，延时销毁的闭包实例</h2><p>将例3稍作修改，就变成了延时销毁的闭包实例。</p><h3 id="例4："><a href="#例4：" class="headerlink" title="例4："></a>例4：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()();<span class="comment">//这里到底发生了什么？其实是执行了一次fn之后，把返回的子函数有执行了一次，所以在子函数执行的时候，栈内存fn()是不能销毁的，但是子函数执行完毕后因为没有被占用，所以最终还是要被销毁的，所以最终fn()还是会被销毁的。</span></span><br></pre></td></tr></table></figure><p>例4的图示：</p><p><img src="T163156.png" alt="T163156"></p><p>正如途中椭圆形关键点处所说，<code>fn()()</code>的意思是在执行完<code>fn()</code>之后再把返回的值函数执行一遍。因此在子函数执行的时候，堆内存xxxfff111被占用了，相应的栈内存A也将保留。</p><p>可堆内存xxxfff111中保存的子函数在执行完成之后还是会被销毁，接着堆内存xxxfff111就作为未被占用的堆内存而被销毁，最终栈内存A也会被销毁。</p><p>所以，栈内存在执行完之后会被保留一段时间，这段时间等于其子函数执行的时间。</p><p>参考资料：</p><p>javascript高级程序设计(第三版)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在试图弄清这个问题之前，先要理解&lt;a href=&quot;/posts/49976/&quot; title=&quot;栈内存堆内存和预处理&quot;&gt;栈内存堆内存和预处理&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;占用内存，不会销毁的闭包实例&quot;&gt;&lt;a href=&quot;#占用内存，不会销毁的闭包实例&quot; class=&quot;he</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="学习笔记" scheme="https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Javascript" scheme="https://blog.jddfe.com/tags/Javascript/"/>
    
    <category term="闭包" scheme="https://blog.jddfe.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>栈内存堆内存和预处理</title>
    <link href="https://blog.jddfe.com/posts/49976/"/>
    <id>https://blog.jddfe.com/posts/49976/</id>
    <published>2016-09-02T14:10:54.000Z</published>
    <updated>2020-11-17T12:54:33.344Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器是如何运行javascript代码的？<a href="https://segmentfault.com/a/1190000020438413">JavaScript 是如何运行的？</a></p><p>看例1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">num = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>用图解释这一行代码是如何执行的。</p><p><img src="T161637.png" alt="T161637"></p><p>这是一个简单的图示，现在我们来增加几个概念：栈内存、堆内存和预处理。</p><h2 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h2><p>栈内存用来存放基本数据类型(Number、String、Boolean、Null和Undefined)，<strong>在执行完之后销毁。</strong></p><p>栈内存与另一个概念息息相关——作用域，即代码的执行环境。上图中左边的栈内存就是全局作用域，而右边的则是局部作用域。全局作用域在浏览器窗口关闭之后才销毁。局部作用域在执行完之后就会销毁。</p><p>javascript规定，父作用域不能使用子作用域中变量和方程，而反过来是可以的。这个反过来的方向链条则被称为作用域链。</p><p>这里需要注意的是，<strong>判断子作用域的父作用域是哪一个，要看这个子作用域是在哪里定义的，而不是在哪里执行。</strong></p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>堆内存用来存放引用数据类型(object、array、function、date)，<strong>在没有被引用之后销毁。</strong></p><p>当我们声明和定义了一个引用数据类型之后，这个对象保存在堆内存中，而这个对象的地址则保存在栈内存中以用于引用。</p><p>在全局作用域声明和定义的引用数据类型，销毁的方法是手动赋值null。</p><h2 id="看一组例子来说明栈内存与堆内存的区别："><a href="#看一组例子来说明栈内存与堆内存的区别：" class="headerlink" title="看一组例子来说明栈内存与堆内存的区别："></a>看一组例子来说明栈内存与堆内存的区别：</h2><p>例2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 20;</span><br><span class="line">var b &#x3D; a;</span><br><span class="line">b &#x3D; 30;</span><br><span class="line">&#x2F;&#x2F; a等于多少？</span><br></pre></td></tr></table></figure><p>例3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m &#x3D; &#123; a: 10, b: 20 &#125;</span><br><span class="line">var n &#x3D; m;</span><br><span class="line">n.a &#x3D; 15;</span><br><span class="line">&#x2F;&#x2F; m.a的值是分别是什么？</span><br></pre></td></tr></table></figure><p>例2的图解</p><p><img src="T161737.png" alt="T161737"></p><p>例3的图解</p><p><img src="T161816.png" alt="T161816"></p><p>由上两个图解可见，当基本数据类型传递的时候，其实是复制了一个新的数据给另一个变量；而当引用类型传递的时候，复制的仅仅是引用数据类型的地址，两个变量通过地址指向的是同一个堆内存中的数据。</p><p>所以在例3中，当我们改变n.a的时候，m.a也同样改变了。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>预处理是浏览器在执行代码前要做的任务，它包括变量的声明和函数声明与定义。</p><p>预处理是<strong>变量提升</strong>的原因。</p><p>当我们写了<code>var num = 12</code>这样的一行代码的时候，在执行时其实是分为两步：声明<code>var num</code>和定义<code>num = 12</code>。对于变量，预处理只做声明而不做定义。</p><p>而相对于函数<code>function fn()&#123;var num 12&#125;</code>，同样有声明和定义之分，与变量不同的是，预处理时声明和定义全部执行。具体步骤是：声明<code>function fn()</code>，定义<code>fn() = &quot;&#123;var num = 12&#125;&quot;</code>。</p><p>理解了栈内存、堆内存和预处理之后，重新画出例1的图示：</p><p><img src="T161853.png" alt="T161853"></p><p>这里的堆内存xxxfff000被全局作用域的函数fn引用，而全局作用域只有在浏览器窗口关闭的时候才会销毁，所以，只要浏览器窗口没有关闭，则堆内存xxxfff000一直被引用而不会销毁。</p><p>参考资料：</p><p>javascript高级程序设计(第三版)；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;浏览器是如何运行javascript代码的？&lt;a href=&quot;https://segmentfault.com/a/1190000020438413&quot;&gt;JavaScript 是如何运行的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看例1：&lt;/p&gt;
&lt;figure class=&quot;highlig</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="学习笔记" scheme="https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Javascript" scheme="https://blog.jddfe.com/tags/Javascript/"/>
    
    <category term="栈和堆" scheme="https://blog.jddfe.com/tags/%E6%A0%88%E5%92%8C%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>JS 中的事件绑定、事件监听、事件委托</title>
    <link href="https://blog.jddfe.com/posts/31762/"/>
    <id>https://blog.jddfe.com/posts/31762/</id>
    <published>2016-08-18T12:50:14.000Z</published>
    <updated>2020-11-17T12:54:33.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ul><li>要想让 <code>javascript </code>对用户的操作作出响应，首先要对 <code>dom</code> 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称</li></ul><a id="more"></a><ul><li><p>在<code>javascript</code>中，有三种常用的绑定事件的方法</p><ul><li>在<code>dom</code>元素中直接绑定；</li><li>在<code>javascript</code>代码中绑定；</li><li>绑定事件监听函数</li></ul></li></ul><h4 id="在dom中直接绑定事件"><a href="#在dom中直接绑定事件" class="headerlink" title="在dom中直接绑定事件"></a>在<code>dom</code>中直接绑定事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;click me&quot;</span> onclick=<span class="string">&quot;hello()&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="在javascript代码中绑定事件"><a href="#在javascript代码中绑定事件" class="headerlink" title="在javascript代码中绑定事件"></a>在<code>javascript</code>代码中绑定事件</h4><ul><li>在<code>javascript</code>代码中（即script标签内）绑定事件可以使<code>javascript</code>代码与<code>HTML</code>标签分离，文档结构清晰，便于管理和开发</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;click me&quot;</span> id=<span class="string">&quot;btn&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="使用事件监听绑定事件"><a href="#使用事件监听绑定事件" class="headerlink" title="使用事件监听绑定事件"></a>使用事件监听绑定事件</h4><ul><li>关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段</li><li>起初<code>Netscape</code>制定了<code>javascript</code>的一套事件驱动机制（即事件捕获）。随即<code>IE</code>也推出了自己的一套事件驱动机制（即事件冒泡）。最后<code>W3C</code>规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），<code>IE9</code>以后<code>IE</code>也支持了W3C规范</li></ul><p><strong>W3C规范</strong></p><ul><li>语法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(event, <span class="function"><span class="keyword">function</span>, <span class="title">useCapture</span>)</span></span><br></pre></td></tr></table></figure><ul><li><p><code>event</code> : （必需）事件名，支持所有<code>dom</code>事件。</p></li><li><p><code>function</code>：（必需）指定要事件触发时执行的函数。</p></li><li><p><code>useCapture</code>：（可选）指定事件是否在捕获或冒泡阶段执行。<code>true</code>，捕获。<code>false</code>，冒泡。默认<code>false</code></p></li><li><p>注：<code> IE8</code> 以下不支持</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;click me&quot;</span> id=<span class="string">&quot;btn1&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;btn1&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>,hello);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>IE标准</strong></p><ul><li>语法：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.attachEvent(event, <span class="function"><span class="keyword">function</span>)</span></span><br></pre></td></tr></table></figure><ul><li><code>event</code>：（必需）事件类型。需加“on“，例如：<code>onclick</code>。</li><li><code>function</code>：（必需）指定要事件触发时执行的函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;click me&quot;</span> id=<span class="string">&quot;btn2&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;btn2&quot;</span>).attachEvent(<span class="string">&quot;onclick&quot;</span>,hello);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="事件监听的优点"><a href="#事件监听的优点" class="headerlink" title="事件监听的优点"></a>事件监听的优点</h4><ul><li>可以绑定多个事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;click me&quot;</span> id=<span class="string">&quot;btn3&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> btn3 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn3&quot;</span>);</span><br><span class="line">btn3.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello 1&quot;</span>); <span class="comment">//不执行</span></span><br><span class="line">&#125;</span><br><span class="line">btn3.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello 2&quot;</span>); <span class="comment">//执行</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>常规的事件绑定只执行最后绑定的事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;click me&quot;</span> id=<span class="string">&quot;btn4&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> btn4 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn4&quot;</span>);</span><br><span class="line">btn4.addEventListener(<span class="string">&quot;click&quot;</span>,hello1);</span><br><span class="line">btn4.addEventListener(<span class="string">&quot;click&quot;</span>,hello2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello 1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello 2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>两个事件都执行了</p><ul><li>可以解除相应的绑定</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;click me&quot;</span> id=<span class="string">&quot;btn5&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> btn5 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn5&quot;</span>);</span><br><span class="line">btn5.addEventListener(<span class="string">&quot;click&quot;</span>,hello1);<span class="comment">//执行了</span></span><br><span class="line">btn5.addEventListener(<span class="string">&quot;click&quot;</span>,hello2);<span class="comment">//不执行</span></span><br><span class="line">btn5.removeEventListener(<span class="string">&quot;click&quot;</span>,hello2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello 1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello 2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>封装事件监听</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;click me&quot;</span> id=<span class="string">&quot;btn5&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定监听事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEventHandler</span>(<span class="params">target,type,fn</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">target.addEventListener</span>)</span>&#123;</span><br><span class="line">    target.addEventListener(type,fn);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    target.attachEvent(<span class="string">&quot;on&quot;</span>+type,fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除监听事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEventHandler</span>(<span class="params">target,type,fn</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">target.removeEventListener</span>)</span>&#123;</span><br><span class="line">    target.removeEventListener(type,fn);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    target.detachEvent(<span class="string">&quot;on&quot;</span>+type,fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">var</span> btn5 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn5&quot;</span>);</span><br><span class="line">addEventHandler(btn5,<span class="string">&quot;click&quot;</span>,hello1);<span class="comment">//添加事件hello1</span></span><br><span class="line">addEventHandler(btn5,<span class="string">&quot;click&quot;</span>,hello2);<span class="comment">//添加事件hello2</span></span><br><span class="line">removeEventHandler(btn5,<span class="string">&quot;click&quot;</span>,hello1);<span class="comment">//移除事件hello1</span></span><br></pre></td></tr></table></figure><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><ul><li>事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;click me&quot;</span> id=<span class="string">&quot;btn6&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn6 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn6&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event = event || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">var</span> target = event.target || event.srcElement;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">target == btn6</span>)</span>&#123;</span><br><span class="line">    alert(btn5.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="事件委托优点"><a href="#事件委托优点" class="headerlink" title="事件委托优点"></a>事件委托优点</h5><ul><li>提高javascript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用</li><li>传统写法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item1&quot;</span> &gt;item1&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item2&quot;</span> &gt;item2&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item3&quot;</span> &gt;item3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> item1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;item1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> item2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;item2&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> item3 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;item3&quot;</span>);</span><br><span class="line"></span><br><span class="line">item1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello item1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">item2.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello item2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">item3.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello item3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>事件委托</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item1&quot;</span> &gt;item1&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item2&quot;</span> &gt;item2&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item3&quot;</span> &gt;item3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> item1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;item1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> item2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;item2&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> item3 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;item3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = event.target;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">target == item1</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello item1&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">target == item2</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello item2&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">target == item3</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello item3&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>动态的添加dom元素，不需要因为元素的改动而修改事件绑定</li><li>传统写法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item1&quot;</span> &gt;item1&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item2&quot;</span> &gt;item2&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item3&quot;</span> &gt;item3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = list.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>;i&lt;item.length;i++</span>)</span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    item[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(item[i].innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> node=<span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> textnode=<span class="built_in">document</span>.createTextnode(<span class="string">&quot;item4&quot;</span>);</span><br><span class="line">node.appendChild(textnode);</span><br><span class="line">list.appendChild(node);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。</li><li>事件委托</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item1&quot;</span> &gt;item1&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item2&quot;</span> &gt;item2&lt;/li&gt;</span><br><span class="line">  &lt;li id=<span class="string">&quot;item3&quot;</span> &gt;item3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = event.target;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">target.nodeName == <span class="string">&quot;LI&quot;</span></span>)</span>&#123;</span><br><span class="line">    alert(target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> node=<span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> textnode=<span class="built_in">document</span>.createTextnode(<span class="string">&quot;item4&quot;</span>);</span><br><span class="line">node.appendChild(textnode);</span><br><span class="line">list.appendChild(node);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>当点击item4时，item4有事件响应。说明事件委托可以为新添加的dom元素动态的添加事件</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;事件绑定&quot;&gt;&lt;a href=&quot;#事件绑定&quot; class=&quot;headerlink&quot; title=&quot;事件绑定&quot;&gt;&lt;/a&gt;事件绑定&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;要想让 &lt;code&gt;javascript &lt;/code&gt;对用户的操作作出响应，首先要对 &lt;code&gt;dom&lt;/code&gt; 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://blog.jddfe.com/tags/javascript/"/>
    
    <category term="学习笔记" scheme="https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="事件" scheme="https://blog.jddfe.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
    <category term="event" scheme="https://blog.jddfe.com/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>OOP之原型与原型链</title>
    <link href="https://blog.jddfe.com/posts/65309/"/>
    <id>https://blog.jddfe.com/posts/65309/</id>
    <published>2016-08-17T12:40:20.000Z</published>
    <updated>2020-11-17T12:54:33.338Z</updated>
    
    <content type="html"><![CDATA[<h4 id="prototype原型对象"><a href="#prototype原型对象" class="headerlink" title="prototype原型对象"></a>prototype原型对象</h4><hr><ul><li>每个函数都有一个默认的<code>prototype</code>属性，其实际上还是一个对象，如果被用在继承中，姑且叫做原型对象</li><li>在构造函数中的<code>prototype</code>中定义的属性和方法，会被创建的对象所继承下来。举个栗子：<a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">F.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;F is working..&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.work(); <span class="comment">// F is working..</span></span><br></pre></td></tr></table></figure></li><li>当你创建函数时，<code>JS</code>会为这个函数自动添加 <code>prototype</code> 属性，值是空对象。而一旦你把这个函数当作构造函数（ <code>constructor</code> ）调用（即通过 <code>new </code>关键字调用），那么<code>JS</code>就会帮你创建该构造函数的实例，实例继承构造函数 <code>prototype</code> 的所有属性和方法（实例通过设置自己的<code> __proto__</code> 指向构造函数的 <code>prototype</code> 来实现这种继承）</li></ul><h4 id="神秘的proto"><a href="#神秘的proto" class="headerlink" title="神秘的proto"></a>神秘的<strong>proto</strong></h4><hr><ul><li><code>JS</code>的对象中都包含了一个<code>__proto__</code>属性，其指向的是创建该对象时的构造函数的原型对象<code>prototype</code></li></ul><p><img src="T155728.png" alt="T155728"></p><ul><li>从上面的输出结果看出，<code>f.__proto__</code>指向了其构造函数<code>F</code>的<code>prototype</code>，而<code>F.prototype</code>本身也是一个对象，其内部也有<code>__proto__</code>属性，其指向的是<code>Object.prototype</code>,直到最后<code>Object.prototype</code>指向<code>null</code>，这条原型链才结束</li><li>因此，<code>__proto__</code>这个神秘的属性才是原型链形成的真正原因</li></ul><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><hr><ul><li>由于原型对象本身也是对象，根据上边的定义，它也有自己的原型，而它自己的原型对象又可以有自己的原型，这样就组成了一条链，这个就是原型链，<code>JavaScritp</code>引擎在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回<code>undefined</code>。原型链一般实现为一个链表，这样就可以按照一定的顺序来查找</li></ul><p><img src="T155751.png" alt="T155751"></p><ul><li><p>从上图看出：</p><ul><li><code>Object.prototype</code>是顶级对象，所有对象都继承自它。</li><li><code>Function </code>继承 <code>Function </code>本身， <code>Function.prototype</code> 继承 <code>Object.prototype </code></li><li><code>Function.prototype</code> 和 <code>Function.__proto__</code> 都指向 <code>Function.prototype</code></li><li><code>Object.prototype.__proto__ === null</code> ，说明原型链到 <code>Object.prototype</code>终止</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;prototype原型对象&quot;&gt;&lt;a href=&quot;#prototype原型对象&quot; class=&quot;headerlink&quot; title=&quot;prototype原型对象&quot;&gt;&lt;/a&gt;prototype原型对象&lt;/h4&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;每个函数都有一个默认的&lt;code&gt;prototype&lt;/code&gt;属性，其实际上还是一个对象，如果被用在继承中，姑且叫做原型对象&lt;/li&gt;
&lt;li&gt;在构造函数中的&lt;code&gt;prototype&lt;/code&gt;中定义的属性和方法，会被创建的对象所继承下来。举个栗子：</summary>
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://blog.jddfe.com/tags/javascript/"/>
    
    <category term="原型链" scheme="https://blog.jddfe.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
    <category term="学习笔记" scheme="https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>OOP之面向对象</title>
    <link href="https://blog.jddfe.com/posts/14581/"/>
    <id>https://blog.jddfe.com/posts/14581/</id>
    <published>2016-08-16T12:26:24.000Z</published>
    <updated>2020-11-17T12:54:33.341Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一般面向对象包含：继承，封装，多态，抽象</p></blockquote><h4 id="对象形式的继承"><a href="#对象形式的继承" class="headerlink" title="对象形式的继承"></a>对象形式的继承</h4><hr><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><hr><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">        home: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">        office: <span class="string">&#x27;office&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    sclools: [<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> programer = &#123;</span><br><span class="line">    language: <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">p, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"> <span class="keyword">var</span> prop <span class="keyword">in</span> p</span>)</span>&#123;</span><br><span class="line">        c[prop] = p[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">extend(Person, programer);</span><br><span class="line">programer.name;  <span class="comment">// allin</span></span><br><span class="line">programer.address.home;  <span class="comment">// home</span></span><br><span class="line">programer.address.home = <span class="string">&#x27;house&#x27;</span>;  <span class="comment">//house</span></span><br><span class="line">Person.address.home;  <span class="comment">// house</span></span><br></pre></td></tr></table></figure><ul><li>从上面的结果看出，浅拷贝的缺陷在于修改了子对象中引用类型的值，会影响到父对象中的值，因为在浅拷贝中对引用类型的拷贝只是拷贝了地址，指向了内存中同一个副本</li></ul><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendDeeply</span>(<span class="params">p, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> p)&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> p[prop] === <span class="string">&quot;object&quot;</span></span>)</span>&#123;</span><br><span class="line">            c[prop] = (p[prop].constructor === <span class="built_in">Array</span>)?[]:&#123;&#125;;</span><br><span class="line">            extendDeeply(p[prop], c[prop]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            c[prop] = p[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用递归进行深拷贝，这样子对象的修改就不会影响到父对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extendDeeply(Person, programer);</span><br><span class="line">programer.address.home = <span class="string">&#x27;allin&#x27;</span>;</span><br><span class="line">Person.address.home; <span class="comment">// home</span></span><br></pre></td></tr></table></figure><h5 id="利用call和apply继承"><a href="#利用call和apply继承" class="headerlink" title="利用call和apply继承"></a>利用call和apply继承</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.address = &#123;<span class="attr">home</span>: <span class="string">&quot;home&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.language = <span class="string">&quot;js&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ES5中的Object-create"><a href="#ES5中的Object-create" class="headerlink" title="ES5中的Object.create()"></a>ES5中的Object.create()</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">name</span> : <span class="string">&#x27;allin&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(o);</span><br><span class="line">obj.name; <span class="comment">// allin</span></span><br></pre></td></tr></table></figure><ul><li><code>Object.create()</code>作为<code>new</code>操作符的替代方案是<code>ES5</code>之后才出来的。我们也可以自己模拟该方法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟Object.create()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCreate</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    o = <span class="keyword">new</span> F();</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">name</span> : <span class="string">&#x27;allin&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = myCreate(o);</span><br><span class="line">obj.name; <span class="comment">// allin</span></span><br></pre></td></tr></table></figure><ul><li>目前，各大浏览器的最新版本（包括<code>IE9</code>）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">　　　　<span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">　　　　　　 <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">　　　　　　F.prototype = o;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><hr><h5 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.headCount = <span class="number">1</span>;</span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;eating...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Programmer</span>(<span class="params">name, age, title</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Programmer.prototype = <span class="built_in">Object</span>.create(Person.prototype); <span class="comment">//建立继承关系</span></span><br><span class="line">Programmer.prototype.constructor = Programmer;  <span class="comment">// 修改constructor的指向</span></span><br></pre></td></tr></table></figure><h5 id="调用父类方法"><a href="#调用父类方法" class="headerlink" title="调用父类方法"></a>调用父类方法</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.headCount = <span class="number">1</span>;</span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;eating...&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Programmer</span>(<span class="params">name, age, title</span>)</span>&#123;</span><br><span class="line">    Person.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用父类的构造器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Programmer.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Programmer.prototype.constructor = Programmer;</span><br><span class="line"></span><br><span class="line">Programmer.prototype.language = <span class="string">&quot;js&quot;</span>;</span><br><span class="line">Programmer.prototype.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;i am working code in &#x27;</span>+ <span class="built_in">this</span>.language);</span><br><span class="line">    Person.prototype.eat.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用父类上的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><hr><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><hr><ul><li><code>js</code>是没有命名空间的，因此可以用对象模拟</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = &#123;&#125;;  <span class="comment">// 命名空间app</span></span><br><span class="line"><span class="comment">//模块1</span></span><br><span class="line">app.module1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;allin&#x27;</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hi robot&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">app.module1.name; <span class="comment">// &quot;allin&quot;</span></span><br><span class="line">app.module1.f();  <span class="comment">// hi robot</span></span><br></pre></td></tr></table></figure><h5 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员</span></span><br><span class="line">Person.walk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;static&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Person.walk();  <span class="comment">// static</span></span><br></pre></td></tr></table></figure><h5 id="私有与公有"><a href="#私有与公有" class="headerlink" title="私有与公有"></a>私有与公有</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有属性与方法</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;allin&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有属性与方法</span></span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;say hello&#x27;</span>);</span><br><span class="line">        work.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">123</span>);</span><br><span class="line">p1.name; <span class="comment">// undefined</span></span><br><span class="line">p1.id;  <span class="comment">// 123</span></span><br><span class="line">p1.say();  <span class="comment">// say hello 123</span></span><br></pre></td></tr></table></figure><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleA;</span><br><span class="line">moduleA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        func: func,</span><br><span class="line">        prop: prop</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;(); <span class="comment">// 立即执行匿名函数</span></span><br></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><hr><h5 id="模拟方法重载"><a href="#模拟方法重载" class="headerlink" title="模拟方法重载"></a>模拟方法重载</h5><hr><ul><li><code>arguments</code>属性可以取得函数调用的实参个数，可以利用这一点模拟方法的重载</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">a, b </span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(demo.length); <span class="comment">// 得到形参个数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">//得到实参个数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);  <span class="comment">// 第一个实参 4</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);  <span class="comment">// 第二个实参 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现可变长度实参的相加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"> <span class="keyword">var</span> i = <span class="built_in">arguments</span>.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--</span>)</span>&#123;</span><br><span class="line">        total += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数不同的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fontSize</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;js&#x27;</span>);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">arguments</span>.length == <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ele.style.fontSize;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ele.style.fontSize = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fontSize(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fontSize());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型不同的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setting</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;js&#x27;</span>);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>] === <span class="string">&quot;object&quot;</span></span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> p <span class="keyword">in</span> <span class="built_in">arguments</span>[<span class="number">0</span>]</span>)</span>&#123;</span><br><span class="line">            ele.style[p] = <span class="built_in">arguments</span>[<span class="number">0</span>][p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ele.style.fontSize = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">        ele.style.backgroundColor = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setting(<span class="number">18</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">setting(&#123;<span class="attr">fontSize</span>:<span class="number">20</span>, <span class="attr">backgroundColor</span>: <span class="string">&#x27;green&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><h5 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h5><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">F.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">f.run(); <span class="comment">// F</span></span><br><span class="line"></span><br><span class="line">f.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fff&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">f.run();  <span class="comment">// fff</span></span><br></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><hr><ul><li>在构造器中 <code>throw new Error(&#39;&#39;)</code>; 抛异常。这样防止这个类被直接调用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DetectorBase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Abstract class can not be invoked directly!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DetectorBase.prototype.detect = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Detection starting...&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">DetectorBase.prototype.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Detection stopped.&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">DetectorBase.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var d = new DetectorBase();</span></span><br><span class="line"><span class="comment">// Uncaught Error: Abstract class can not be invoked directly!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkDetector</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">LinkDetector.prototype = <span class="built_in">Object</span>.create(DetectorBase.prototype);</span><br><span class="line">LinkDetector.prototype.constructor = LinkDetector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l = <span class="keyword">new</span> LinkDetector();</span><br><span class="line"><span class="built_in">console</span>.log(l); <span class="comment">//LinkDetector &#123;&#125;__proto__: LinkDetector</span></span><br><span class="line">l.detect(); <span class="comment">//Detection starting...</span></span><br><span class="line">l.init(); <span class="comment">//Uncaught Error: Error</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一般面向对象包含：继承，封装，多态，抽象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;对象形式的继承&quot;&gt;&lt;a href=&quot;#对象形式的继承&quot; class=&quot;headerlink&quot; title=&quot;对象形式的继承&quot;&gt;&lt;/a&gt;对象形式的继承&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h5&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://blog.jddfe.com/tags/javascript/"/>
    
    <category term="学习笔记" scheme="https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="面向对象" scheme="https://blog.jddfe.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>OOP之类与对象</title>
    <link href="https://blog.jddfe.com/posts/10937/"/>
    <id>https://blog.jddfe.com/posts/10937/</id>
    <published>2016-08-15T12:55:24.000Z</published>
    <updated>2020-11-17T12:54:33.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><hr><h5 id="对象的含义"><a href="#对象的含义" class="headerlink" title="对象的含义"></a>对象的含义</h5><ul><li><p>所谓对象，就是一种无序的数据集合，由若干个“键值对”（<code>key-value</code>）构成</p><a id="more"></a><h5 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h5></li><li><p>使用<code>new</code>运算符创建<code>Object</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">p.name = <span class="string">&quot;Tony&quot;</span>;    </span><br></pre></td></tr></table></figure><ul><li>使用对象字面量的形式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象字面量形式</span></span><br><span class="line"><span class="keyword">var</span> p =&#123;</span><br><span class="line">    name: <span class="string">&quot;tony&quot;</span>,</span><br><span class="line">    work: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;working....&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    _age: <span class="number">18</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">age</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">age</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params"> val &lt;<span class="number">0</span> || val &gt; <span class="number">150</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;invalid value&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>._age = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p.name);</span><br></pre></td></tr></table></figure><h5 id="对象的基本操作"><a href="#对象的基本操作" class="headerlink" title="对象的基本操作"></a>对象的基本操作</h5><ul><li>成员属性的添加</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.defineProperty()方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(p, <span class="string">&quot;age&quot;</span>,&#123;<span class="attr">value</span>: <span class="number">18</span>, <span class="attr">writable</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"><span class="comment">//Object.defineProperties()方法 添加多个属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(p, &#123;</span><br><span class="line">    salary:&#123;</span><br><span class="line">        value: <span class="number">1000</span>,</span><br><span class="line">        writable: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    gender:&#123;</span><br><span class="line">        value: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>成员的遍历</p><ul><li>使用 <code>for..in</code>语句</li><li><code>Object.keys()</code>方法 返回一个包含对象键名的字符串数组</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o =&#123;&#125;;</span><br><span class="line">o.name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">o.age = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i <span class="keyword">in</span> o</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o[i]);</span><br><span class="line">&#125; <span class="comment">// jack, 20</span></span><br><span class="line"><span class="built_in">Object</span>.keys(o); <span class="comment">// [&quot;name&quot;, &quot;age&quot;]</span></span><br></pre></td></tr></table></figure><ul><li><p>检查对象是否有某个属性</p><ul><li><code>in</code> 操作符</li><li><code>Object.hasOwnProperty()</code>方法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>: <span class="string">&quot;mariya&quot;</span>&#125;</span><br><span class="line"><span class="string">&quot;name&quot;</span> <span class="keyword">in</span> o; <span class="comment">// true</span></span><br><span class="line">o.hasOwnProperty(<span class="string">&quot;name&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>得到对象的属性特性描述 <code>Object.getOwnPropertyDescriptor(obj,property)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//Object &#123;</span></span><br><span class="line"><span class="comment">//    value: &quot;mariya&quot;, writable: true, enumerable: true, configurable: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除属性<ul><li><code>delete</code>运算符,但有些对象的属性是删除不了的</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> o.name; <span class="comment">//true</span></span><br><span class="line">o.name;  <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure><h5 id="Constructor属性"><a href="#Constructor属性" class="headerlink" title="Constructor属性"></a>Constructor属性</h5><ul><li><code>constructor</code>始终指向创建当前对象的构造函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 由构造函数实例化一个obj对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor === Foo); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor.constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>每个函数都有一个默认的属性<code>prototype</code>，而这个<code>prototype</code>的<code>constructor</code>默认指向这个函数</li></ul><h4 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h4><hr><ul><li><p>虽然<code>js</code>是门基于对象的语言，但是没有类这一概念的，虽然保留了<code>class</code>的关键字，但在<code>ES6</code>之前是无法使用的。所以，可以用构造函数模拟类的创建，也就是伪类。</p></li><li><p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了<code>this</code>变量。对构造函数使用<code>new</code>运算符，就能生成实例，并且<code>this</code>变量会绑定在实例对象上</p></li><li><p>每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>)</span>&#123; <span class="comment">//Class</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将公共的属性或方法放在prototype属性上</span></span><br><span class="line">Person.prototype.headCount = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//创建实例对象</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="number">19</span>, <span class="string">&#x27;johnsom&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">20</span>, <span class="string">&#x27;allen&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><hr><ul><li><code>this</code>表示当前对象，如果在全局作用范围内使用<code>this</code>，则指代当前页面对象<code>window</code>； 如果在函数中使用<code>this</code>，则<code>this</code>指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用<code>apply</code>和<code>call</code>两个全局方法来改变函数中<code>this</code>的具体指向</li></ul><h5 id="全局代码中的this"><a href="#全局代码中的this" class="headerlink" title="全局代码中的this"></a>全局代码中的this</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">//true 全局范围内使用this指向window对象</span></span><br></pre></td></tr></table></figure><h5 id="普通的函数调用"><a href="#普通的函数调用" class="headerlink" title="普通的函数调用"></a>普通的函数调用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&quot;tony&quot;</span>; <span class="comment">// this在运行时指向window对象,在严格模式下则是undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在对象中使用"><a href="#在对象中使用" class="headerlink" title="在对象中使用"></a>在对象中使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">&quot;tony&quot;</span>,</span><br><span class="line">    print: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);  <span class="comment">//this指向对象o，但是可以改变其指向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="作为构造函数"><a href="#作为构造函数" class="headerlink" title="作为构造函数"></a>作为构造函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> F(); <span class="comment">// 函数内部的this指向新创建的对象。</span></span><br></pre></td></tr></table></figure><h5 id="多层嵌套的内部函数"><a href="#多层嵌套的内部函数" class="headerlink" title="多层嵌套的内部函数"></a>多层嵌套的内部函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">&quot;person&quot;</span>,</span><br><span class="line">    hello : <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sayhello = <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot; says &quot;</span> + sth);</span><br><span class="line">        &#125;;</span><br><span class="line">        sayhello(sth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.hello(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//global says hello world</span></span><br></pre></td></tr></table></figure><ul><li>在内部函数中，<code>this</code>没有按预想的绑定到外层函数对象上，而是绑定到了全局对象。这里普遍被认为是<code>javascript</code>语言的设计错误，因为没有人想让内部函数中的<code>this</code>指向全局对象。一般的处理方式是将<code>this</code>作为变量保存下来，一般约定为<code>that</code>或者<code>self</code>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">&quot;person&quot;</span>,</span><br><span class="line">    hello : <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> sayhello = <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(that.name + <span class="string">&quot; says &quot;</span> + sth);</span><br><span class="line">        &#125;;</span><br><span class="line">        sayhello(sth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.hello(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//person says hello world</span></span><br></pre></td></tr></table></figure><h5 id="事件中的this"><a href="#事件中的this" class="headerlink" title="事件中的this"></a>事件中的this</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">ele.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);  <span class="comment">//this指向dom元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="使用apply和call改变this的指向"><a href="#使用apply和call改变this的指向" class="headerlink" title="使用apply和call改变this的指向"></a>使用apply和call改变this的指向</h5><ul><li><code>apply</code>和<code>call</code>类似，只是后面的参数是通过一个数组传入，而不是分开传入。两者都是将某个函数绑定到某个具体对象上使用，自然此时的<code>this</code>会被显式的设置为第一个参数。两者的方法定义：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call( thisArg [，arg1，arg2，… ] );  <span class="comment">// 参数列表，arg1，arg2，...</span></span><br><span class="line">apply(thisArg [，argArray] );     <span class="comment">// 参数数组，argArray</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">&#x27;job&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o.getName(); <span class="comment">// job</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用call或apply改变函数中this的指向</span></span><br><span class="line">o.getName.call(<span class="built_in">this</span>); <span class="comment">// global</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>简单的总结：</strong></p><ul><li>当函数作为对象的方法调用时，<code>this</code>指向该对象。</li><li>构造函数中的<code>this</code>指向新创建的对象</li><li>嵌套函数中的<code>this</code>不会继承上层函数的<code>this</code>，如果需要，可以用一个变量保存上层函数的<code>this</code></li></ul></li></ul><h5 id="bind（）"><a href="#bind（）" class="headerlink" title="bind（）"></a>bind（）</h5><ul><li>该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入<code>bind</code>方法的第一个参数作为<code>this</code>，传入<code>bind</code>方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#ele&quot;</span>).click(person.hello.bind(person));</span><br><span class="line"><span class="comment">//相应元素被点击时，输出person says hello world</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;对象的含义&quot;&gt;&lt;a href=&quot;#对象的含义&quot; class=&quot;headerlink&quot; title=&quot;对象的含义&quot;&gt;&lt;/a&gt;对象的含义&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所谓对象，就是一种无序的数据集合，由若干个“键值对”（&lt;code&gt;key-value&lt;/code&gt;）构成&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://blog.jddfe.com/tags/javascript/"/>
    
    <category term="学习笔记" scheme="https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="面向对象" scheme="https://blog.jddfe.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>移动端自适应适配实现方案</title>
    <link href="https://blog.jddfe.com/posts/14854/"/>
    <id>https://blog.jddfe.com/posts/14854/</id>
    <published>2016-06-16T07:21:47.000Z</published>
    <updated>2020-11-17T12:54:33.346Z</updated>
    
    <content type="html"><![CDATA[<p>最近招聘面试过程中，我经常会问到这个移动端自适应适配是怎么实现的，大部分候选人都能说初rem的方式，但是很少有能说出原理的。</p><h4 id="rem-实现弹性布局原理"><a href="#rem-实现弹性布局原理" class="headerlink" title="rem 实现弹性布局原理"></a>rem 实现弹性布局原理</h4><p>根据屏幕宽度动态改变 html 根字体的大小。</p><p><strong>（1）rem + js 实现弹性布局</strong>   </p><p>rem 和 em 两者都是 css 的相对单位，但是两者有明显的区别：<br>当作为font-size单位时，em 表示相对于父元素字体的大小；当作为其他单位时，表示自身字体大小，比如首行缩紧2个字符 text-indent:2em; 。<br>当作为非根元素的时，rem 是相对于根字体的大小；当作为根元素时，相对于初始字体大小的。<br>💡em 容易造成“牵一发而动全身”，可以用作于行高、首行缩紧等；rem 最大的特点是统一参考系，其实现弹性布局的本质是等比缩放（通常是基于宽度）。</p><p><strong>（2）更高级的单位 vw 实现弹性布局</strong>  </p><p>如果把屏幕宽度分为 100 份，每一份就是宽度的 1% ，如果以这一份为单位 就可以实现弹性布局了。利用 rem 相对于根字体这个特性，可以间接地实现这样的单位。 根字体的大小通常是通过 js 获取屏幕宽度设置的。但是 CSS3 引入了一个新的单位 vw ，vw —— 视口宽度的 1/100，其实正是上面我们想办法实现的那个每一份的单位。 vw 允许不通过 js 也能实现根据屏幕宽度的弹性布局。</p><p><strong>（3）vw + rem实现弹性布局</strong>  </p><p>我们完全可以通过 vw 实现弹性布局，当然 vw 结合 rem 同样可以实现弹性布局。   </p><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>移动端设备的屏幕大小差别很大，为了避免因为屏幕过宽或过窄造成字体过大或过小，需要结合媒体查询 根据不同屏幕的宽度，设定相对单位的大小。这个时候就需要利用 rem 实现了。 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//当屏幕宽度小于 320px 的时候，规定字体大小 64px 。</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">320px</span>) &#123;  </span><br><span class="line">  <span class="selector-tag">font-size</span>: 64<span class="selector-tag">px</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//当屏幕宽度大于 540px 的时候，规定字体大小 108px 。</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">540px</span>) &#123;  </span><br><span class="line">  <span class="selector-tag">font-size</span>: 108<span class="selector-tag">px</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>💡响应式布局是不同设备、屏幕展示的样式不同。弹性布局则是等比缩放，高度还原。弹性布局属于响应式布局的一种。使用 rem 实现弹性布局不允许用户设置字体大小，所以 rem 通常适用于图标类活动页，而不是适用于纯文本的页面。</p><h4 id="css-预处理器语言-scss"><a href="#css-预处理器语言-scss" class="headerlink" title="css 预处理器语言 scss"></a>css 预处理器语言 scss</h4><p>scss 是 css 预处理器语言，语法规则和 css 类似。比如，变量使用 $ 符表示，如 $m_fontsize:75 。可以定义函数等。<br>具体规则可查看<a href="https://www.sass.hk/docs/">sass官方文档</a>。</p><h4 id="rem-vw-媒体查询方式实现弹性布局的完整代码实例"><a href="#rem-vw-媒体查询方式实现弹性布局的完整代码实例" class="headerlink" title="rem + vw + 媒体查询方式实现弹性布局的完整代码实例"></a>rem + vw + 媒体查询方式实现弹性布局的完整代码实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通常设计稿以 iphone6 为模型来设计的。因为 iphone6 屏幕宽度是 750px ，所以 iphone6 的屏宽尺寸设置根元素大小基准值 75px ，这里 75px 只是用来计算的，完全可以设置成其他的值</span><br><span class="line">$m_fontsize: 75;   </span><br><span class="line">@function rem($px) &#123;  </span><br><span class="line">  @return ($px &#x2F; $m_fontsize) * 1rem;  </span><br><span class="line">&#125;  </span><br><span class="line">$m_design: 750;  </span><br><span class="line">html &#123;  </span><br><span class="line">  font-size: ($m_fontsize &#x2F; ($m_design &#x2F; 2)) * 100vw;   </span><br><span class="line">  &#x2F;&#x2F; 通过媒体查询限制屏幕过宽过窄造成的页面内容过大和过小的问题</span><br><span class="line">  @media screen and (max-width: 320px) &#123;  </span><br><span class="line">    font-size: 64px;  </span><br><span class="line">  &#125;  </span><br><span class="line">  @media screen and (min-width: 540px) &#123;  </span><br><span class="line">    font-size: 110px;  </span><br><span class="line">  &#125;  </span><br><span class="line">&gt;&#125;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近招聘面试过程中，我经常会问到这个移动端自适应适配是怎么实现的，大部分候选人都能说初rem的方式，但是很少有能说出原理的。&lt;/p&gt;
&lt;h4 id=&quot;rem-实现弹性布局原理&quot;&gt;&lt;a href=&quot;#rem-实现弹性布局原理&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="rem" scheme="https://blog.jddfe.com/tags/rem/"/>
    
    <category term="css" scheme="https://blog.jddfe.com/tags/css/"/>
    
    <category term="适配" scheme="https://blog.jddfe.com/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
</feed>
