{"meta":{"title":"JDDFE","subtitle":"just do devFE","description":"简单的前端","author":"jddfer","url":"https://blog.jddfe.com","root":"/"},"pages":[{"title":"","date":"2020-11-15T15:05:10.472Z","updated":"2020-11-15T15:05:10.472Z","comments":true,"path":"tmp-bak.html","permalink":"https://blog.jddfe.com/tmp-bak.html","excerpt":"","text":"关于介绍不是一个人（不是人），而是一个组织。招募热爱前端开发及用户体验设计，喜欢新事物，关注前端动态，对新的技术有追求， 喜欢产品，喜欢Coding 的你一起加入。"},{"title":"关于","date":"2020-11-15T15:10:40.645Z","updated":"2020-11-15T15:10:40.645Z","comments":false,"path":"about/index.html","permalink":"https://blog.jddfe.com/about/index.html","excerpt":"","text":"1234567891011121314151617181920212223242526&#123; name: &#x27;jddfer&#x27; profession: &#x27;写代码，学理财，没事经常吃吃瓜！！！&#x27;, address: &#x27;帝都&#x27;, github: &#x27;https://github.com/jddfe&#x27;, blog: &#x27;http://blog.jddfe.com&#x27;, email: &#x27;jddfe_com@163.com&#x27;, description: &#x27;不懂理财的吃瓜群众不是好攻城狮~&#x27;, skills: [ [&#x27;Html&#x27;, &#x27;Javascript&#x27;, &#x27;jQuery&#x27;, &#x27;CSS&#x27;, &#x27;ES6&#x27;, &#x27;Node&#x27;], [&#x27;Webpack&#x27;, &#x27;Gulp&#x27;], [&#x27;Less&#x27;,&#x27;Sass&#x27;], [&#x27;Git&#x27;, &#x27;SVN&#x27;], [&#x27;Vue&#x27;], [&#x27;平面设计&#x27;, &#x27;产品设计&#x27;] ], devTools: [ [&#x27;Sublime Text&#x27;, &#x27;Visual Studio Code&#x27;, &#x27;WebStorm&#x27;], [&#x27;Chrome DevTools&#x27;, &#x27;Fiddler&#x27;, &#x27;Charles&#x27;], [&#x27;SourceTree&#x27;, &#x27;TortoiseSVN&#x27;], [&#x27;SwitchHosts&#x27;], [&#x27;Navicat&#x27;, &#x27;XAMPP&#x27;], ] &#125;"},{"title":"书单","date":"2020-11-09T13:38:40.331Z","updated":"2020-11-09T06:37:15.850Z","comments":false,"path":"books/index.html","permalink":"https://blog.jddfe.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-10T12:10:26.148Z","updated":"2020-11-09T06:37:15.850Z","comments":false,"path":"categories/index.html","permalink":"https://blog.jddfe.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-11-09T13:40:17.085Z","updated":"2020-11-09T06:37:15.850Z","comments":true,"path":"links/index.html","permalink":"https://blog.jddfe.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-10T16:49:26.393Z","updated":"2020-11-09T06:37:15.851Z","comments":false,"path":"tags/index.html","permalink":"https://blog.jddfe.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端安全之跨站脚本攻击（XSS）防御","slug":"前端安全之跨站脚本攻击（XSS）防御","date":"2021-01-28T22:41:53.000Z","updated":"2021-06-29T06:53:13.828Z","comments":true,"path":"posts/1746/","link":"","permalink":"https://blog.jddfe.com/posts/1746/","excerpt":"","text":"什么是跨站脚本攻击（XSS）跨站脚本（Cross Site Scripting，XSS）指攻击者在页面插入恶意代码，当其他用户访问时，浏览会器解析并执行这些代码，达到窃取用户身份、钓鱼、传播恶意代码等行为。一般我们把 XSS 分为反射型、存储型、DOM型 3 种类型。 反射型 XSS反射型 XSS 也叫“非持久型 XSS”，是指攻击者将恶意代码通过请求提交给服务端，服务端返回的内容，也带上了这段 XSS 代码，最后导致浏览器执行了这段恶意代码。 反射型 XSS 攻击方式需要诱导用户点击链接，攻击者会伪装该链接（例如短链接），当用户点击攻击者的链接后，攻击者便可以获取用户的 cookie 身份信息。 案例：服务端直接输出参数内容： 123&lt;? php$input = $_GET[&quot;param&quot;];echo &quot;&lt;div&gt;&quot;.$input.&quot;&lt;/div&gt;&quot;; 恶意代码链接： 1http:&#x2F;&#x2F;www.a.com&#x2F;test.php?param&#x3D;&lt;srcipt src&#x3D;&quot;xss.js&quot;&gt;&lt;&#x2F;script&gt; 存储型 XSS存储型 XSS 也叫“持久型XSS”，会把用户输入的数据存储在服务端，这种XSS具有很强的稳定性。 案例：比如攻击者在一篇博客下留言，留言包含恶意代码，提交到服务端后被存储到数据库。所有访问该博客的用户，在加载出这条留言时，会在他们的浏览器中执行这段恶意的代码。 DOM 型 XSSDOM 型 XSS 是一种特殊的反射型 XSS，它也是非持久型 XSS。相比于反射型 XSS，它不需要经过服务端，而是改变页面 DOM 来达到攻击。同样，这种攻击方式也需要诱导用户点击。 案例： 目标页面： 1234567&lt;html&gt; &lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;&lt;script&gt; let search = new URLSearchParams(location.search) document.write(&quot;hello, &quot; + search.get(&#x27;name&#x27;) + &#x27;!&#x27;)&lt;/script&gt; 恶意代码链接： 1http:&#x2F;&#x2F;www.a.com&#x2F;test.index?name&#x3D;&lt;srcipt src&#x3D;&quot;xss.js&quot;&gt;&lt;&#x2F;script&gt; 防御手段 参数验证，不符合要求的数据不要存入数据库 对特殊字符转义，如”&lt;”、”&gt;”、”/“、”&amp;”等 避免使用eval、new Function动态执行字符串的方法 避免使用 innerHTML、document.write 直接将字符串输出到HTML 把一些敏感的 cookie 设置为 http only，避免前端访问 cookie","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端安全 XSS","slug":"前端安全-XSS","permalink":"https://blog.jddfe.com/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8-XSS/"}]},{"title":"Vue知识汇总","slug":"Vue知识汇总","date":"2021-01-07T20:09:20.000Z","updated":"2021-06-29T06:07:29.252Z","comments":true,"path":"posts/34562/","link":"","permalink":"https://blog.jddfe.com/posts/34562/","excerpt":"","text":"对MVVM模式的理解MVVM 对应 3个组成部分，Model（模型）、View（视图） 和 ViewModel（视图模型）。 1）View 是用户在屏幕上看到的结构、布局和外观，也称UI。2）ViewModel 是一个绑定器，能和 View 层和 Model 层进行通信。3）Model 是数据和逻辑。 View 不能和 Model 直接通信，它们只能通过 ViewModel 通信。Model 和 ViewModel 之间的交互是双向的，ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。 严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 在组件提供了 $refs 这个属性，让 Model 可以直接操作 View，违反了这一规定。 Vue的渲染流程流程主要分为三个部分： 1）模板编译，parse 解析模板生成抽象语法树（AST）；optimize 标记静态节点，在后续页面更新时会跳过静态节点； generate 将AST转成 render 函数，render 函数用于构建 VNode。2）构建VNode（虚拟dom），构建过程使用 createElement 构建 VNode， createElement 也是自定义 render 函数时接受到的第一个参数。3）VNode转真实dom，patch 函数负责将 VNode 转换成真实dom， 核心方法是createElm，递归创建真实dom树，最终渲染到页面上。 Vue 生命周期 beforeCreate: 在实例创建之前调用，由于实例还未创建，所以无法访问实例上的 data、computed、method等。 created: 在实例创建完成后调用，这时已完成数据的观测，可以获取数据和更改数据，但还无法与dom进行交互，如果想要访问dom，可以使用 vm.$nextTick。此时可以对数据进行更改，不会触发 updated。 beforeMount: 在挂载之前调用，这时的模板已编译完成并生成render函数，准备开始渲染。在此时也可以对数据进行更改，不会触发 updated。 mounted: 在挂载完成后调用，真实的dom挂载完毕，可以访问到dom节点，使用 $refs 属性对dom进行操作。 beforeUpdate: 在更新之前调用，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，在当前阶段进行更改数据，不会造成重渲染。 updated： 在更新完成之后调用，组件dom已完成更新。要注意的是避免在此期间更改数据，这可能会导致死循环。 beforeDestroy： 在实例销毁之前调用，这时实例还可以被使用，一般这个周期内可以做清除计时器和取消事件监听的工作。 destroyed： 在实例销毁之后调用，这时已无法访问实例。当前实例从父实例中被移除，观测被卸载，所有事件监听器呗移除，子实例也统统被销毁。 Vue 父组件和子组件生命周期执行顺序1、渲染过程 1)父组件 beforeCreate 2)父组件 created 3)父组件 beforeMount 4)子组件 beforeCreate 5)子组件 created 6)子组件 beforeMount 7)子组件 mounted 8)父组件 mounted 子组件早于父组件挂载，因为创建节点树时使用的是递归，子组件会先被创建完成，最后才是整个父节点创建完成。 2、更新过程 1）父组件 beforeUpdate 2）子组件 beforeUpdate 3）子组件 updated 4）父组件 updated 3、销毁过程 1）父组件 beforeDestroy 2）子组件 beforeDestroy 3）子组件 destroyed 4）父组件 destroyed data为什么要求是函数当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。 Vue 构造实例使用的是同一个构造函数，data 直接使用对象会导致实例的共享引用，即组件间的状态会相互影响。通常发生共享引用，都是组件复用的情况。使用函数返回一个对象，由于是不同引用，自然可以避免这个问题发生。 组件通信方式 props/emit $children/$parent ref $attrs/$listeners provide/inject eventBus vuex Vue 的5种指令1）v-if2）v-for3）v-show4）v-html5）v-model v-if 和 v-show 的区别v-if 会让条件块内元素或组件适当地被销毁和重建。v-show 的元素或组件一开始就被渲染，只是简单的进行css切换。相比之下，v-if 会带来更高的切换消耗，所以频繁切换使用 v-show，不常切换则使用 v-if。 v-model的理解v-model 是属性 value 和 input 事件的语法糖。内部默认将 value 作为值，使用 $emit 触发 input 事件更新属性，从而实现双向绑定。而自定义双向绑定可以定义组件的 model 选项设置 prop 和 event 来实现。 双向绑定原理双向绑定是视图变化会反映到数据，数据变化会反映到视图，v-model 就是个很好理解的例子。其实主要考查的还是响应式原理，响应式原理共包括3个主要成员，Observer 负责监听数据变化，Dep 负责依赖收集，Watcher 负责数据或视图更新，我们常说的收集依赖就是收集 Watcher。 响应式原理主要工作流程如下：1）Observer 内使用 Object.defineProperty 劫持数据，为其设置 set 和 get。2）每个数据都会有自己的 dep。数据取值触发 get 函数，调用 dep.depend 收集依赖； 数据更新触发 set 函数，调用 dep.notify 通知 Watcher 更新。3）Watcher 接收到更新的通知，将这些通知加入到一个异步队列中， 并且进行去重处理，等到所有同步操作完成后，再一次性更新视图。 Vue 中 的 key 有什么作用key 是每个 VNode 的唯一标识，依靠 key 能够在 diff 算法执行时更快的找到对应的 VNode，提高 diff 速度。key 能保证元素之间的状态独立，在更新后状态不被复用，避免一些意外的结果。就像输入框在复用的情况下，即使元素更新，输入框的内容依旧没有刷新，这是因为 Vue 默认是使用“就地复用”的策略，会尽可能减少创建和销毁的过程。 computed 和 watch 的区别1）computed 依赖 data 的改变而改变，computed 有返回值；watch 观测 data， 执行对应的函数。2）computed 有缓存功能，重复取值不会执行求值函数。3）computed 依赖收集在页面渲染时触发，watch 依赖收集在页面渲染前触发。4）computed 更新需要“渲染Watcher”的配合，computed 更新只是设置 dirty， 需要页面渲染触发 get 重新求值 Vue 中的 computed 是如何实现缓存的“计算属性Watcher”会带有一个 dirty 的属性，在初始化取值完成后，会将求值结果缓存起来，并把 dirty 设置为 false。只要依赖属性不更新，dirty 永远为 false，重复取值也不会再去执行求值函数，而是直接返回缓存结果，从而实现缓存。相反，依赖属性更新会将“计算属性 Watcher”的 dirty 设置为 true，在页面渲染对计算属性取值时，再次触发求值函数更新计算属性。 1234567891011Object.defineProperty(target, key, &#123; get() &#123; const watcher &#x3D; this._computedWatchers &amp;&amp; this._computedWatchers[key] &#x2F;&#x2F; 计算属性缓存 if (watcher.dirty) &#123; &#x2F;&#x2F; 计算属性求值 watcher.evaluate() &#125; return watcher.value &#125;&#125;) 子组件为什么不能直接更改props？什么是单向数据流？所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。 子组件不能更改 props 是因为要遵循单向数据流的原则。单向数据流只允许数据由父组件传递给子组件，数据只能由父组件更新。当数据传递到多个子组件，而子组件能够在其内部更新数据时，在主观上很难知道是哪个子组件更新了数据，导致数据流向不明确，从而增加应用调试的难度。但子组件更新父组件数据的场景确实存在，有3种方法可以使用： 1）子组件 emit，父组件接受自定义事件。这种方法最终还是由父组件进行修改， 子组件只是起到一个通知的作用。2）子组件自定义双向绑定，设置组件的 model 选项为组件添加自定义双向绑定。3）.sync 属性修饰符，它是第一种方法的语法糖，在传递属性添加上该修饰符， 子组件内可调用 this.$emit(‘update:属性名’, value) 更新属性。 Vue 如何检测数组更新Vue 内部重写数组原型链，当数组发生变化时，除了执行原生的数组方法外，还会调用 dep.notify 通知 Watcher 更新。触发数组更新的方法共7种： 1)push2)pop3)shift4)unshift5)splice6)sort7)reverse keep-alive 是如何实现的？keep-alive 是 Vue 的内置组件，同时也是一个抽象组件，不会作为元素被渲染到页面上。它用于组件缓存。当组件切换时会将组件的VNode缓存起来，等待下次重新激活时，再将缓存的组件VNode取出来渲染，从而实现缓存。 常用的两个属性 include 和 exclude，支持字符串、正则和数组的形式，允许组件有条件的进行缓存。还有 max 属性，用于设置最大缓存数。 两个生命周期 activated 和 deactivated，在组件激活和失活时触发。 keep-alive 的缓存机制运用LRU(Least Recently Used)算法 说一下 nextTick 的原理在下次 dom 更新结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用： 1)Promise2)MutationObserver3)setImmediate4)setTimeout nextTick 主要用于内部 Watcher 的异步更新，对外我们可以使用 Vue.nextTick 和 vm.$nextTick。在 nextTick 中可以获取更新完成的 dom。 对比 Vue3 和 Vue2.x1)使用 Proxy 代替 Object.defineProperty2)新增 Composition API3)模板允许多个根节点 Vue3 为什么使用 Proxy 代替 Object.definedPropertyObject.definedProperty 只能检测到属性的获取和设置，对于新增和删除是没办法检测的。在数据初始化时，由于不知道哪些数据会被用到，Vue 是直接递归观测全部数据，这会导致性能多余的消耗。 Proxy 劫持整个对象，对象属性的增加和删除都能检测到。Proxy 并不能监听到内部深层的对象变化，因此 Vue 3.0 的处理方式是在 getter 中去递归响应式，只有真正访问到的内部对象才会变成响应式，而不是无脑递归，在很大程度上提升了性能。 路由懒加载是如何实现的路由懒加载是性能优化的一种手段，在编写代码时可以使用 import() 引入路由组件，使用懒加载的路由会在打包时单独出来成一个 js 文件，可以使用 webpackChunkName 自定义包名。在项目上线后，懒加载的 js 文件不会在第一时间加载，而是在访问到对应的路由时，才会动态创建 script 标签去加载这个 js 文件。 12345&#123; path:&#39;users&#39;, name:&#39;users&#39;, component:()&#x3D;&gt; import(&#x2F;*webpackChunkName: &quot;users&quot;*&#x2F; &#39;@&#x2F;views&#x2F;users&#39;),&#125; Vue路由钩子函数1、全局钩子 123456789101112131415161718&#x2F;&#x2F; 1&gt; beforeEach （路由进入前调用）const router &#x3D; new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) &#x3D;&gt; &#123; &#x2F;&#x2F; ...&#125;)&#x2F;&#x2F; 2&gt; beforeResolve (2.5.0 新增) 在所有组件内守卫和异步组件被解析之后调用router.beforeResolve((to, from, next) &#x3D;&gt; &#123; &#x2F;&#x2F; ...&#125;)&#x2F;&#x2F; 3&gt; afterEach 路由在确认后调用router.afterEach((to, from) &#x3D;&gt; &#123; &#x2F;&#x2F; ...&#125;) 2、路由独享钩子 12345678910111213&#x2F;&#x2F; beforeEnter 路由进入前调用，beforeEnter 在 beforeEach 之后执行const router &#x3D; new VueRouter(&#123; routes: [ &#123; path: &#39;&#x2F;foo&#39;, component: Foo, beforeEnter: (to, from, next) &#x3D;&gt; &#123; &#x2F;&#x2F; ... &#125; &#125; ]&#125;) 3、组件钩子 1234567891011121314151617181920&#x2F;&#x2F; 1）beforeRouteEnter 路由确认前调用，组件实例还没被创建，不能获取组件实例 thisbeforeRouteEnter (to, from, next) &#123; &#x2F;&#x2F; ... &#x2F;&#x2F; 可以通过回调访问实例 next(vm &#x3D;&gt; &#123; &#x2F;&#x2F; vm 为组件实例 &#125;)&#125;,&#x2F;&#x2F; 2）beforeRouteUpdate (2.2 新增) 路由改变时调用，可以访问组件实例beforeRouteUpdate (to, from, next) &#123; &#x2F;&#x2F; ...&#125;,&#x2F;&#x2F; 3）beforeRouteLeave 离开该组件的对应路由时调用，可以访问组件实例 thisbeforeRouteLeave (to, from, next) &#123; &#x2F;&#x2F; ...&#125; vue-router的原理vue-router 原理是更新视图而不重新请求页面。vue-router 共有3种模式：hash模式、history模式、abstract模式。 1、hash模式hash 模式使用 hashchange 监听地址栏的 hash 值的变化，加载对应的页面。每次的 hash 值变化后依然会在浏览器留下历史记录，可以通过浏览器的前进后退按钮回到上一个页面。 2、history模式history 模式基于History Api实现，使用 popstate 监听地址栏的变化。使用 pushState 和 replaceState 修改 url，而无需加载页面。但是在刷新页面时还是会向后端发起请求，需要后端配合将资源定向回前端，交由前端路由处理。 3、abstract不涉及和浏览器地址的相关记录。通过数组维护模拟浏览器的历史记录栈。 vuex 怎么跨模块调用跨模块调用是指当前命名空间模块调用全局模块或者另一个命名空间模块。在调用 dispatch 和 commit 时设置第三个参数为 {root：true}。 12345678910111213141516modules: &#123; foo: &#123; namespaced: true, actions: &#123; someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123; &#x2F;&#x2F; 调用自己的action dispatch(&#39;someOtherAction&#39;) &#x2F;&#x2F; -&gt; &#39;foo&#x2F;someOtherAction&#39; &#x2F;&#x2F; 调用全局的action dispatch(&#39;someOtherAction&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;someOtherAction&#39; &#x2F;&#x2F; 调用其他模块的action dispatch(&#39;user&#x2F;someOtherAction&#39;, null, &#123; root: true &#125;) &#x2F;&#x2F; -&gt; &#39;user&#x2F;someOtherAction&#39; &#125;, someOtherAction (ctx, payload) &#123; ... &#125; &#125; &#125;&#125; vuex 如何实现持久化vuex存储的状态在页面刷新后会丢失，使用持久化技术能保证页面刷新后状态依然存在。 1）使用本地存储配合，设置 state 同时设置 storage，在刷新后再初始化 vuex2）vuex-persistedstate 插件","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue 学习笔记","slug":"vue-学习笔记","permalink":"https://blog.jddfe.com/tags/vue-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"一个快速，零配置的 Web 应用打包工具 📦","slug":"🚀 宣布 Parcel：一个快速，零配置的 Web 应用打包工具 📦","date":"2020-12-20T21:13:38.000Z","updated":"2021-06-29T04:01:49.091Z","comments":true,"path":"posts/8237/","link":"","permalink":"https://blog.jddfe.com/posts/8237/","excerpt":"","text":"🚀 宣布 Parcel：一个快速，零配置的 Web 应用打包工具 📦 原文：🚀 Announcing Parcel: A blazing fast, zero configuration web application bundler 📦 译者：neal1991 welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me LICENSE: MIT 今天，我非常高兴地宣布 Parcel，一个快速，零配置的 Web 应用程序打包工具，我对于该工具的工作已经持续了几个月。 去 Github上看看吧！ 为了解决我在 Browserify 和 Webpack 等现有模块打包工具中遇到的两个主要问题：性能和配置经验，我开始研究 Parcel。 特性 🚀 非常快的打包时间 - 多核编译，以及文件系统缓存，这样即使在重新启动后也能快速重建。 📦对于 JS, CSS, HTML, 图片以及文件资源以及其它支持开箱即用，不需要安装插件。 🐠在需要时使用 Babel，PostCSS 和 PostHTML 自动转换模块 - 甚至是node_modules。 ✂️ 零配置代码分割使用动态import() 语句。 🔥内置支持热加载 🚨 友好的错误日志体验 - 语法高亮显示的代码帧有助于查明问题。 性能我被激发建立一个新的打包工具的第一个原因是性能。 我已经在数千个模块上做了一些相当大的应用程序，并且总是对现有打包工具的速度感到失望。 大型应用程序可能需要几分钟才能完成，这在开发过程中尤其令人沮丧 许多打包工具专注于快速增量重新构建性能，这是很好的。 但是，最初的构建性能对于开发和生产/ CI 构建也非常重要。 Parcel 通过使用工作进程并行编译代码，利用现代多核处理器解决了这个问题。 这导致了初始构建的巨大加速。 它还有一个文件系统缓存，可以保存每个文件的编译结果，以便更快的后续启动。 零配置体验我建立Parcel的第二个原因是帮助解决管理配置的痛苦。大多数其它打包工具都是围绕着配置文件以及大量的插件建立起来的，为了使事情顺利进行，看到 500 行以上的应用程序配置并不罕见。 这种配置不仅繁琐耗时，而且很难正确使用，并且必须针对每个应用程序进行复制。通常情况下，这可能导致次优化的应用程序转到到生产。 Parcel 被设计为零配置：只需将它指向你的应用程序的入口点，它就能正确工作。 Parcel 支持 JS，CSS，HTML，图片，文件资源等等 - 不需要任何插件。 Parcel 的零配置体验也涉及到文件格式。当 Parcel 检测到 .babelrc，.postcssrc 等时，也会自动应用像 Babel，PostCSS 和 PostHTML 这样的转换。这甚至适用于仅用于该模块的 node_modules 中的第三方代码，因此应用程序作者不需要知道如何构建他们导入的每个模块，并且构建不会减慢不必要地在每个文件上运行 Babel。 最后，还支持代码分割和热模块重新加载等高级打包功能。在生产模式下，Parcel 自动启用缩小，未来还会进行其他优化，如 tree-shaking。 未来架构启动一个新项目的一个好处是，我能够为 Parcel 设计一个更加现代化的架构，这个架构更加可扩展，更灵活，同时无需用户配置，并支持代码拆分和热加载等高级功能。 大多数打包工具主要关注 JavaScript，并支持其他格式。例如，默认情况下，其他文件类型通常会内嵌到JavaScript 文件中，并使用额外的插件和 hack 将其再次提取到单独的文件中。 在 Parcel 中，任何类型的文件都可以成为一等公民。添加代表输入文件的新资源类型和将类似类型的资源组合到输出文件中的打包工具很容易。 例如，分析和生成 CSS 代码的 CSS 资源类型和将 CSS 资源组合成最终打包的 CSS Packager。 JS，HTML 等存在类似的类型。这样，Parcel 完全是文件类型无关的。 你可以阅读更多关于Parcel 如何在网站上工作的信息。 试试把Parcel 刚刚开始，但许多应用程序已经开箱即用并且零配置！ 所以试试看吧 - 删除你的webpack/browserify配置，卸载这些插件，然后尝试Parcel。😎 欢迎向我反馈！ 你可以在Twitter上找到我@devongovett。 网站和文档 Github","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://blog.jddfe.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"送给 ES6 开发者的7个hack","slug":"送给 ES6 开发者的7个hack ","date":"2020-12-19T21:13:38.000Z","updated":"2020-12-21T10:21:20.459Z","comments":true,"path":"posts/60300/","link":"","permalink":"https://blog.jddfe.com/posts/60300/","excerpt":"","text":"原文：7 Hacks for ES6 Developers 译者：neal1991 welcome to star my articles-translator, providing you advanced articles translation. Any suggestion, please issue or contact me LICENSE: MIT 关注原来的 JavaScript hacks，上面有一些新的好东西。2018 使用 JavaScript 写代码真的又变得有意思了！ Hack #1 — 交换变量使用数组结构来交换值 let a = &#39;world&#39;, b = &#39;hello&#39; [a, b] = [b, a] console.log(a) // -&gt; hello console.log(b) // -&gt; world // 是的，很神奇 Hack #2 — 使用解构的 Async/Await再说一遍，数组结构真的很棒。通过和 async/await 以及 promise 结合可以让复杂的流程变得简单。 const [user, account] = await Promise.all([ fetch(&#39;/user&#39;), fetch(&#39;/account&#39;) ]) Hack #3 — 调试对于那些喜欢使用 console.logs 来调试的人来说，现在有一些特别酷的（并且我也听说过 console.table）： const a = 5, b = 6, c = 7 console.log(&#123; a, b, c &#125;) // 输出优雅的对象: // &#123; // a: 5, // b: 6, // c: 7 // &#125; Hack #4 — 一行搞定一切对于数组操作，语法可以非常紧凑 // 寻找最大值 const max = (arr) =&gt; Math.max(...arr); max([123, 321, 32]) // outputs: 321 // 对数组求和 const sum = (arr) =&gt; arr.reduce((a, b) =&gt; (a + b), 0) sum([1, 2, 3, 4]) // output: 10 Hack #5 — 数组拼接拓展操作符可以用来代替 concat： const one = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] const two = [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;] const three = [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;] // 老方法 #1 const result = one.concat(two, three) // 老方法 #2 const result = [].concat(one, two, three) // 新方法 const result = [...one, ...two, ...three] Hack #6 — 克隆轻松克隆数组和对象： const obj = &#123; ...oldObj &#125; const arr = [ ...oldArr ] 注意：这会产生一个浅克隆。 Hack #7 — 命名参数通过结构让函数以及函数函数调用更具有可读性： 123456789101112const getStuffNotBad = (id, force, verbose) =&gt; &#123; ...do stuff&#125;const getStuffAwesome = (&#123; id, name, force, verbose &#125;) =&gt; &#123; ...do stuff&#125;// 在代码的其它某个地方... 到底什么是 true, true?getStuffNotBad(150, true, true)// 在代码的其他某个地方.. I ❤ JS!!!getStuffAwesome(&#123; id: 150, force: true, verbose: true &#125;) 已经全部知道了？ 你是一个真正的黑客，让我们继续在 Twitter上的谈话你还可以看看我的 Torii 教学，我们让“SaaS 头痛”消失。","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://blog.jddfe.com/tags/ES6/"}]},{"title":"微信公众号业务域名、JS接口安全域名、网页授权三者作用","slug":"微信公众号业务域名、JS接口安全域名、网页授权三者作用","date":"2020-12-06T21:57:39.000Z","updated":"2020-12-21T10:11:56.219Z","comments":true,"path":"posts/11988/","link":"","permalink":"https://blog.jddfe.com/posts/11988/","excerpt":"","text":"首先，这三者都是用来做网页开发的，需要具备网页开发技能。 1、业务域名 业务域名不仅在公众号中存在，在微信小程序中也存在设置的地方。业务域名的设置是微信保障了该公众号所开发的网页是合法的（微信认为合法）。如果不设置，当输入框聚焦时，微信会弹出警告提示！像这样： 如果在微信小程序中，当你使用内置webview想打开H5时，如果不设置业务域名，连网页也打不开。 2、JS安全域名 微信有一套JSSDK，在html中引入JSSDK可以调用相机，录音等API，如果不设置的话，你的网页也调不了这些API。 3、网页授权域名 当你需要获取用户信息时，就需要用到网页授权了。设置网页授权域名，当用户同意授权弹出框时，你就能调用获取用户信息的API，而如果不设置，你最多也只能拿到用户的openid（用户在微信的唯一标识）。","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"https://blog.jddfe.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"}]},{"title":"蛋壳爆雷还未跑路，某银行为啥慌了？","slug":"蛋壳爆雷还未跑路，某银行为啥慌了？","date":"2020-11-25T00:50:30.000Z","updated":"2020-11-26T15:06:45.297Z","comments":true,"path":"posts/60230/","link":"","permalink":"https://blog.jddfe.com/posts/60230/","excerpt":"","text":"最近，长租公寓蛋壳公寓出现资金链断裂，讨薪、跑路…目漫天的传闻也将成为真相。随着蛋壳爆雷，将引发了一场剧烈的地震。 无数打工人被坑，有的人甚至大半夜下着雨被房东从家里赶出来，行李全部丢在马路上，场面极为凄惨。 房东也好不到哪去，网上的视频，一个被坑的房东带着锁匠，想把自己房子的锁换掉，把租客赶走。租客报警，警察赶到阻止，警告胆敢换锁的话，房东和锁匠可能面临治安拘留，房东站在那里顿时懵了…… 蛋壳不仅坑了打工人和房东，连银行也被牵扯进来。 转自微博 - 通货朋仗","categories":[{"name":"吃瓜","slug":"吃瓜","permalink":"https://blog.jddfe.com/categories/%E5%90%83%E7%93%9C/"}],"tags":[{"name":"蛋壳公寓爆雷","slug":"蛋壳公寓爆雷","permalink":"https://blog.jddfe.com/tags/%E8%9B%8B%E5%A3%B3%E5%85%AC%E5%AF%93%E7%88%86%E9%9B%B7/"},{"name":"微众银行","slug":"微众银行","permalink":"https://blog.jddfe.com/tags/%E5%BE%AE%E4%BC%97%E9%93%B6%E8%A1%8C/"}]},{"title":"亚洲巨骗案之“一马币案”（二）","slug":"亚洲巨骗案之“一马币案”（二）","date":"2020-11-20T23:21:46.000Z","updated":"2020-11-26T15:12:49.907Z","comments":true,"path":"posts/14885/","link":"","permalink":"https://blog.jddfe.com/posts/14885/","excerpt":"","text":"接上篇，讲到刘马扁费了好半天劲，结果一分钱没捞到，不得不另找财路， 当时，全东南亚的目光都在关注[依斯干达经济特区]，就跟我们现在的粤港澳大湾区差不多。无数的地产开发商都在摩拳擦掌，想要参与其中，大赚一笔。 刚好，刘马扁听说有两家建筑公司的资金链断裂，正准备出售。于是他立刻想到低价买下这俩家公司，然后自己参与开发【依斯干达经济特区】，主意虽然好，但是买公司首先要有钱。苦撑两年的刘马扁，连租办公室的贷款都还没还，信用记录不良，银行也不愿意再贷款给他。怎么才能从银行那里搞到启动资金呢？ 他准备再利用一次自己的权贵人脉。因为这种高段位的操作，普通人可能一辈子也接触不到。 首先，刘马扁在英属维京群岛注册了一家公司——【阿布达比科威特大马投资公司】，简称ADKMIC。（Abu Dhabi-Kuwait-Malaysia Investment Corporation） 接着他把这家公司的干股送给了欧泰巴、科威特和马来西亚的官员。因为干股是无偿赠送的，能够享受公司的分红，所以欧泰巴等人欣然接受。接下来，刘马扁就偷偷地把这些人列为公司股东。这么做的目的，是为了外界以为这家公司背景深厚。果然，刘马扁再去银行贷款，就轻松地贷到了几百万美元。于是他用部分贷款，买下了那两家建筑公司，同时通过他的【赢吨集团】又借了一笔钱，在【依斯干达特区】买下了一块土地。这块空土地，紧挨着【穆巴达拉基金】计划开发的地方。 这样一来，刘马扁看起来，就不只是一个赚佣金的买办，而是共同投资人。当然刘马扁买这些公司和土地，不是自己用来开发。刘马扁真正的计划，是找一个冤大头，高价接盘他这两家刚买来的建筑公司。奔着这个目的，他又开始了一系列的骚操作。首先，他在印度洋上的塞舌尔小岛，注册了两家空壳公司。一家叫做【ADIA投资公司】，另一家叫做【KIA投资公司】。而全球两大主权基金——阿布扎比投资管理局和科威特投资管理局，它们的简称也同样是ADIA和KIA。(Abu Dhabi Investment Authority；Kuwait Investment Authority)。 这样，就会让人误以为，这两家公司和中东的两大主权基金有关。但实际上它们只是两家空壳公司。这时候，有很多亿万富翁就会问了：维尔京群岛和开曼群岛不是避税天堂吗，刘马扁为什么要去塞舌尔注册公司呢？原来刘马扁发现，这个印度洋上的塞舌尔小岛，不仅一样可以避税，还可以发行不记名的实体股票。 在设立【ADIA投资公司】时，刘马扁总共只发行了一张不记名实体股票，价值1美元。什么意思呢？也就是说，这张股票在谁的手上，谁就拥有这家公司。这种不记名实体股票，能够神不知鬼不觉地变更公司股权。不记名股票，在很多国家和地区都已经被禁止了，包括开曼群岛。但是在塞舌尔，还可以发行。 目光回到马来西亚，刘马扁不是贷款买了两家建筑公司吗？他把ADIA和KIA，这两家看起来和中东主权基金有关的投资公司，分别设为了两家建筑公司的股东。于是，在外人眼里，科威特皇室、马来西亚官员、阿联酋外交官以及两大主权基金，全都是刘马扁的合伙人。到这一步，刘马扁的精心布局已经全部完成。万事俱备，只欠韭菜。刘马扁要找的韭菜，是那种非常有钱，但对资本套路并不熟悉的人。 没多久，刘马扁就找到了合适的目标，马来西亚砂拉越州的高官——泰益．玛末。（Taib Mahmud）71岁的泰益，靠着林业发家，是马来西亚最有钱的人之一。刘马扁放出风声，说穆巴达拉基金在投资「依斯干达特区」之后，正在马来西亚寻找其他投资机会。而泰益，正好一直想找人投资砂拉越州的油棕提炼厂，于是联系上了刘马扁。刘马扁忽悠泰益说，“未来中东的投资者也许会想投资砂拉越州”，让他先买下刘马扁的建设公司以表诚意。 几个月后，刘马扁的【赢吨公司】正式将名下持有的土地，转让给泰益。还有刘马扁低价买来的建筑公司，也一并卖给了泰益。这笔交易，不仅让刘马扁大赚1.1个亿，美金，而且还让他获得了泰益旗下公司的股份。27岁，本科毕业才三年的刘马扁一战成名。赚了钱的他立马买了一辆黑色法拉利。就在他春风得意时，华尔街也注意到了他。 2008年金融危机席卷全球，由于美国经济疲软、股市冷清，高盛于是越发地看好亚洲。高盛亚洲的东南亚负责人——提姆·莱斯纳，已经在马来西亚布局十年。他通过高盛在马来西亚的另一名员工——吴崇华（Roger Ng），认识了刘马扁。莱斯纳胃口很大，而刘马扁正好也在寻找下一个机会。两人一拍即合。刘马扁觉得自己机关算尽、精心布局，才赚了一亿美元，而卡尔杜恩执掌百亿美金，享有巨大的权力和地位，轻轻松松就能日进斗金。 于是，刘马扁心想，不如自己也借着高盛的投行背景，在马来西亚搞一个主权基金。事情又回到了原点，钱从哪里来？还记不记得前面说过，穆巴达拉基金的资金是用石油做担保，在国际市场上募集来的。于是刘马扁准备照虎画猫，他把目光看向了马来西亚外海、拥有丰富油田与天然气的登嘉楼州。不过登嘉楼州是米占苏丹的地盘儿，（Alexandra Milchan），所以刘马扁必须先搞定他。 于是刘马扁故技重施，通过米占的姐姐，把(ADKMIC )公司的干股送给了米占。然后刘马扁向米占提议，可以仿照穆巴达拉基金的模式，成立主权基金。为了说服米占，刘马扁说自己认识高盛的银行家，能够通过高盛募集大笔的资金。之后刘马扁带着莱斯纳和吴崇华，到吉隆坡晋见米占苏丹。他们给这个项目取了个代号，叫做【冠冕计划】。 2009年二月，「登嘉楼投资机构」正式成立，简称TIA。（Terengganu Investment Authority）在明面上，刘马扁是TIA的投资顾问，但实际上，他才是背后的操盘手。刘马扁原计划，以登嘉楼州未来的石油收入作为抵押，发行十四亿美元的【伊斯兰债券】。但是就在定案之前，米占苏丹却突然反悔。他觉得管理团队还没有完全确定，不用着急发行债券。可是刘马扁怕煮熟的鸭子飞了，照样发行了债券。于是米占苏丹警告刘马扁赶紧收手，否则就撤销基金。同时，金融圈也开始盛传，刘马扁坑骗过砂拉越州的部长泰益，致使米占苏丹越发地不信任刘马扁。 就在刘马扁功亏一篑之际，事情却突然发生了转机。 原来就在米占苏丹发难的一个月前，副首相纳吉布赢得了大选，成为了马来西亚的新总理。纳吉布上任后宣称，要在数年内让马来西亚跻身发达国家，因此需要庞大的资金支持。于是刘马扁再次向纳吉布提议建立主权基金，而且他还提出了一个让纳吉布无比心动的建议：可以利用这个基金来募集政治献金。也就说，纳吉布可以用这笔基金来回馈选民和政治盟友，从而为纳吉布赢得支持。谁支持我，我就给谁投钱。为了进一步获取纳吉布的信任，刘马扁还为纳吉布引荐了沙特王子图尔基（Turki Bin Abdullah）。 最终，一家全新的马来西亚主权基金成立，取名为【一个马来西亚发展有限公司】，简称“一马公司”（1MDB）。（1 Malaysia Development Berhad） 一马公司成立之初唯一的资金来源，就是米占苏丹的TIA（登嘉楼投资机构）。TIA在刘马扁的操作下，发行了十四亿美元的伊斯兰债券，这笔钱全部转入联邦政府手中。也就是说，偿还这笔债券的责任，会落到一马公司的头上，而米占苏丹则不赚不亏被踢出局。 堂堂的苏丹，就这样成了刘马扁的打工人。完成收购后，刘马扁向纳吉布保证：未来，一马公司将会吸引中东资金投入，也会募集到国际游资。但是纳吉布并不知道，和图尔基王子的见面，也是刘马扁的精心设计。其实，刘马扁和图尔基王子才刚认识不久。在大多数人的印象里，阿拉伯国家的王子都特别的有钱。但实际上沙特当时的国王——阿卜杜拉有二十个孩子，图尔基王子只是其中并不受宠的一个。 他曾经是沙特的空军飞行员，退伍之后开始经商，但并没有赚到钱。图尔基有一家石油勘探公司——【沙乌地石油国际】（PetroSaudi International），简称PSI。他希望能利用自己王子的身份，到别的国家争取石油勘探权。但是PSI其实也是一家空壳公司，并没有做成过几笔生意。和欧泰巴一样，图尔基王子也是刘马扁最需要的人，有身份、有地位，但是骨子里特别需要钱。 而刘马扁就是擅长找到这些人，并利用他们的身份为自己背书。刘马扁让图尔基花五十万美金，在地中海上租下了一艘豪华游轮（Alfa Nero），邀请纳吉布一家登船度假。在游轮上，图尔基与纳吉布当即拟定了一份合作备忘录。几天之后，图尔基用沙特的官方信纸，写了一封信给纳吉布，正式提出双方共同的投资方案：PSI将以名下资产——在土库曼与阿根廷的油田开发权，总值二十五亿美元，与一马公司共同投资。而一马公司，则投入十亿美元。 但实际上，PSI公司所谓的土库曼油田位于里海，和阿塞拜疆存在纠纷，根本不值25亿美元。十亿美元的大单谈成后，刘马扁开始为一马公司招兵买马。总理纳吉布出任一马公司的顾问团主席，拥有董事会成员的任命权和公司的决策权。然后纳吉布对刘马扁充分授权，让刘马扁安排了许多他自己的人马。虽然整个一马公司的组织名单里并没有刘马扁，但是大家都知道，刘马扁才是这家公司的实际决策者。接着，为了通过和PSI的合作开发案，刘马扁和PSI公司的人展开了行动。 他们先去摩根大通在瑞士的一家小分行，开了一个账户，作为PSI与一马公司的合作户头。然后他们又找到了前雷曼兄弟的分析师，曾任职美国能源部的爱德华．莫尔斯（Edward Morse）。仅用两天时间，莫尔斯就给出了一份分析报告。 结论是，PSI公司的资产估值高达36亿美元！ 当然，这份2天就出炉的报告，让莫尔斯自己拿到十万美元佣金。不只是莫尔斯，刘马扁找来的所有专业人士全都乐于配合。没办法，有钱就是可以为所欲为。最后，董事会提案通过，一马公司将投资十亿美元与PSI合作开发油田。一般来说，规模如此庞大的投资计划，少则数个月，多则要一年以上才能完成。但是，从图尔基王子在八月下旬写信给纳吉布算起，刘马扁只花了一个月，就完成了这个数十亿美元的合资案。 到这里，刘马扁已经成为了东南亚资本圈里的风云人物，但是刘马扁却还不满足。 2009年9月，德意志银行马来西亚分行的主管，给马来西亚央行打了一个电话。德意志银行发现，一马公司的汇款十分可疑。因为一马公司的十亿美元，应当直接汇入与PSI在瑞士共同开设的户头。但是，现在有一笔7亿美元的巨款，被要求汇入顾资银行苏黎世分行，而且只提供账号，没有户名。按照一马公司的说法，这个户头也属于PSI。这笔7亿的汇款，是为了偿还先前欠PSI的钱。很快，马来西亚央行回复，可以放行，只要钱最后是进到PSI的相关户口就没有问题。于是，在当天下午，一马公司的十亿美金被汇出。三亿美金汇到了摩根大通的瑞士分行，另一笔七亿美元则汇到了顾资银行的神秘账户。 顾资银行（Coutts Bank），是一家专门服务最顶级、最富有客户的私人银行。 7亿美金汇入的神秘账户属于一家登记在塞舌尔的公司——Good Star。Good Star的唯一股东，就是刘马扁。实际上根本没有什么7亿美元的欠款，Good Star公司也是一个月前才成立的，这一切都是刘马扁用来套现的诡计。7亿美元到手后，刘马扁立马开始分赃。他先以“委托私募基金投资”的名义，分两笔打给了参与合谋的PSI高管，共计一亿五千三百万，其中图尔基王子分得七千七百万美元。然后，刘马扁当然要回报总理纳吉布。他给纳吉布的老婆罗斯玛买了数千万美金的珠宝，还在伦敦、洛杉矶、纽约购买豪宅给纳吉布的家人享用。其中一座（Park Laurel）就在纽约中央公园旁边，面积高达七千七百平米。这些豪宅统统记在纳吉布的继子，刘马扁的好兄弟——里查的名下。而纳吉布也从来都不过问刘马扁的资金来源，一旦有人问起，纳吉布就撇得一干二净。 显然，刘马扁已经成了纳吉布的白手套。给同伙分完钱后，刘马扁手上还剩下大把的现金。但是他并不满足，他要把钱带到美国，供他挥霍、结交名流、然后继续新的冒险。 当时，已经有大批的外国官员，用贪污来的钱在美国购置资产，引起了美国监管部门的注意。为了安全起见，刘马扁先开设了一个ＩＯＬＴＡ（音译：艾欧塔）信托账户。（Interest On Lawyer Trust Accounts）这种账户的好处是，律师不会像银行一样对客户进行尽职调查，还会依法对客户的汇款细节进行保密。 ＩＯＬＴＡ账户，是美国律师事务所大约从三十年前开始，专门为客户开设的一种账户，通过这个账户替客户存放短期资金。 因此外界只能看到律师事务所的名称，查不到资金的真正来源。这简直就是为刘马扁这样的，专门准备的洗钱工具!刘马扁为了开ＩＯＬＴＡ账户，找上了谢尔曼·思特灵律师事务所（Shearman &amp; Sterling）。这家律师事务所位于纽约曼哈顿，是全美最顶级的律师事务所。但他们平常的业务都是大型企业并购，根本就看不上刘马扁这种小角色。于是刘马扁又故技重施，声称自己和马来西亚以及中东的主权基金都有关系，准备在美国进行投资。果然，谢尔曼律师事务所的态度立马转变，替他开设了ＩＯＬＴＡ账户。 之后的一年里，刘马扁累计将三亿六千九百万美元，转入自己的ＩＯＬＴＡ账户。并且在这段时间里，刘马扁和他的哥们儿尽情地挥霍，喝酒、赌博、买私人飞机、租豪华游艇、招待好莱坞巨星。包括让小甜甜布兰妮大跳生日艳舞。 刘马扁挥金如土，为的就是吸引最有钱、最有名的人，好进一步扩大自己的人脉。刘马扁有名媛情结，从大学时代起，就对一位名媛深深着迷。有钱之后，刘马扁在第一时间就与她结交。 这位名媛就是帕里斯·希尔顿，希尔顿酒店集团的继承人，真正的名媛。 老司机们都知道她，懂的都懂，不多介绍。 刘马扁得知，希尔顿的好朋友——乔伊·麦克法兰，曾经拍过几部低成本电影，正准备成立一家电影制作公司。于是，刘马扁就和他的好兄弟提供资金，成立了红岩电影（Red Granite Pictures），正式进军好莱坞。这家公司对外宣称创始人是里查·阿兹和乔伊·麦克法兰，当然刘马扁又一次隐藏在幕后操盘。他们的第一部电影，就是著名的R级片《华尔街之狼》，由大导演马丁·斯科塞斯执导，小李子主演，这部电影的预算高达1亿美元！ 小李子过生日时，刘马扁送了他毕加索的画和马龙·白兰度的奥斯卡奖杯。 除了搞电影，刘马扁还准备做音乐。刘马扁成立了一家【红春】音乐制作公司（Red Spring），打算找最好的音乐人替萧亚轩制作专辑，让萧亚轩红到美国。他花了三百万美元，请著名音乐人法瑞尔·威廉姆斯为萧亚轩写了三首曲子，并且和萧亚轩合拍ＭＶ。 另外，他还花四百万美元请艾莉西亚·凯斯（Alicia Keys）和她的老公史监制这张专辑，协助萧亚轩打开美国市场。不过，尽管刘马扁准备了一千两百万美元的预算，萧亚轩最后并没有做完这张专辑。 刘马扁十分享受这种置身权贵，无所不能的感觉，但这需要源源不断的金钱来维系。他和同伙在两年间，从一马公司陆续捞走了二十亿美元。但大部分钱都被瓜分，然后拿去挥霍。 等到《华尔街之狼》快要开机，刘的钱已经不够烧了，他必须想办法再弄一笔钱。雪上加霜的是，有钱之后的刘马扁过于高调，引起了图尔基王子的不满。刘马扁和PSI公司的关系也闹僵了，于是他不得不物色新的同伙。就在这时，刘马扁突然看到一则新闻：有一个集团要卖酒店，买家竞争激烈，其中一家引入了中东基金——阿尔巴投资。 这个阿尔巴投资的背后，是阿布达比的另一家主权基金——国际石油公司（International Petroleum Investment Company），简称IPIC。 IPIC的资产高达七百亿美元，总经理卡登在金融圈里以爱吃回扣出名。刘马扁得到消息之后，立马故意参与到饭店的竞购中，成功通过关系结交到了卡登。卡登虽然不像欧泰巴和图尔基王子一样缺钱，但是他却更加贪婪。而刘马扁这次要联合卡登布一个更大的局，从一马公司榨出更多的钱。 2012年3月，刘马扁和自己的“老”搭档，高盛的莱斯纳、吴崇华，飞往阿布扎比，见到了地表最有钱的人之一：曼苏尔亲王（Sheikh Mansour Bin Zayed）。他是英超曼城足球队的老板，也是IPIC的董事长，身价高达四百亿美元，跟一个百度的市值差不多。许多华尔街的大银行都隔三差五地拜访IPIC，但从来没有人能见到曼苏尔亲王。多亏了刘马扁的新朋友卡登，从中牵线，他们才能艰难地见到曼苏尔亲王。 接下来，刘马扁三人向曼苏尔亲王讲述了他们的计划。高盛打算替一马公司发行三十五亿美元的公司债，并拿笔钱来投资世界各地的的火力发电厂。买下这些发电厂之后，一马公司将为这些发电厂另外成立一家公司，并且在马来西亚上市。买壳，装修，卖壳，上市割韭菜。这样一通操作下来，预估能够赚到五十亿美元！ 而刘马扁一行人来这的目的，就是希望ＩＰＩＣ能为这批公司债提供担保，好让其他投资者放心投资。如果ＩＰＩＣ同意，将来就能以非常优惠的价格认购即将上市的公司股票。曼苏尔亲王十分信任卡登，虽然大型投资案都是由他亲自拍板，但一般只要过了卡登这一关就行，就不需要再提交董事会讨论。在刘马扁等人晋见以前，卡登已经提前和曼苏尔亲王通过气了，因此曼苏尔亲王同意为一马公司提供担保。 不过这个计划依然是刘马扁精心设计的骗局。醉翁之意不在酒，刘马扁和卡登等人的真正目的，才不是投资什么火力发电厂。他们只是想从一马公司捞钱。 根据刘马扁的计划，一马公司将发行17.5亿美元的十年期债券，而高盛将从中收取高达1.9亿美元的承销费。这个数字高的就只剩两个字——离谱！按照业界常见的行情，应该是一百万美元左右。而这一笔案子，高盛的收益是正常情况的一百九十倍！之所以会收取这么高的承销费，主要是因为，刘马扁希望高盛先以自有资金买下全部债券，然后高盛再去另外找买主。换言之，一马公司将可以很快拿到钱，而高盛将承担所有的风险。之所以这么做，原因也很简单，刘马扁能够最快速地搞到钱。 这项离谱的计划，引起了高盛内部的激烈讨论。最后在莱斯纳的极力游说下，得到了高盛总裁盖瑞·康恩（Gary Cohn）的力挺。高盛之所以会最终通过这个案子，其实有一个心照不宣的理由。那就是，这笔交易会大大拉高盛亚洲部那一年的业绩和奖金。所有人都是精明鬼，只有马来西亚的股民是替死鬼。 2012年五月二十一日，高盛将17.5亿美元汇入一马公司能源部的账户里。隔天，一笔五亿六千万美元的款项，被汇入了一家注册在英属维京群岛的【阿尔巴投资】公司。一马公司声称，这笔巨款是付给IPIC作为提供担保的费用。 是不是感觉，这味道有点熟悉。没错，刘马扁又一次故技重施! 这个【阿尔巴投资】（Aabar Investment Ltd.）公司跟IPIC根本没有关系，它其实是刘马扁在两个月前成立的。刘马扁故意把名字取得跟真正的阿尔巴投资公司「Aabar Investments PJS」差不多，并且还把卡登和曼苏尔亲王的名字列在股东名单中。 这就是刘马扁的惯用伎俩，谎称自己获得了中东主权基金的投资，从而蒙骗一马公司共同投资。然后成立名字相似的空壳公司，最后把一马公司的资金转走。只不过这一次和卡登联手，刘马扁玩的规模更大。 为了确保不引起外界注意，他们将这笔巨款又转入了瑞士的「安勤私人银行」（Falcon Private Bank）。而这家银行，就是卡登自己的私人银行！是卡登在金融危机期间，向美国AIG集团买下的。 五个月后，高盛梅开二度，再次替一马公司发行17.5亿美元的公司债，这一次高盛收取的佣金为1.14亿美元。刘马扁还是一模一样，把资金转走。这两笔大生意，让莱斯纳在2012年赚了一千万美元，成为高盛收入最高的员工之一。不过这只是小钱，接下来两年，刘马扁和同伙总共瓜分了十四亿美元，其中有超过两亿美元流入莱斯纳和他亲戚的账户，而卡登也分到了四亿。 不过，纸终究保不住火。刘马扁满世界的高调挥霍，《华尔街之狼》的无预算上限拍摄，早就传回了马来西亚，传遍了大街小巷。其实早在高盛第一次替一马公司发行债券时，吉隆坡就爆发了十万人的反贪大游行。从高空鸟瞰，整个市中心都被穿着黄色Ｔ恤的群众淹没。示威群众高举着纳吉布老婆罗斯玛的画像，大声质问买珠宝的钱从哪里来的？只不过当时，可怜的马来人，还以为一马公司在投资“绿色”能源，投资高科技产业。他们不知道，刘马扁早用五鬼搬运之法，将一马公司和马来人的未来偷偷搬空。 一马弊案最后如何败露？调查此事的检察官为什么会被埋进水里？刘马扁现在又躲在何处？","categories":[{"name":"吃瓜","slug":"吃瓜","permalink":"https://blog.jddfe.com/categories/%E5%90%83%E7%93%9C/"}],"tags":[{"name":"一马币案","slug":"一马币案","permalink":"https://blog.jddfe.com/tags/%E4%B8%80%E9%A9%AC%E5%B8%81%E6%A1%88/"}]},{"title":"亚洲巨骗案之“一马币案”（一）","slug":"亚洲巨骗案之“一马币案”（一）","date":"2020-11-20T21:13:38.000Z","updated":"2020-11-26T15:14:59.681Z","comments":true,"path":"posts/21156/","link":"","permalink":"https://blog.jddfe.com/posts/21156/","excerpt":"","text":"本文整理自B站-阿牛读财 今天这个瓜，内容实在过于丰富，涉及颇多名词和名人，所以还吃瓜的小伙伴们搬好小板凳，换个舒服的姿势，慢慢品尝。 这个是一桩震惊世界的金融大案 —— “一马币案”，不仅让资本界的一些人慌了阵脚，连一向虚荣繁华的好莱坞电影圈，都纷纷退出了群聊，不想和它沾上关系。从马来西亚前总理纳吉布，排到了奥斯卡奖的得主小李子，以及名媛帕利斯·希尔顿和澳洲名模米兰达·可儿等一众名利场女性。 一马币案钱权交易玩弄人心，瞒天过海金蝉脱壳，这是一个比电影还要精彩的真实故事。 案中的男主是一名马来西亚华裔金融家——刘特佐Jho Low，祖籍广东揭阳的马来西亚华人，是个不折不扣的富二代。 故事开始，从刘上学、发展人脉到发家史，了解整个案件。为了方便，以下将主角称为刘马扁。 1998年，17岁的刘马扁被父亲送到哈罗公学读高中。哈罗公学是腐国最好的私立学校之一，英国首相丘吉尔诗人拜伦前印度总理尼赫鲁签。约旦国王侯赛因一事都毕业于哈罗公学。 刘马扁在哈罗的成绩平淡无奇，但接受过刘马扁的人都对他的交际能力刮目相看。刘马扁一开学就结识了文莱和科威特的皇室成员，还通过社区联谊和一个大学生成为了好朋友。这个大学生叫做里查·阿兹，是未来刘马扁打进马来西亚政要圈的金钥匙。因为里查·阿兹的爸爸是马来西亚的教育部长（这是一个从拼爹到坑爹的故事）。 之前我们就介绍过，刘马扁在马来西亚还算是个富二代，但是来到了哈罗公学之后，他才发现人比人气死人自己几千万的家族财富还不够别人的零头，自己综合实力不行，那就只能跪舔，在努力融入上流圈子的过程中，刘马扁开始尝到了权势的甜豆。有一次他不知道从哪弄来了文莱大使馆的信纸，伪造出一封皇室预定座位的信件，交给伦敦一家顶级夜总会。这家夜总会信以为真。于是当晚刘马扁成功带着几个同学混入会所和店里的嫩模狂欢了一夜。自此以后，刘马扁就学会借助别人的身份地位来为自己达成目的，也就是狗仗人势。从哈罗毕业后，刘马扁被送到美国常春藤名校。宾夕法尼亚大学就读于闻名世界的沃顿商学院，沃顿商学院和哈罗公学一样，大多数学生都是富二代，并且培养了一批金融巨鳄和国际骗徒。比如巴菲特和川普。 尝过权势甜头的刘马扁，进入沃顿的主要精力也不在学习上，而是开始变本加厉的培养人脉。据说当时川普的女儿伊万卡也在沃顿商学院读书，刘马扁就写信邀请伊万卡一起去川普的赌场玩，不过被伊朗卡拒绝，因为她说她才不想参合他爸爸的鸟赌场。为了打响自己的名头，刘马扁经常给学院的院刊沃顿期刊投稿，但其实这些文章都是刘马扁超来的。他一字不漏的抄袭华尔街的分析报告竟然也没有人发现，毕竟那个时候还没有普及查重系统。就这样，并没有多少真才实学的刘马扁因为在院刊上发表了许多文章，甚至在圈内被视为投资高手。 2003年，刘马扁申请了GAP YEAR，他的同学一般都利用GAP YEAR去做做慈善，四处游玩或者勤工俭学体验生活。只有刘马扁直接拜托几位阿拉伯土豪同学为他安排了一趟中东旅行。他跟着这些土豪专门拜访中东最有钱的家族势力，最庞大的企业目的只有一个。为了结交当地的巨贾政要，苦心钻研的成果是刘马扁认识了一个大人物，阿联酋的先进外交官欧泰巴。欧泰巴的父亲是阿联酋的第一任石油部长，也是阿联酋的开国元勋。曾经六次担任OPEC主席。不过，欧泰巴虽然出身豪门能力出众，但是他本人的地位比较尴尬，因为欧泰巴的父亲有四个老婆生了一打孩子给他的钱并不多。 作为一个外交官赚不到太多钱，欧泰巴还要经常打顶和王室的关系，因此开销巨大并不太懂商业的欧泰巴。当时满脑子想的都是怎么利用自己的人脉，私下里赚些外快。可以说欧泰巴刚好就是刘马扁最需要的那种人，有钱有势，有影响力，有人脉，但是需要赚更多的钱。刘马扁看穿了欧泰巴想要赚钱的心态，于是跟他大谈东南亚，尤其是马来西亚有多少投资机会，但其实当时的刘马扁完全没有做过生意，在马来西亚的商机也没有半点门路。在刘马扁的忽悠下，欧泰巴又把刘马扁引荐给了一位真正的大佬卡尔杜恩。和欧泰巴相比卡尔杜恩更年轻，更有权势也更野心勃勃，因为他管理着阿布扎比的一只主权基金——穆巴达拉。 什么是主权基金主权基金？ 可以简单粗暴的理解为国库之主权。国家政府所设立的用来长期投资的金融资产或者基金，一般由专门的政府投资机构管理。主权基金的钱一般来源于国家盈余，外汇储备，自然资源出口，英语等等，可以说是真正意义上的“国家队”。 题外话： 阿联酋最富的酋长国不是迪拜，而是阿布扎比]，阿联酋九成的石油产量都是出自阿布扎比，阿布扎比的国家队就是穆巴达拉和其他中东国家的主权基金不同，穆巴达拉不是拿政府卖石油赚的钱去投资，而是以石油做担保，从国际金融市场上募资，然后回头投资自己的国家。在阿布达比投资，房地产，半导体等产业协助阿布扎比进行经济转型。阿布扎比现在也是一带一路上重要的节点。 说回刘马扁。 他看着不到三十岁的卡尔杜恩掌握着富可敌国的国家资源。当然羡慕嫉妒恨。在阿布扎比的所见所闻，让刘马扁明白了另一个道理，想成功狗仗人势伏低做小根本不够，还需要步子迈得更大，路子的更野。从中东返回学校之后，刘马扁到了人生的十字路口。 一般来说，沃顿的本科生到了大四就要开始找工作了，要么去华尔街加入高盛、麦肯锡这样的大型投行或者咨询公司，要么就回家继承家产。 但是开了天眼的刘马扁明白，打工人员挣不了大钱，只有像卡尔多那样掌握国家资源才能一夜暴富。 于是，刘马扁在英属维京群岛注册了自己的第一家公司。赢顿集团（Wynton group），年纪轻轻的他准备忽悠中东的金主，通过赢顿集团来投资马来西亚人。 虽然刘马扁只是做了一个空壳公司，但是他明白在哈罗公学和沃顿积累的人脉就是他的本钱。 2005年，刘马扁从沃顿毕业返回大马之后的第一件事就是在吉隆坡地标建筑双子星大楼为自己的赢顿集团租下了整层办公室。当然租办公室的钱是刘马扁找银行贷的，还记得有一个部长爸爸的里查·阿兹吗？通过里查·阿兹的牵线，刘马扁成功认识了纳吉布的弟弟和老婆，搭上了纳吉布家族。 纳吉布家族是马来西亚的政治世家，纳吉布的父亲和姨丈都当过总理。 不过对于已经当上副总理的纳吉布来说，刘马扁这种小年轻根本入不了他的法眼。纳吉布家族也看不起刘马扁。转机出现在2007年，为了争取总理之位，纳吉布需要为第二年的大选准备政绩。而这时，马来西亚的主权基金国库控股打算找人合伙一起来开发马来西亚南部临近新加坡的一块土地，他们希望把这块地发展成足以抗衡新加坡的金融中心。这个计划叫做伊斯干达经济特区（相当于马来西亚的深圳特区）。 刘马扁预感自己的机会来了，如果他能够帮大马主权基金国库控股找到合伙人，就能从中赚到一大笔佣金。 刘马扁赶紧写了一份电子邮件给欧泰巴，向他详细介绍了伊斯干达经济特区计划，让欧泰巴去联系卡尔杜恩，引入穆巴达拉基金。之后，他又赶紧安排国库控股的主管飞到阿布扎比与欧泰巴等人见面。 在刘马扁贺欧泰巴的引荐之下，穆巴达拉欣欣决定投资五亿美金参与开发。依斯干达经济特区这次成功的撮合对刘马扁来说是一箭三雕。 第一，向纳吉布家族证明了自己有能力从中东找来资金。 第二，向欧泰巴和卡尔杜恩证明了马来西亚的确有投资机会。 第三，刘能够从中获得一大笔佣金。 但是刘马扁没有想到的是，国库控股由专业团队管理，直接拒绝了他的中介佣金。刘马扁也找不到任何能捞一笔的机会。至此，刘马扁学到了第三课。光会当舔狗，人脉NB也不行，自己攒的局还得自己做主才行。 下一篇：亚洲巨骗案之“一马币案”（二）","categories":[{"name":"吃瓜","slug":"吃瓜","permalink":"https://blog.jddfe.com/categories/%E5%90%83%E7%93%9C/"}],"tags":[{"name":"一马币案","slug":"一马币案","permalink":"https://blog.jddfe.com/tags/%E4%B8%80%E9%A9%AC%E5%B8%81%E6%A1%88/"}]},{"title":"老人言","slug":"老人言","date":"2020-11-19T20:29:48.000Z","updated":"2020-11-23T04:20:27.800Z","comments":true,"path":"posts/7970/","link":"","permalink":"https://blog.jddfe.com/posts/7970/","excerpt":"","text":"荒田无人耕，一耕有人争； 肚里无食无人知，身上无衣无人欺； 合伙租船船会漏，两家喂驴驴会瘦 更新于 2020-11-20 知者不言，言者不知。 智者语迟，愚者话多。 人不贵在牙尖嘴硬，而贵在耳聪目明。 摘自道德经，更新于 2020-11-21","categories":[{"name":"每日最佳","slug":"每日最佳","permalink":"https://blog.jddfe.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%80%E4%BD%B3/"}],"tags":[{"name":"道德经","slug":"道德经","permalink":"https://blog.jddfe.com/tags/%E9%81%93%E5%BE%B7%E7%BB%8F/"}]},{"title":"假如互联网大佬们去摆摊","slug":"假如互联网大佬们去摆摊","date":"2020-11-17T20:50:14.000Z","updated":"2020-11-18T04:56:46.137Z","comments":true,"path":"posts/14122/","link":"","permalink":"https://blog.jddfe.com/posts/14122/","excerpt":"","text":"假如互联网大佬们去摆摊… 时光如果倒流，英雄莫问出处 转自微博-我是K董","categories":[{"name":"每日最佳","slug":"每日最佳","permalink":"https://blog.jddfe.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%80%E4%BD%B3/"}],"tags":[{"name":"每日最佳","slug":"每日最佳","permalink":"https://blog.jddfe.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%80%E4%BD%B3/"},{"name":"全民摆摊","slug":"全民摆摊","permalink":"https://blog.jddfe.com/tags/%E5%85%A8%E6%B0%91%E6%91%86%E6%91%8A/"}]},{"title":"基金投资新手入门科普宝典","slug":"基金投资新手入门科普宝典","date":"2020-11-14T15:06:10.000Z","updated":"2020-11-17T12:54:33.343Z","comments":true,"path":"posts/56721/","link":"","permalink":"https://blog.jddfe.com/posts/56721/","excerpt":"","text":"网上关于基金投资教学的文章有很多，但都太过于专业，太过于繁琐，今天就用简单直白的内容重新认识基金。 直接告诉你 怎么买、买多少、怎么卖 开始前先了解下基金的分类 基金的分类注：以下提到的收益率为有专业操作经验的普通投资者的近一年预估收益率。 货币型基金：是以银行存款，短期债券保本型产品为主的类型，一般收益在 2.5%-3.5% 低风险，比如我们常用的余额宝和天天基金的活期宝，适合1年内的资金打理，随取随用。 债券型基金：成分80%以上是国债和企业债，收益在6%-8%，中风险，纯债基金100%投资于债券，不碰股票。特点是波动小，收益比较稳定。适合1-2年资金的打理。 混合型基金：成分现金、债券、股票都有，进可攻退可守，非常灵活，收益在10%-13%中高风险 股票型基金：成分80%以上是股票，收益在12%-30%+，高风险。 指数型基金（被动型基金）：不主动寻求取得超越市场的表现，而是试图复制指数的表现。一般选取特定的指数作为跟踪的对象，因此通常又被称为“指数型基金”。相当于在股票市场上，把每种股票都买一点，最后追求一个市场平均收益率的基金。 ＥＴＦ：交易型开放指数基金，通常又称为“交易所交交易基金”，是一种在交易所上市交易的、基金份额可变的一种开放式基金。 ＬＯＦ：上市开放式基金，是一种既可以在场外市场进行基金份额申购赎回，又可以在交易所（场内市场）进行基金份额交易和基金反而二申购或赎回的开放式基金。是我国对证券投资基金的一种本土化创新。 国内的一些指数 上证50指数：就是把上交所规模最大、流动性最好的50家公司的股票组合在一起。 沪深300指数：就是把上交所和深交所前300只规模最大、流动最好的300家公司的股票组合在一起。 中证500指数：把沪深300指数的前300家大公司排除，剩下的大公司中再选前500只规模最大、流动最好的500家公司的股票统计起来的股票组合在一起。 上证红利指数：从上交所的股票中，挑选现金分红最高的 50 家公司股票组合在一起。 时间越长，分红越高。 创业板指数：限制了成分股的数量，只从创业板上市公司中，挑选出规模最大、流动性最好的100只股票。 接下来直接进入主题，这里就不介绍平台和开户相关前提了 一、怎么买？基金投资的第一步就是选到优秀并且适合自己的基金，上面介绍了基金的分类了，那接下来直接说说如何选基金。 长期投资建议：混合型基金和股票型基金，其次债券型基金 接下来，解释一下原因： （1）货币型基金首先排除掉余额宝等货币型基金，因为收益率过低，甚至跑不赢通货膨胀，不予考虑。 （2）债券型基金债券型基金在一年期内，取得正收益率的概率大于股票型基金，但是其长期和平均收益率要远低于股票型基金。 如果选择长期投资自然是股票型基金更适合。 （3）主动型与被动型基金取舍了股票型和债券型，我们接下来看看股票型基金、混合型基金（二者统称为主动型基金）与指数基金（被动型基金）的对比。 巴菲特说过：“一个什么都不懂的投资者，通过定投指数型基金，就可以战胜大多数的专业投资者。” 这句话确实是金玉良言，但是那是在美国的市场上。 美国市场处于机构博弈的状态，就是基金和基金打架，能从中脱颖而出，战胜大盘平均成绩的基金自然是不多； 但是在中国市场上，是机构和散户博弈，目前市场上近7成的交易量由散户提供，那些基金工作机构相对于散户来说，处于信息和技术层面的绝对优势， 我们再看看数据统计： 被许多人吹捧的指数型基金的年化收益率甚至低于债券基金，并且风险（波动率）还要更大。 如果在中国你选择了指数基金，那就是实实在在的损失掉了一部分收益。 好了，现在我们知道自己要买的是股票型基金和混合型基金了，那么接下来我们该怎么细选呢？ 毕竟这两种基金可有将近4000多只，我们怎么样才能选到那些能给我们带来长期稳定收益的基金呢？ 既然说了是最直白的教程，那在这里就应该直接给大家一份名单，直截了当的告诉你，哪些基金是“陈年好基” 我在这篇回答里，为你直接列举了中国最优秀的基金经理和他们的代表基金（全部都是经过5年以上牛熊市考验的老牌基金，长期平均年化收益率15%以上），并且附有自主选择基金的方法： 链接：国内优秀基金经理及其代表基金推荐 （4）购买方式好了，选择好基金后，我们就要开始购买了，那哪种购买方式最适合我们呢？ 在讲这个问题前，我们要简单的说一下定投的原理： 为了你更好地理解，请你陪我算一道很简单的计算题。 假如我们去菜市场买西红柿，每次买3000元，买三次。第一次买的价格是1.5元1斤，第二次是1元1斤，第三次是0.5元一斤 问：买完3次后，你手中的西红柿成本是几元1斤？ 你可能就要说1元对吧，那让我们来仔细算算这笔账，一共买了3次，花了9000元，第一次买了2000斤，第二次买了3000斤，第三次买了6000斤 细心的朋友到这里就发现了，实际上我们花了9000元，却买了11000斤西红柿。 当西红柿回到1元1斤时，总的来说虽然西红柿的价格没有上涨，但我们还是可以净赚2000元， 这就是定投的魔力。 定投好处就在于①可以在低位时吸收更多筹码②克服人追涨杀跌的天性，规定买入时间。 注意事项： 1、基金的选择和蔬菜一样也讲究荤素搭配、营养全面，我们不能只吃一样，建议你持有4-8只，就可以避免因为一个基金出现问题，而影响我们整体的收益率。 2、不要买支付宝等软件主页面上推荐的基金，被推荐的基金都是在近期涨幅很大，看起来很诱人的基金，但是近期涨幅过大并不是好事，说明两个问题： ①基金经理风格偏激进 ②该基金最近处于高位，后期很大可能跌落。所以一般购买这类基金，有很大的概率是当了接盘侠。 二、买多少那么我们究竟应该买入多少呢？为了充分考虑到所有人，这里我分情况来说，请大家直接看适合自己的那部分即可。 1、学生 从现在开始，给自己定一个长期目标，明确标出每个月需要攒下来的钱。然后每月通过兼职或者从生活费中节省下来该金额。 很多人会说学生不可以理财，钱少不可以理财，现在理财看似只能赚个几十，并且还有一定风险。 但其实不然，如果你能从现在开始积累理财经验，那这对你的后半生会是一个取之不尽的财富。 毕竟劳动无法致富，普通人财务自由的最佳方式，就是早点开始理财。 2、上班族 将自己收入的10%攒下来，定投到你的基金组合当中， 如果你想拥有被动收入，并在未来的某一天脱离这种早出晚归的上班生活的话，建议你从现在开始播种理财。 同样的给自己列一个计划表，有了计划，我们才能一步一步的去实践。 3、有一定/目标压力的人群 明确该目标的预算，然后根据这个数额，来决定每月定投金额以及定投时间。 定投频率：两周一次最佳，每日一投会因为买入时间间隔过短，所以起不到摊低成本的作用，经数据测算，两周一投是收益率最高的方式。 注意事项： 1、短期内要用到的钱不能用于投资。 2、定投贵在坚持，每一次定投都是你在向财务自由迈步。 三、怎么卖 俗话说：“会买的是徒弟，会卖的才是师傅。” 如何把握卖出时机的确是基金投资中，最难掌握的一步，但是不用害怕，这个时候我们已经有了收益，需要做的就是落袋为安，把那个数字转换成实实在在的钱罢了。 下面有几种方法请大家查收，从简单到困难。 （1）目标收益率法在我们入市之前，给自己定下一个目标收益率（15%或者20%）， 当定投的持有收益率达到目标收益率时，卖出20%-30%，然后继续投资。简单粗暴，适合小白操作。 （2）估值表法则支付宝上对于基金估值的判断会有一个红绿灯来表示： （图中基金不作投资参考） 除了指数红绿灯，在支付宝上还可以找到专业机构看法参考： （图中基金不做投资参考） 参考基金估值和机构的看法，来决定是否止盈 但是止盈并不是全部卖出，假设后面有一个大牛市，那么全部卖出就吃不到后面的收益，建议每次止盈**酌情卖出20%、30%**等 （3）市场形势止盈法这个是老基民的方法了，要求个人理财者把握好大的方向： 知道目前市场是牛是熊、市场上的基金是便宜还是贵。如果实在不知道的呢，我建议上证指数2900点以下多买，3300点附近部分卖出。 更进一阶的可以不只分析大盘，也可以分析自己所投资的行业，分别从政策、技术、资金等方面判断市场所处位置，上涨的可能性大还是跌的可能性大。 如果现在不会这种方法，不用担心，在市场上度过一年之后，你就会有自己的看法。 本文整理自知乎-吴机长的回答","categories":[{"name":"懂理财","slug":"懂理财","permalink":"https://blog.jddfe.com/categories/%E6%87%82%E7%90%86%E8%B4%A2/"}],"tags":[{"name":"基金","slug":"基金","permalink":"https://blog.jddfe.com/tags/%E5%9F%BA%E9%87%91/"},{"name":"定投","slug":"定投","permalink":"https://blog.jddfe.com/tags/%E5%AE%9A%E6%8A%95/"},{"name":"投资","slug":"投资","permalink":"https://blog.jddfe.com/tags/%E6%8A%95%E8%B5%84/"}]},{"title":"防抖、节流及应用场景","slug":"防抖、节流及应用场景","date":"2020-11-11T14:27:28.000Z","updated":"2020-11-17T12:54:33.351Z","comments":true,"path":"posts/49523/","link":"","permalink":"https://blog.jddfe.com/posts/49523/","excerpt":"","text":"防抖(debounce) 事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 防抖，顾名思义，防止抖动，什么叫抖动，事件被高频触发，想象你在用鼠标点击按钮操纵一个小人让他有跳跃的动作，你狂点鼠标，小人狂跳，这就是最直观的抖动现象。 直接上代码 12345678910111213141516/** fn [function] 需要防抖的函数* delay [number] 毫秒，防抖期限值*/function debounce(fn, delay) &#123; let timer = null // 借助闭包 return function() &#123; // 当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时 if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(()=&gt;&#123; fn.call(this, arguments); &#125;, delay) &#125;&#125; 节流(throttle) 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 简单的可以理解为指定时间间隔只执行一次任务。 直接看代码： 12345678910111213function throttle(fn,delay)&#123; let valid = true return function() &#123; if(valid)&#123; valid = false &#125; // 工作时间，执行函数并且在间隔期内把状态位设为无效 setTimeout(() =&gt; &#123; fn.call(this, arguments); valid = true; &#125;, delay) &#125;&#125; 注：节流函数并不止上面这种实现方案,例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样。 总结那么你可能会困惑，防抖也有时间间隔，节流还是时间间隔，它俩啥区别？ 上结论： 防抖：超过指定时间间隔，不论点击多少次都只执行一次。 节流：指定时间间隔只执行一次，执行频率不受操作频率影响，但会把所有的都执行完。 应用场景防抖： search搜索联想，用户在不断输入值时，用防抖来节约请求资源。window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 节流： 鼠标不断点击触发，mousedown(单位时间内只触发一次)监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"防抖","slug":"防抖","permalink":"https://blog.jddfe.com/tags/%E9%98%B2%E6%8A%96/"},{"name":"节流","slug":"节流","permalink":"https://blog.jddfe.com/tags/%E8%8A%82%E6%B5%81/"}]},{"title":"Hexo 双线部署到 Coding 和 GitHub 并实现全站 HTTPS","slug":"Hexo-双线部署到-Coding-和-GitHub-并实现全站-HTTPS","date":"2020-11-09T14:56:25.000Z","updated":"2020-11-17T13:07:00.693Z","comments":true,"path":"posts/39593/","link":"","permalink":"https://blog.jddfe.com/posts/39593/","excerpt":"","text":"GitHub pages是GitHub提供的一项静态站点托管网页，这里就不过多介绍，由于国内网络原因，访问延迟100-300ms，当然这还是在网络较好的时候，在网络差的情况下会很难加载完全网页，令人头疼，于是，针对这个问题做个大致的解决方案，记录分享下。 本文主要从双线部署和实现https自定义域名两个点做分享，并记录一下其中遇到的坑。 所谓双线部署就是将博客同时发布到 Coding 和 Github，博客发布到 Coding 来提升国内访问速度，并可以提交百度收录，GitHub 禁止了百度的爬取，当然可以通过其他方案来解决收录问题，这里就不过多介绍了，感兴趣的可以网上找一下。 实现双线部署首先，你要将 Hexo 成功部署到了 GitHub Pages，如果还没有，可以参考之前的博文专门的教程Hexo5分钟搞定你的个人博客 在成功部署到了 GitHub 后，那么就简单了，关键点就在于发布配置多配置个 Coding 代码库。 上代码： 1234567# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: git repository: coding: https:&#x2F;&#x2F;e.coding.net&#x2F;团队名&#x2F;项目名&#x2F;代码库.git github: https:&#x2F;&#x2F;github.com&#x2F;昵称&#x2F;代码库.git 创建 Coding 项目进入 Coding 官网，点击登录（如果首次使用，需要创建团队-创建用户-完成注册，安装步骤完成） 进入后创建项目，选择 DevOps 项目 （比较关键，决定后面能否静态部署）创建完项目后，新建仓库重点这里，新建静态网站 这里有三种方式： 代码来源-现有仓库，网站类型-静态网站 代码来源-现有仓库，网站类型-Hexo/Jekyll 代码来源-示例仓库，网站类型-Hexo/Jekyll 区别在于是在本地构建编译，还是云构建编译。最终都是把编译后的代码部署到服务。 好，到此，上面双部署就算完成。 自定义域名并HTTPSGithub 自定义域名在 Settings -&gt; GitHub Pages 直接配置 Custom domain。这里要注意一定要在 hexo项目source下新建一个 CNAME 文件，内容为你自定义的域名，解决每次发布的时候 Custom domain 会被重置的问题。 Coding 自定义域名静态网站 -&gt; 自定义域名。 配置同时需要生产SSL证书，并且需要做域名解析的配置。 至此，我们的 Hexo 博客就成功双线部署到 Coding Pages 和 GitHub Pages 了，并且也实现了全站 HPPTS。完成配置后你会明显发现速度的变化。","categories":[{"name":"折腾不止","slug":"折腾不止","permalink":"https://blog.jddfe.com/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.jddfe.com/tags/Hexo/"},{"name":"Github Page","slug":"Github-Page","permalink":"https://blog.jddfe.com/tags/Github-Page/"}]},{"title":"闭包为什么会占用内存","slug":"闭包为什么会占用内存","date":"2016-09-03T14:16:54.000Z","updated":"2020-11-17T12:54:33.349Z","comments":true,"path":"posts/28448/","link":"","permalink":"https://blog.jddfe.com/posts/28448/","excerpt":"","text":"在试图弄清这个问题之前，先要理解栈内存堆内存和预处理 占用内存，不会销毁的闭包实例例1：123456789var num = 12;function fn() &#123; var num = 100; return function () &#123; console.log(num); &#125;&#125;var f = fn();f(); 例1的图示 未被占用的堆内存才会被销毁 所以，正如图中椭圆形关键点中说明的那样，堆内存xxxfff111被返回给了全局变量f，而全局变量只有在窗口关闭的时候才会销毁，因此堆内存xxxfff111将一直被占用而不会销毁，定义它的局部作用域A也不会被销毁。 例2123456var oDiv = document.getElementById(&quot;div1&quot;);function() &#123; oDiv.onclick = function() &#123; &#125;&#125;(); 这段代码的特点是：私有作用域给dom元素的事件绑定一个方法。 例2的图示： 正如图中椭圆形关键点所说，标签对象的属性里面会自带一个onclick的属性，未被赋值时其值为null。那么，在自执行函数执行的时候，其创建的作用域所占用的堆内存xxxfff111同样也会被全局的堆内存xxxfff000占用（这里要注意，是堆内存占用堆内存），所以堆内存xxxfff111和栈内存A都不会被销毁。 不占用内存，立即销毁的实例只需要将例1稍作修改。 例3：1234567function fn()&#123; var num &#x3D; 100; return function()&#123; console.log(num); &#125;&#125;fn(); &#x2F;&#x2F;主要修改在这里 例3的图示 由于在函数fn中，xxxfff111是被return的，所以栈内存A的预解释不会处理xxxfff111，它只在fn函数执行的时候才会生成，而函数fn的栈内存A每次被执行之后都会被销毁。 暂时占用内存，延时销毁的闭包实例将例3稍作修改，就变成了延时销毁的闭包实例。 例4：1234567function fn()&#123; var num = 100; return function()&#123; &#125;&#125;fn()(); //这里到底发生了什么？其实是执行了一次fn之后，把返回的子函数有执行了一次，所以在子函数执行的时候，栈内存fn()是不能销毁的，但是子函数执行完毕后因为没有被占用，所以最终还是要被销毁的，所以最终fn()还是会被销毁的。 例4的图示： 正如途中椭圆形关键点处所说，fn()()的意思是在执行完fn()之后再把返回的值函数执行一遍。因此在子函数执行的时候，堆内存xxxfff111被占用了，相应的栈内存A也将保留。 可堆内存xxxfff111中保存的子函数在执行完成之后还是会被销毁，接着堆内存xxxfff111就作为未被占用的堆内存而被销毁，最终栈内存A也会被销毁。 所以，栈内存在执行完之后会被保留一段时间，这段时间等于其子函数执行的时间。 参考资料： javascript高级程序设计(第三版)。","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Javascript","slug":"Javascript","permalink":"https://blog.jddfe.com/tags/Javascript/"},{"name":"闭包","slug":"闭包","permalink":"https://blog.jddfe.com/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"栈内存堆内存和预处理","slug":"栈内存堆内存和预处理","date":"2016-09-02T14:10:54.000Z","updated":"2020-11-17T12:54:33.344Z","comments":true,"path":"posts/49976/","link":"","permalink":"https://blog.jddfe.com/posts/49976/","excerpt":"","text":"浏览器是如何运行javascript代码的？JavaScript 是如何运行的？ 看例1： 123456var num = 12;function fn() &#123; var num = 100;&#125;fn();num = 200; 用图解释这一行代码是如何执行的。 这是一个简单的图示，现在我们来增加几个概念：栈内存、堆内存和预处理。 栈内存栈内存用来存放基本数据类型(Number、String、Boolean、Null和Undefined)，在执行完之后销毁。 栈内存与另一个概念息息相关——作用域，即代码的执行环境。上图中左边的栈内存就是全局作用域，而右边的则是局部作用域。全局作用域在浏览器窗口关闭之后才销毁。局部作用域在执行完之后就会销毁。 javascript规定，父作用域不能使用子作用域中变量和方程，而反过来是可以的。这个反过来的方向链条则被称为作用域链。 这里需要注意的是，判断子作用域的父作用域是哪一个，要看这个子作用域是在哪里定义的，而不是在哪里执行。 堆内存堆内存用来存放引用数据类型(object、array、function、date)，在没有被引用之后销毁。 当我们声明和定义了一个引用数据类型之后，这个对象保存在堆内存中，而这个对象的地址则保存在栈内存中以用于引用。 在全局作用域声明和定义的引用数据类型，销毁的方法是手动赋值null。 看一组例子来说明栈内存与堆内存的区别：例2 1234var a &#x3D; 20;var b &#x3D; a;b &#x3D; 30;&#x2F;&#x2F; a等于多少？ 例3 1234var m &#x3D; &#123; a: 10, b: 20 &#125;var n &#x3D; m;n.a &#x3D; 15;&#x2F;&#x2F; m.a的值是分别是什么？ 例2的图解 例3的图解 由上两个图解可见，当基本数据类型传递的时候，其实是复制了一个新的数据给另一个变量；而当引用类型传递的时候，复制的仅仅是引用数据类型的地址，两个变量通过地址指向的是同一个堆内存中的数据。 所以在例3中，当我们改变n.a的时候，m.a也同样改变了。 预处理预处理是浏览器在执行代码前要做的任务，它包括变量的声明和函数声明与定义。 预处理是变量提升的原因。 当我们写了var num = 12这样的一行代码的时候，在执行时其实是分为两步：声明var num和定义num = 12。对于变量，预处理只做声明而不做定义。 而相对于函数function fn()&#123;var num 12&#125;，同样有声明和定义之分，与变量不同的是，预处理时声明和定义全部执行。具体步骤是：声明function fn()，定义fn() = &quot;&#123;var num = 12&#125;&quot;。 理解了栈内存、堆内存和预处理之后，重新画出例1的图示： 这里的堆内存xxxfff000被全局作用域的函数fn引用，而全局作用域只有在浏览器窗口关闭的时候才会销毁，所以，只要浏览器窗口没有关闭，则堆内存xxxfff000一直被引用而不会销毁。 参考资料： javascript高级程序设计(第三版)；","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Javascript","slug":"Javascript","permalink":"https://blog.jddfe.com/tags/Javascript/"},{"name":"栈和堆","slug":"栈和堆","permalink":"https://blog.jddfe.com/tags/%E6%A0%88%E5%92%8C%E5%A0%86/"}]},{"title":"JS 中的事件绑定、事件监听、事件委托","slug":"JS 中的事件绑定、事件监听、事件委托","date":"2016-08-18T12:50:14.000Z","updated":"2020-11-17T12:54:33.333Z","comments":true,"path":"posts/31762/","link":"","permalink":"https://blog.jddfe.com/posts/31762/","excerpt":"事件绑定 要想让 javascript 对用户的操作作出响应，首先要对 dom 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称","text":"事件绑定 要想让 javascript 对用户的操作作出响应，首先要对 dom 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称 在javascript中，有三种常用的绑定事件的方法 在dom元素中直接绑定； 在javascript代码中绑定； 绑定事件监听函数 在dom中直接绑定事件1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;hello()&quot;&gt;&lt;script&gt;function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 在javascript代码中绑定事件 在javascript代码中（即script标签内）绑定事件可以使javascript代码与HTML标签分离，文档结构清晰，便于管理和开发 1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn&quot;).onclick = function()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 使用事件监听绑定事件 关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段 起初Netscape制定了javascript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范 W3C规范 语法 1element.addEventListener(event, function, useCapture) event : （必需）事件名，支持所有dom事件。 function：（必需）指定要事件触发时执行的函数。 useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false 注： IE8 以下不支持 12345678&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn1&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn1&quot;).addEventListener(&quot;click&quot;,hello);function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; IE标准 语法： 1element.attachEvent(event, function) event：（必需）事件类型。需加“on“，例如：onclick。 function：（必需）指定要事件触发时执行的函数 12345678&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn2&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn2&quot;).attachEvent(&quot;onclick&quot;,hello);function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 事件监听的优点 可以绑定多个事件 1234567891011&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn3&quot;&gt;&lt;script&gt;var btn3 = document.getElementById(&quot;btn3&quot;);btn3.onclick = function()&#123; alert(&quot;hello 1&quot;); //不执行&#125;btn3.onclick = function()&#123; alert(&quot;hello 2&quot;); //执行&#125;&lt;/script&gt; 常规的事件绑定只执行最后绑定的事件 1234567891011121314&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn4&quot;&gt;&lt;script&gt;var btn4 = document.getElementById(&quot;btn4&quot;);btn4.addEventListener(&quot;click&quot;,hello1);btn4.addEventListener(&quot;click&quot;,hello2);function hello1()&#123; alert(&quot;hello 1&quot;);&#125;function hello2()&#123; alert(&quot;hello 2&quot;);&#125;&lt;/script&gt; 两个事件都执行了 可以解除相应的绑定 123456789101112131415&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;&lt;script&gt;var btn5 = document.getElementById(&quot;btn5&quot;);btn5.addEventListener(&quot;click&quot;,hello1);//执行了btn5.addEventListener(&quot;click&quot;,hello2);//不执行btn5.removeEventListener(&quot;click&quot;,hello2);function hello1()&#123; alert(&quot;hello 1&quot;);&#125;function hello2()&#123; alert(&quot;hello 2&quot;);&#125;&lt;/script&gt; 封装事件监听 12345678910111213141516171819202122232425&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;//绑定监听事件function addEventHandler(target,type,fn)&#123; if(target.addEventListener)&#123; target.addEventListener(type,fn); &#125;else&#123; target.attachEvent(&quot;on&quot;+type,fn); &#125;&#125;//移除监听事件function removeEventHandler(target,type,fn)&#123; if(target.removeEventListener)&#123; target.removeEventListener(type,fn); &#125;else&#123; target.detachEvent(&quot;on&quot;+type,fn); &#125;&#125;//测试var btn5 = document.getElementById(&quot;btn5&quot;);addEventHandler(btn5,&quot;click&quot;,hello1);//添加事件hello1addEventHandler(btn5,&quot;click&quot;,hello2);//添加事件hello2removeEventHandler(btn5,&quot;click&quot;,hello1);//移除事件hello1 事件委托 事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果 12345678910&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn6&quot;&gt;var btn6 = document.getElementById(&quot;btn6&quot;);document.onclick = function(event)&#123; event = event || window.event; var target = event.target || event.srcElement; if(target == btn6)&#123; alert(btn5.value); &#125;&#125; 事件委托优点 提高javascript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用 传统写法 123456789101112131415161718192021&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);item1.onclick = function()&#123; alert(&quot;hello item1&quot;);&#125;item2.onclick = function()&#123; alert(&quot;hello item2&quot;);&#125;item3.onclick = function()&#123; alert(&quot;hello item3&quot;);&#125;&lt;/script&gt; 事件委托 12345678910111213141516171819202122&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123; var target = event.target; if(target == item1)&#123; alert(&quot;hello item1&quot;); &#125;else if(target == item2)&#123; alert(&quot;hello item2&quot;); &#125;else if(target == item3)&#123; alert(&quot;hello item3&quot;); &#125;&#125;)&lt;/script&gt; 动态的添加dom元素，不需要因为元素的改动而修改事件绑定 传统写法 123456789101112131415161718192021222324&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);var item = list.getElementsByTagName(&quot;li&quot;);for(var i=0;i&lt;item.length;i++)&#123; (function(i)&#123; item[i].onclick = function()&#123; alert(item[i].innerHTML); &#125; &#125;)(i)&#125;var node=document.createElement(&quot;li&quot;);var textnode=document.createTextnode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; 点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。 事件委托 12345678910111213141516171819202122&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123; var target = event.target; if(target.nodeName == &quot;LI&quot;)&#123; alert(target.innerHTML); &#125;&#125;)var node=document.createElement(&quot;li&quot;);var textnode=document.createTextnode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; 当点击item4时，item4有事件响应。说明事件委托可以为新添加的dom元素动态的添加事件","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.jddfe.com/tags/javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"事件","slug":"事件","permalink":"https://blog.jddfe.com/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"event","slug":"event","permalink":"https://blog.jddfe.com/tags/event/"}]},{"title":"OOP之原型与原型链","slug":"OOP之原型与原型链","date":"2016-08-17T12:40:20.000Z","updated":"2020-11-17T12:54:33.338Z","comments":true,"path":"posts/65309/","link":"","permalink":"https://blog.jddfe.com/posts/65309/","excerpt":"prototype原型对象 每个函数都有一个默认的prototype属性，其实际上还是一个对象，如果被用在继承中，姑且叫做原型对象 在构造函数中的prototype中定义的属性和方法，会被创建的对象所继承下来。举个栗子：","text":"prototype原型对象 每个函数都有一个默认的prototype属性，其实际上还是一个对象，如果被用在继承中，姑且叫做原型对象 在构造函数中的prototype中定义的属性和方法，会被创建的对象所继承下来。举个栗子： 123456function F()&#123;&#125;F.prototype.work = function()&#123; console.log(&#x27;F is working..&#x27;);&#125;;var f = new F();f.work(); // F is working.. 当你创建函数时，JS会为这个函数自动添加 prototype 属性，值是空对象。而一旦你把这个函数当作构造函数（ constructor ）调用（即通过 new 关键字调用），那么JS就会帮你创建该构造函数的实例，实例继承构造函数 prototype 的所有属性和方法（实例通过设置自己的 __proto__ 指向构造函数的 prototype 来实现这种继承） 神秘的proto JS的对象中都包含了一个__proto__属性，其指向的是创建该对象时的构造函数的原型对象prototype 从上面的输出结果看出，f.__proto__指向了其构造函数F的prototype，而F.prototype本身也是一个对象，其内部也有__proto__属性，其指向的是Object.prototype,直到最后Object.prototype指向null，这条原型链才结束 因此，__proto__这个神秘的属性才是原型链形成的真正原因 原型链 由于原型对象本身也是对象，根据上边的定义，它也有自己的原型，而它自己的原型对象又可以有自己的原型，这样就组成了一条链，这个就是原型链，JavaScritp引擎在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回undefined。原型链一般实现为一个链表，这样就可以按照一定的顺序来查找 从上图看出： Object.prototype是顶级对象，所有对象都继承自它。 Function 继承 Function 本身， Function.prototype 继承 Object.prototype Function.prototype 和 Function.__proto__ 都指向 Function.prototype Object.prototype.__proto__ === null ，说明原型链到 Object.prototype终止","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.jddfe.com/tags/javascript/"},{"name":"原型链","slug":"原型链","permalink":"https://blog.jddfe.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"OOP之面向对象","slug":"OOP之面向对象","date":"2016-08-16T12:26:24.000Z","updated":"2020-11-17T12:54:33.341Z","comments":true,"path":"posts/14581/","link":"","permalink":"https://blog.jddfe.com/posts/14581/","excerpt":"一般面向对象包含：继承，封装，多态，抽象 对象形式的继承 浅拷贝","text":"一般面向对象包含：继承，封装，多态，抽象 对象形式的继承 浅拷贝 12345678910111213141516171819202122232425var Person = &#123; name: &#x27;allin&#x27;, age: 18, address: &#123; home: &#x27;home&#x27;, office: &#x27;office&#x27;, &#125; sclools: [&#x27;x&#x27;,&#x27;z&#x27;],&#125;;var programer = &#123; language: &#x27;js&#x27;,&#125;;function extend(p, c)&#123; var c = c || &#123;&#125;; for( var prop in p)&#123; c[prop] = p[prop]; &#125;&#125;extend(Person, programer);programer.name; // allinprogramer.address.home; // homeprogramer.address.home = &#x27;house&#x27;; //housePerson.address.home; // house 从上面的结果看出，浅拷贝的缺陷在于修改了子对象中引用类型的值，会影响到父对象中的值，因为在浅拷贝中对引用类型的拷贝只是拷贝了地址，指向了内存中同一个副本 深拷贝 1234567891011function extendDeeply(p, c)&#123; var c = c || &#123;&#125;; for (var prop in p)&#123; if(typeof p[prop] === &quot;object&quot;)&#123; c[prop] = (p[prop].constructor === Array)?[]:&#123;&#125;; extendDeeply(p[prop], c[prop]); &#125;else&#123; c[prop] = p[prop]; &#125; &#125;&#125; 利用递归进行深拷贝，这样子对象的修改就不会影响到父对象 123extendDeeply(Person, programer);programer.address.home = &#x27;allin&#x27;;Person.address.home; // home 利用call和apply继承 12345678function Parent()&#123; this.name = &quot;abc&quot;; this.address = &#123;home: &quot;home&quot;&#125;;&#125;function Child()&#123; Parent.call(this); this.language = &quot;js&quot;; &#125; ES5中的Object.create()123var p = &#123; name : &#x27;allin&#x27;&#125;;var obj = Object.create(o);obj.name; // allin Object.create()作为new操作符的替代方案是ES5之后才出来的。我们也可以自己模拟该方法： 12345678910//模拟Object.create()方法function myCreate(o)&#123; function F()&#123;&#125;; F.prototype = o; o = new F(); return o;&#125;var p = &#123; name : &#x27;allin&#x27;&#125;;var obj = myCreate(o);obj.name; // allin 目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署 1234567 if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;; &#125; 类的继承 Object.create() 123456789function Person(name, age)&#123;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123; console.log(&#x27;eating...&#x27;);&#125;function Programmer(name, age, title)&#123;&#125;Programmer.prototype = Object.create(Person.prototype); //建立继承关系Programmer.prototype.constructor = Programmer; // 修改constructor的指向 调用父类方法 12345678910111213141516171819202122function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123; console.log(&#x27;eating...&#x27;);&#125;function Programmer(name, age, title)&#123; Person.apply(this, arguments); // 调用父类的构造器&#125;Programmer.prototype = Object.create(Person.prototype);Programmer.prototype.constructor = Programmer;Programmer.prototype.language = &quot;js&quot;;Programmer.prototype.work = function()&#123; console.log(&#x27;i am working code in &#x27;+ this.language); Person.prototype.eat.apply(this, arguments); // 调用父类上的方法&#125; 封装 命名空间 js是没有命名空间的，因此可以用对象模拟 12345678910var app = &#123;&#125;; // 命名空间app//模块1app.module1 = &#123; name: &#x27;allin&#x27;, f: function()&#123; console.log(&#x27;hi robot&#x27;); &#125;&#125;;app.module1.name; // &quot;allin&quot;app.module1.f(); // hi robot 静态成员 123456789function Person(name)&#123; var age = 100; this.name = name;&#125;//静态成员Person.walk = function()&#123; console.log(&#x27;static&#x27;);&#125;;Person.walk(); // static 私有与公有 1234567891011121314151617function Person(id)&#123; // 私有属性与方法 var name = &#x27;allin&#x27;; var work = function()&#123; console.log(this.id); &#125;; //公有属性与方法 this.id = id; this.say = function()&#123; console.log(&#x27;say hello&#x27;); work.call(this); &#125;;&#125;;var p1 = new Person(123);p1.name; // undefinedp1.id; // 123p1.say(); // say hello 123 模块化 1234567891011var moduleA;moduleA = function() &#123; var prop = 1; function func() &#123;&#125; return &#123; func: func, prop: prop &#125;;&#125;(); // 立即执行匿名函数 多态 模拟方法重载 arguments属性可以取得函数调用的实参个数，可以利用这一点模拟方法的重载 12345678function demo(a, b )&#123; console.log(demo.length); // 得到形参个数 console.log(arguments.length); //得到实参个数 console.log(arguments[0]); // 第一个实参 4 console.log(arguments[1]); // 第二个实参 5&#125;demo(4, 5, 6); 123456789101112131415161718192021222324252627282930313233343536373839//实现可变长度实参的相加function add()&#123; var total = 0; for( var i = arguments.length - 1; i &gt;= 0; i--)&#123; total += arguments[i]; &#125; return total;&#125;console.log(add(1)); // 1console.log(add(1, 2, 3)); // 7// 参数不同的情况function fontSize()&#123; var ele = document.getElementById(&#x27;js&#x27;); if(arguments.length == 0)&#123; return ele.style.fontSize; &#125;else&#123; ele.style.fontSize = arguments[0]; &#125;&#125;fontSize(18);console.log(fontSize());// 类型不同的情况function setting()&#123; var ele = document.getElementById(&#x27;js&#x27;); if(typeof arguments[0] === &quot;object&quot;)&#123; for(var p in arguments[0])&#123; ele.style[p] = arguments[0][p]; &#125; &#125;else&#123; ele.style.fontSize = arguments[0]; ele.style.backgroundColor = arguments[1]; &#125;&#125;setting(18, &#x27;red&#x27;);setting(&#123;fontSize:20, backgroundColor: &#x27;green&#x27;&#125;); 方法重写 1234567891011function F()&#123;&#125;var f = new F();F.prototype.run = function()&#123; console.log(&#x27;F&#x27;);&#125;f.run(); // Ff.run = function()&#123; console.log(&#x27;fff&#x27;);&#125;f.run(); // fff 抽象类 在构造器中 throw new Error(&#39;&#39;); 抛异常。这样防止这个类被直接调用 12345678910111213141516171819202122232425function DetectorBase() &#123; throw new Error(&#x27;Abstract class can not be invoked directly!&#x27;);&#125;DetectorBase.prototype.detect = function() &#123; console.log(&#x27;Detection starting...&#x27;);&#125;;DetectorBase.prototype.stop = function() &#123; console.log(&#x27;Detection stopped.&#x27;);&#125;;DetectorBase.prototype.init = function() &#123; throw new Error(&#x27;Error&#x27;);&#125;;// var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!function LinkDetector() &#123;&#125;LinkDetector.prototype = Object.create(DetectorBase.prototype);LinkDetector.prototype.constructor = LinkDetector;var l = new LinkDetector();console.log(l); //LinkDetector &#123;&#125;__proto__: LinkDetectorl.detect(); //Detection starting...l.init(); //Uncaught Error: Error","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.jddfe.com/tags/javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面向对象","slug":"面向对象","permalink":"https://blog.jddfe.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"OOP之类与对象","slug":"OOP之类与对象","date":"2016-08-15T12:55:24.000Z","updated":"2020-11-17T12:54:33.340Z","comments":true,"path":"posts/10937/","link":"","permalink":"https://blog.jddfe.com/posts/10937/","excerpt":"对象 对象的含义 所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成","text":"对象 对象的含义 所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成 对象的创建 使用new运算符创建Object 12var p = new Object();p.name = &quot;Tony&quot;; 使用对象字面量的形式 12345678910111213141516171819//对象字面量形式var p =&#123; name: &quot;tony&quot;, work: function()&#123; console.log(&quot;working....&quot;); &#125;, _age: 18, get age()&#123; return this._age; &#125;, set age(val)&#123; if( val &lt;0 || val &gt; 150)&#123; throw new Error(&quot;invalid value&quot;); &#125;else&#123; this._age = val; &#125; &#125;&#125;console.log(p.name); 对象的基本操作 成员属性的添加 123456789101112// Object.defineProperty()方法Object.defineProperty(p, &quot;age&quot;,&#123;value: 18, writable: false&#125;);//Object.defineProperties()方法 添加多个属性Object.defineProperties(p, &#123; salary:&#123; value: 1000, writable: false &#125;, gender:&#123; value: true &#125;&#125;); 成员的遍历 使用 for..in语句 Object.keys()方法 返回一个包含对象键名的字符串数组 1234567var o =&#123;&#125;;o.name = &quot;jack&quot;;o.age = 20;for(var i in o)&#123; console.log(o[i]);&#125; // jack, 20Object.keys(o); // [&quot;name&quot;, &quot;age&quot;] 检查对象是否有某个属性 in 操作符 Object.hasOwnProperty()方法 123var o = &#123;name: &quot;mariya&quot;&#125;&quot;name&quot; in o; // trueo.hasOwnProperty(&quot;name&quot;); // true 得到对象的属性特性描述 Object.getOwnPropertyDescriptor(obj,property) 1234Object.getOwnPropertyDescriptor(o, &quot;name&quot;);//Object &#123;// value: &quot;mariya&quot;, writable: true, enumerable: true, configurable: true&#125; 删除属性 delete运算符,但有些对象的属性是删除不了的 12delete o.name; //trueo.name; // undefined Constructor属性 constructor始终指向创建当前对象的构造函数 12345678var arr = [];console.log(arr.constructor === Array); // truevar Foo = function() &#123;&#125;;console.log(Foo.constructor === Function); // true// 由构造函数实例化一个obj对象var obj = new Foo();console.log(obj.constructor === Foo); // trueconsole.log(obj.constructor.constructor === Function); // true 每个函数都有一个默认的属性prototype，而这个prototype的constructor默认指向这个函数 类的创建 虽然js是门基于对象的语言，但是没有类这一概念的，虽然保留了class的关键字，但在ES6之前是无法使用的。所以，可以用构造函数模拟类的创建，也就是伪类。 所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上 每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承 12345678910//构造函数模式function Person(age, name)&#123; //Class this.age = age; this.name = name;&#125;//将公共的属性或方法放在prototype属性上Person.prototype.headCount = 1;//创建实例对象var p = new Person(19, &#x27;johnsom&#x27;);var p1 = new Person(20, &#x27;allen&#x27;); this this表示当前对象，如果在全局作用范围内使用this，则指代当前页面对象window； 如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用apply和call两个全局方法来改变函数中this的具体指向 全局代码中的this1console.log(this === window); //true 全局范围内使用this指向window对象 普通的函数调用123function f()&#123;this.name = &quot;tony&quot;; // this在运行时指向window对象,在严格模式下则是undefined&#125; 在对象中使用123456var o = &#123; name: &quot;tony&quot;, print: function()&#123; console.log(this.name); //this指向对象o，但是可以改变其指向 &#125;&#125;; 作为构造函数1new F(); // 函数内部的this指向新创建的对象。 多层嵌套的内部函数1234567891011var name = &quot;global&quot;;var person = &#123; name : &quot;person&quot;, hello : function(sth)&#123; var sayhello = function(sth) &#123; console.log(this.name + &quot; says &quot; + sth); &#125;; sayhello(sth); &#125;&#125;person.hello(&quot;hello world&quot;);//global says hello world 在内部函数中，this没有按预想的绑定到外层函数对象上，而是绑定到了全局对象。这里普遍被认为是javascript语言的设计错误，因为没有人想让内部函数中的this指向全局对象。一般的处理方式是将this作为变量保存下来，一般约定为that或者self： 123456789101112var name = &quot;global&quot;;var person = &#123; name : &quot;person&quot;, hello : function(sth)&#123; var that = this; var sayhello = function(sth) &#123; console.log(that.name + &quot; says &quot; + sth); &#125;; sayhello(sth); &#125;&#125;person.hello(&quot;hello world&quot;);//person says hello world 事件中的this1234var ele = document.getElementById(&quot;id&quot;);ele.addEventListener(&#x27;click&#x27;,function()&#123; console.log(this); //this指向dom元素&#125;); 使用apply和call改变this的指向 apply和call类似，只是后面的参数是通过一个数组传入，而不是分开传入。两者都是将某个函数绑定到某个具体对象上使用，自然此时的this会被显式的设置为第一个参数。两者的方法定义： 12call( thisArg [，arg1，arg2，… ] ); // 参数列表，arg1，arg2，...apply(thisArg [，argArray] ); // 参数数组，argArray 1234567891011var name = &#x27;global&#x27;;var o = &#123; name: &#x27;job&#x27;, getName: function()&#123; console.log(this.name); &#125;&#125;;o.getName(); // job//用call或apply改变函数中this的指向o.getName.call(this); // global 简单的总结： 当函数作为对象的方法调用时，this指向该对象。 构造函数中的this指向新创建的对象 嵌套函数中的this不会继承上层函数的this，如果需要，可以用一个变量保存上层函数的this bind（） 该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数. 12$(&quot;#ele&quot;).click(person.hello.bind(person));//相应元素被点击时，输出person says hello world","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.jddfe.com/tags/javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"面向对象","slug":"面向对象","permalink":"https://blog.jddfe.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"移动端自适应适配实现方案","slug":"移动端自适应适配实现方案","date":"2016-06-16T07:21:47.000Z","updated":"2020-11-17T12:54:33.346Z","comments":true,"path":"posts/14854/","link":"","permalink":"https://blog.jddfe.com/posts/14854/","excerpt":"","text":"最近招聘面试过程中，我经常会问到这个移动端自适应适配是怎么实现的，大部分候选人都能说初rem的方式，但是很少有能说出原理的。 rem 实现弹性布局原理根据屏幕宽度动态改变 html 根字体的大小。 （1）rem + js 实现弹性布局 rem 和 em 两者都是 css 的相对单位，但是两者有明显的区别：当作为font-size单位时，em 表示相对于父元素字体的大小；当作为其他单位时，表示自身字体大小，比如首行缩紧2个字符 text-indent:2em; 。当作为非根元素的时，rem 是相对于根字体的大小；当作为根元素时，相对于初始字体大小的。💡em 容易造成“牵一发而动全身”，可以用作于行高、首行缩紧等；rem 最大的特点是统一参考系，其实现弹性布局的本质是等比缩放（通常是基于宽度）。 （2）更高级的单位 vw 实现弹性布局 如果把屏幕宽度分为 100 份，每一份就是宽度的 1% ，如果以这一份为单位 就可以实现弹性布局了。利用 rem 相对于根字体这个特性，可以间接地实现这样的单位。 根字体的大小通常是通过 js 获取屏幕宽度设置的。但是 CSS3 引入了一个新的单位 vw ，vw —— 视口宽度的 1/100，其实正是上面我们想办法实现的那个每一份的单位。 vw 允许不通过 js 也能实现根据屏幕宽度的弹性布局。 （3）vw + rem实现弹性布局 我们完全可以通过 vw 实现弹性布局，当然 vw 结合 rem 同样可以实现弹性布局。 媒体查询移动端设备的屏幕大小差别很大，为了避免因为屏幕过宽或过窄造成字体过大或过小，需要结合媒体查询 根据不同屏幕的宽度，设定相对单位的大小。这个时候就需要利用 rem 实现了。 1234//当屏幕宽度小于 320px 的时候，规定字体大小 64px 。@media screen and (max-width: 320px) &#123; font-size: 64px; &#125; 1234//当屏幕宽度大于 540px 的时候，规定字体大小 108px 。@media screen and (min-width: 540px) &#123; font-size: 108px; &#125; 💡响应式布局是不同设备、屏幕展示的样式不同。弹性布局则是等比缩放，高度还原。弹性布局属于响应式布局的一种。使用 rem 实现弹性布局不允许用户设置字体大小，所以 rem 通常适用于图标类活动页，而不是适用于纯文本的页面。 css 预处理器语言 scssscss 是 css 预处理器语言，语法规则和 css 类似。比如，变量使用 $ 符表示，如 $m_fontsize:75 。可以定义函数等。具体规则可查看sass官方文档。 rem + vw + 媒体查询方式实现弹性布局的完整代码实例12345678910111213141516&#x2F;&#x2F;通常设计稿以 iphone6 为模型来设计的。因为 iphone6 屏幕宽度是 750px ，所以 iphone6 的屏宽尺寸设置根元素大小基准值 75px ，这里 75px 只是用来计算的，完全可以设置成其他的值$m_fontsize: 75; @function rem($px) &#123; @return ($px &#x2F; $m_fontsize) * 1rem; &#125; $m_design: 750; html &#123; font-size: ($m_fontsize &#x2F; ($m_design &#x2F; 2)) * 100vw; &#x2F;&#x2F; 通过媒体查询限制屏幕过宽过窄造成的页面内容过大和过小的问题 @media screen and (max-width: 320px) &#123; font-size: 64px; &#125; @media screen and (min-width: 540px) &#123; font-size: 110px; &#125; &gt;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"rem","slug":"rem","permalink":"https://blog.jddfe.com/tags/rem/"},{"name":"css","slug":"css","permalink":"https://blog.jddfe.com/tags/css/"},{"name":"适配","slug":"适配","permalink":"https://blog.jddfe.com/tags/%E9%80%82%E9%85%8D/"}]},{"title":"ES6从入门到精通之常量与变量(一)","slug":"ES6从入门到精通之常量与变量(一)","date":"2016-04-03T12:30:22.000Z","updated":"2020-11-17T12:54:33.327Z","comments":true,"path":"posts/63881/","link":"","permalink":"https://blog.jddfe.com/posts/63881/","excerpt":"","text":"ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。 Mozilla公司将在这个标准的基础上，推出JavaScript 2.而ES6有着强大的目标，是使得JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。 对ES6的支持可以查看http://kangax.github.io/compat-table/es6/，在这里可以清晰的了解到不同版本的浏览器对ES6功能的支持情况。如果你想现在就在浏览器使用ES6的特性，还可以通过引用兼容包的方式提前尝尝鲜。 https://github.com/paulmillr/es6-shim。 环境支持推荐用js工具babel来编译http://babeljs.io/。变量与字符串 let是ES6中新增关键字。它的作用类似于var，用来声明变量，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#x2F;*E1*&#x2F;if(true)&#123; var a &#x3D; 1; let b &#x3D; 2;&#125;document.write(a+&#39;&lt;br&#x2F;&gt;&#39;);document.write(b+&#39;&lt;br&#x2F;&gt;&#39;); &#x2F;&#x2F; Uncaught ReferenceError: b is not defined Example2 123456789101112&#x2F;*E2*&#x2F;function f1() &#123; var a &#x3D; 8; let n &#x3D; 5; if (true) &#123; let n &#x3D; 10; var a &#x3D; 20 &#125; document.write(n); &#x2F;&#x2F; 5 document.write(a); &#x2F;&#x2F; 20&#125;f1(); Q1：用let声明a变量默认为5，在if判断中let声明a为10，看a输出结果。 123456&#x2F;*Exercises1*&#x2F;let a &#x3D; 5;if (true) &#123; let a &#x3D; 10;&#125;document.write(a);&#x2F;&#x2F;5 for循环的计数器，就很合适使用let命令。 12345678910111213141516&#x2F;*E3*&#x2F;var a &#x3D; [];for (var i &#x3D; 0; i &lt; 10; i++) &#123; a[i] &#x3D; function () &#123; document.write(i); &#125;;&#125;a[6](); var a &#x3D; [];for (let i &#x3D; 0; i &lt; 10; i++) &#123; a[i] &#x3D; function () &#123; document.write(i); &#125;;&#125;a[6](); constconst 声明的是常量，一旦声明，值将是不可变的。 12345678const PI &#x3D; 3.1415;PI &#x2F;&#x2F; 3.1415 PI &#x3D; 3;PI &#x2F;&#x2F; 3.1415 const PI &#x3D; 3.1;PI &#x2F;&#x2F; 3.1415 const 也具有块级作用域 12345678910&#x2F;*E4*&#x2F;if (true) &#123; const max &#x3D; 5;&#125;document.write(max); &#x2F;&#x2F;Uncaught ReferenceError: max is not definedif (true) &#123; const max &#x3D; 5; document.write(max); &#x2F;&#x2F;5&#125; const 不可重复声明 /* E5*/ 12345var message &#x3D; &quot;Hello!&quot;;let age &#x3D; 25; const message &#x3D; &quot;Goodbye!&quot;;const age &#x3D; 30;&#x2F;&#x2F;cli:Duplicate declaration &quot;age&quot; const 指令指向变量所在的地址，所以对该变量进行属性设置是可行的（未改变变量地址），如果想完全不可变化（包括属性），那么可以使用冻结 /* E6*/ 12345678const C1 &#x3D; &#123;&#125;;C1.a &#x3D; 1;document.write(C1.a); &#x2F;&#x2F; 1 C1 &#x3D; &#123;&#125;; &#x2F;&#x2F; cli: C1 &#x3D; &#123;&#125;; &#x2F;&#x2F; 报错 重新赋值，地址改变const C2 &#x3D; Object.freeze(&#123;&#125;); C2.a &#x3D; 1; document.write(C2.a);&#x2F;&#x2F;Uncaught TypeError: Can&#39;t add property a, object is not extensible Q2:在if (true) { 声明一个const变量a，并为赋值为5， }在块级作用域中和外面，分别打印变量a看结果。 123456&#x2F;*Exercises2*&#x2F;if(true)&#123; const a&#x3D;5; document.write(&#39;a1:&#39;+a);&#125;document.write(&#39;a2:&#39;+a);&#x2F;&#x2F;Uncaught ReferenceError: a is not defined 是否包含字符串三种新方法传统上，JavaScript只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 12345var str &#x3D; &quot;Hello world!&quot;; str.startsWith(&quot;Hello&quot;) &#x2F;&#x2F; truestr.endsWith(&quot;!&quot;) &#x2F;&#x2F; truestr.includes(&quot;o&quot;) &#x2F;&#x2F; true 这三个方法都支持第二个参数，表示开始搜索的位置。 上面代码表示，使用第二个参数n时，endsWith 的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 12345var str &#x3D; &quot;Hello world!&quot;; str.startsWith(&quot;world&quot;, 6) &#x2F;&#x2F; truestr.endsWith(&quot;Hello&quot;, 5) &#x2F;&#x2F; truestr.includes(&quot;Hello&quot;, 6) &#x2F;&#x2F; false repeat()原字符串重复 12345var str &#x3D; &quot;x&quot;;str.repeat(3) &#x2F;&#x2F; &quot;xxx&quot; var str1 &#x3D; &quot;hello&quot;;str1.repeat(2) &#x2F;&#x2F; &quot;hellohello&quot; 标签模板模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 1234var a &#x3D; 5;var b &#x3D; 10; tag&#96;Hello $&#123; a + b &#125; world $&#123; a * b &#125;&#96;; tag函数所有参数的实际值如下。 第一个参数：[‘Hello ‘, ‘ world ‘] 第二个参数: 15 第三个参数：50 也就是说，tag函数实际上以下面的形式调用。 1tag([&#39;Hello &#39;, &#39; world &#39;], 15, 50) tag用法 12345678910111213141516171819&#x2F;*E7*&#x2F;var a &#x3D; 5;var b &#x3D; 10; function tag(s, v1, v2) &#123; document.write(s[0]+&#39;&lt;br&#x2F;&gt;&#39;); document.write(s[1]+&#39;&lt;br&#x2F;&gt;&#39;); document.write(v1+&#39;&lt;br&#x2F;&gt;&#39;); document.write(v2+&#39;&lt;br&#x2F;&gt;&#39;); return &quot;OK&quot;;&#125; tag&#96;Hello $&#123; a + b &#125; world $&#123; a * b&#125;&#96;;&#x2F;&#x2F; &quot;Hello &quot;&#x2F;&#x2F; &quot; world &quot;&#x2F;&#x2F; 15&#x2F;&#x2F; 50&#x2F;&#x2F; &quot;OK&quot; 模板字符串可以是原始的ES6还为原生的String对象，提供了一个raw方法。若使用String.raw 作为模板字符串的前缀，则模板字符串可以是原始(raw)的。反斜线也不再是特殊字符，\\n 也不会被解释成换行符： 1234567&#x2F;*E8*&#x2F;var raw &#x3D;String(&#39;Not a newline: \\n&#39;);document.write(raw &#x3D;&#x3D;&#x3D; &#39;Not a newline: \\\\n&#39;);&#x2F;&#x2F; false let raw &#x3D; String.raw&#96;Not a newline: \\n&#96;; document.write(raw &#x3D;&#x3D;&#x3D; &#39;Not a newline: \\\\n&#39;); &#x2F;&#x2F; true 有兴趣的小伙伴们还可以看下下面文档: let和const命令-阮一峰 let和const命令-阮一峰2 ES6harmony babeljs","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://blog.jddfe.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"https://blog.jddfe.com/tags/JS/"}]},{"title":"初探ES6新功能","slug":"初探ES6新功能","date":"2016-04-02T12:09:10.000Z","updated":"2020-11-17T12:54:33.353Z","comments":true,"path":"posts/15295/","link":"","permalink":"https://blog.jddfe.com/posts/15295/","excerpt":"","text":"ECMAScript 6 git.io/es6features介绍ECMAScript 6，2015年也被称为ECMAScript 标准的最新版本。标志着最新的语言，是及2009年ES5发布后相继6年出的版本。这些功能的实现主要的JavaScript引擎统计如右边链接(现在正在完善)(http://kangax.github.io/es5-compat-table/es6/) ES6的完整规范如左边网址下ES6 standard。 ES6包括以下几个新功能: arrows classes enhanced object literals template strings destructuring default + rest + spread let + const iterators + for..of generators unicode modules module loaders map + set + weakmap + weakset proxies symbols subclassable built-ins promises math + number + string + array + object APIs binary and octal literals reflect api tail calls ECMAScript 6 功能ArrowsArrows are a function shorthand using the =&gt; syntax. They are syntactically similar to the related feature in C#, Java 8 and CoffeeScript. They support both statement block bodies as well as expression bodies which return the value of the expression. Unlike functions, arrows share the same lexical this as their surrounding code. 箭头函数简单的说是用＝&gt;语法。其语法的相关特性类似于c,Java 8和CoffeeScript。他们同时支持声明块体以及表达身体的返回值的表达式。与方法不同，箭头函数分享了相同语法的this以及它周边代码 1234567891011121314151617181920&#x2F;&#x2F; Expression bodiesvar odds &#x3D; evens.map(v &#x3D;&gt; v + 1);var nums &#x3D; evens.map((v, i) &#x3D;&gt; v + i);var pairs &#x3D; evens.map(v &#x3D;&gt; (&#123;even: v, odd: v + 1&#125;));&#x2F;&#x2F; Statement bodiesnums.forEach(v &#x3D;&gt; &#123; if (v % 5 &#x3D;&#x3D;&#x3D; 0) fives.push(v);&#125;);&#x2F;&#x2F; Lexical thisvar bob &#x3D; &#123; _name: &quot;Bob&quot;, _friends: [], printFriends() &#123; this._friends.forEach(f &#x3D;&gt; console.log(this._name + &quot; knows &quot; + f)); &#125;&#125; ES5与ES6对比 1234567891011//ES5nums.forEach(function (v) &#123; if (v % 5 === 0) fives.push(v);&#125;);//ES6nums.forEach(v =&gt; &#123; if (v % 5 === 0) fives.push(v)&#125;) ClassesES6 classes are a simple sugar over the prototype-based OO pattern. Having a single convenient declarative form makes class patterns easier to use, and encourages interoperability. Classes support prototype-based inheritance, super calls, instance and static methods and constructors. ES6类是一个简单基于原型的面向对象模式。它以类模式声明,并鼓励互操作性。类支持基于原型的继承、超级调用实例和静态方法和构造函数。 1234567891011121314151617181920212223class SkinnedMesh extends THREE.Mesh &#123; constructor(geometry, materials) &#123; super(geometry, materials); this.idMatrix = SkinnedMesh.defaultMatrix(); this.bones = []; this.boneMatrices = []; //... &#125; update(camera) &#123; //... super.update(); &#125; get boneCount() &#123; return this.bones.length; &#125; set matrixType(matrixType) &#123; this.idMatrix = SkinnedMesh[matrixType](); &#125; static defaultMatrix() &#123; return new THREE.Matrix4(); &#125;&#125; ES5与ES6对比 12345678910111213141516171819202122//ES5var Shape = function (id, x, y) &#123; this.id = id; this.move(x, y);&#125;;Shape.prototype.move = function (x, y) &#123; this.x = x; this.y = y;&#125;;//ES6class Shape &#123; constructor (id, x, y) &#123; this.id = id this.move(x, y) &#125; move (x, y) &#123; this.x = x this.y = y &#125;&#125; Enhanced Object LiteralsObject literals are extended to support setting the prototype at construction, shorthand for foo: foo assignments, defining methods, making super calls, and computing property names with expressions. Together, these also bring object literals and class declarations closer together, and let object-based design benefit from some of the same conveniences. 对象文本扩展为支持设置原型结构,简称“foo:foo”模式,定义方法,使超级调用,和计算属性名表达式。在一起,这些也将文本对象和类声明更紧密地联系在一起,并让基于对象的设计更加便利的使用在一起。 12345678910111213var obj = &#123; // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Methods toString() &#123; // Super calls return &quot;d &quot; + super.toString(); &#125;, // Computed (dynamic) property names [ &#x27;prop_&#x27; + (() =&gt; 42)() ]: 42&#125;; ES5与ES6对比 1234567891011//ES5obj = &#123; foo: &quot;bar&quot;&#125;;obj[ &quot;prop_&quot; + foo() ] = 42;//ES6obj = &#123; foo: &quot;bar&quot;, [ &quot;prop_&quot; + foo() ]: 42&#125; Template StringsTemplate strings provide syntactic sugar for constructing strings. This is similar to string interpolation features in Perl, Python and more. Optionally, a tag can be added to allow the string construction to be customized, avoiding injection attacks or constructing higher level data structures from string contents. 模板构建字符串的字符串提供更简便的写法。这类似于字符串插值特性在Perl、Python和更多。可选地,可以添加一个标签允许自定义字符串建设,避免注入攻击或从字符串构造更高层次数据结构的内容。 1234567891011121314151617// Basic literal string creation`In JavaScript &#x27;\\n&#x27; is a line-feed.`// Multiline strings`In JavaScript this is not legal.`// String interpolationvar name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`// Construct an HTTP request prefix is used to interpret the replacements and constructionGET`http://foo.org/bar?a=$&#123;a&#125;&amp;b=$&#123;b&#125; Content-Type: application/json X-Credentials: $&#123;credentials&#125; &#123; &quot;foo&quot;: $&#123;foo&#125;, &quot;bar&quot;: $&#123;bar&#125;&#125;`(myOnReadyStateChangeHandler); ES5与ES6对比 12345678910111213//ES5var customer = &#123; name: &quot;Foo&quot; &#125;;var card = &#123; amount: 7, product: &quot;Bar&quot;, unitprice: 42 &#125;;message = &quot;Hello &quot; + customer.name + &quot;,\\n&quot; +&quot;want to buy &quot; + card.amount + &quot; &quot; + card.product + &quot; for\\n&quot; +&quot;a total of &quot; + (card.amount * card.unitprice) + &quot; bucks?&quot;;//ES6var customer = &#123; name: &quot;Foo&quot; &#125;var card = &#123; amount: 7, product: &quot;Bar&quot;, unitprice: 42 &#125;message = `Hello $&#123;customer.name&#125;,want to buy $&#123;card.amount&#125; $&#123;card.product&#125; fora total of $&#123;card.amount * card.unitprice&#125; bucks?` DestructuringDestructuring allows binding using pattern matching, with support for matching arrays and objects. Destructuring is fail-soft, similar to standard object lookup foo[&quot;bar&quot;], producing undefined values when not found. 解构允许绑定使用模式匹配,支持匹配数组和对象。解构是可以让故障弱化,类似于标准对象查找foo(“bar”),生产时没有发现未定义的值‘undefined’。 123456789101112131415161718192021222324// list matchingvar [a, , b] = [1,2,3];// object matchingvar &#123; op: a, lhs: &#123; op: b &#125;, rhs: c &#125; = getASTNode()// object matching shorthand// binds `op`, `lhs` and `rhs` in scopevar &#123;op, lhs, rhs&#125; = getASTNode()// Can be used in parameter positionfunction g(&#123;name: x&#125;) &#123; console.log(x);&#125;g(&#123;name: 5&#125;)// Fail-soft destructuringvar [a] = [];a === undefined;// Fail-soft destructuring with defaultsvar [a = 1] = [];a === 1; ES5与ES6对比 123456789101112131415161718192021222324252627282930313233343536373839404142//ES5var &#123; op: a, lhs: &#123; op: b &#125;, rhs: c &#125; = getASTNode()//ES6var tmp = getASTNode();var a = tmp.op;var b = tmp.lhs.op;var c = tmp.rhs;//ES5function f (arg) &#123; var name = arg[0]; var val = arg[1]; console.log(name, val);&#125;;function g (arg) &#123; var n = arg.name; var v = arg.val; console.log(n, v);&#125;;function h (arg) &#123; var name = arg.name; var val = arg.val; console.log(name, val);&#125;;f([ &quot;bar&quot;, 42 ]);g(&#123; name: &quot;foo&quot;, val: 7 &#125;);h(&#123; name: &quot;bar&quot;, val: 42 &#125;);//ES6function f ([ name, val ]) &#123; console.log(name, val)&#125;function g (&#123; name: n, val: v &#125;) &#123; console.log(n, v)&#125;function h (&#123; name, val &#125;) &#123; console.log(name, val)&#125;f([ &quot;bar&quot;, 42 ])g(&#123; name: &quot;foo&quot;, val: 7 &#125;)h(&#123; name: &quot;bar&quot;, val: 42 &#125;) Default + Rest + SpreadCallee-evaluated default parameter values. Turn an array into consecutive arguments in a function call. Bind trailing parameters to an array. Rest replaces the need for arguments and addresses common cases more directly. Callee-evaluated默认参数值。把一个数组转化为连续函数调用的参数。剩余的参数绑定到一个数组中。其他取代了需要的参数和地址一般情况下更直接。 12345function f(x, y=12) &#123; // y is 12 if not passed (or passed as undefined) return x + y;&#125;f(3) == 15 12345function f(x, ...y) &#123; // y is an Array return x * y.length;&#125;f(3, &quot;hello&quot;, true) == 6 12345function f(x, y, z) &#123; return x + y + z;&#125;// Pass each elem of array as argumentf(...[1,2,3]) == 6 ES5与ES6对比 123456789101112131415//ES5var params = [ &quot;hello&quot;, true, 7 ];var other = [ 1, 2 ].concat(params); // [ 1, 2, &quot;hello&quot;, true, 7 ]f.apply(undefined, [ 1, 2 ].concat(params)) === 9;var str = &quot;foo&quot;;var chars = str.split(&quot;&quot;); // [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ]//ES6var params = [ &quot;hello&quot;, true, 7 ]var other = [ 1, 2, ...params ] // [ 1, 2, &quot;hello&quot;, true, 7 ]f(1, 2, ...params) === 9var str = &quot;foo&quot;var chars = [ ...str ] // [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ] Let + ConstBlock-scoped binding constructs. let is the new var. const is single-assignment. Static restrictions prevent use before assignment. Block-scoped绑定结构。let”是新的“var”。“常量”是单一赋值消息快。静态限制防止作业之前使用。 12345678910111213function f() &#123; &#123; let x; &#123; // okay, block scoped name const x = &quot;sneaky&quot;; // error, const x = &quot;foo&quot;; &#125; // error, already declared in block let x = &quot;inner&quot;; &#125;&#125; ES5与ES6对比 123456789101112//ES5Object.defineProperty(typeof global === &quot;object&quot; ? global : window, &quot;PI&quot;, &#123; value: 3.141593, enumerable: true, writable: false, configurable: false&#125;)PI &gt; 3.0;//ES6const PI = 3.141593PI &gt; 3.0 Iterators + For..OfIterator objects enable custom iteration like CLR IEnumerable or Java Iterable. Generalize for..in to custom iterator-based iteration with for..of. Don’t require realizing an array, enabling lazy design patterns like LINQ. 迭代器对象启用自定义迭代就像CLR IEnumerable或Java Iterable。概括的. .概括来说它就是将‘fo..in’等循环用‘for..of’来写。不需要实现一个数组,使懒惰像LINQ设计模式。 123456789101112131415161718let fibonacci = &#123; [Symbol.iterator]() &#123; let pre = 0, cur = 1; return &#123; next() &#123; [pre, cur] = [cur, pre + cur]; return &#123; done: false, value: cur &#125; &#125; &#125; &#125;&#125;for (var n of fibonacci) &#123; // truncate the sequence at 1000 if (n &gt; 1000) break; console.log(n);&#125; Iteration is based on these duck-typed interfaces (using TypeScript type syntax for exposition only): 12345678910interface IteratorResult &#123; done: boolean; value: any;&#125;interface Iterator &#123; next(): IteratorResult;&#125;interface Iterable &#123; [Symbol.iterator](): Iterator&#125; ES5与ES6对比 123456789101112131415161718192021222324252627282930313233343536373839//ES5var fibonacci = &#123; next: ((function () &#123; var pre = 0, cur = 1; return function () &#123; tmp = pre; pre = cur; cur += tmp; return cur; &#125;; &#125;)();&#125;;var n;for (;;) &#123; n = fibonacci.next(); if (n &gt; 1000) break; console.log(n);&#125;//ES6let fibonacci = &#123; [Symbol.iterator]() &#123; let pre = 0, cur = 1 return &#123; next () &#123; [ pre, cur ] = [ cur, pre + cur ] return &#123; done: false, value: cur &#125; &#125; &#125; &#125;&#125;for (let n of fibonacci) &#123; if (n &gt; 1000) break console.log(n)&#125; GeneratorsGenerators simplify iterator-authoring using function* and yield. A function declared as function* returns a Generator instance. Generators are subtypes of iterators which include additional next and throw. These enable values to flow back into the generator, so yield is an expression form which returns a value (or throws). 生成器简化iterator-authoring使用“function”和“yield”。一个函数声明为函数返回一个生成器实例。生成器是迭代器的子类型,包括额外的“next”和“throw”。这可使用的值回流到生成器,因此“产量”是一种表达形式返回一个值(或抛出)。 Note: Can also be used to enable ‘await’-like async programming, see also ES7 await proposal. 123456789101112131415161718var fibonacci = &#123; [Symbol.iterator]: function*() &#123; var pre = 0, cur = 1; for (;;) &#123; var temp = pre; pre = cur; cur += temp; yield cur; &#125; &#125;&#125;for (var n of fibonacci) &#123; // truncate the sequence at 1000 if (n &gt; 1000) break; console.log(n);&#125; The generator interface is (using TypeScript type syntax for exposition only): 1234interface Generator extends Iterator &#123; next(value?: any): IteratorResult; throw(exception: any);&#125; ES5与ES6对比 1234567891011121314151617181920212223242526//ES5function range (start, end, step) &#123; var list = []; while (start &lt; end) &#123; list.push(start); start += step; &#125; return list;&#125;var r = range(0, 10, 2);for (var i = 0; i &lt; r.length; i++) &#123; console.log(r[i]); // 0, 2, 4, 6, 8&#125;//ES6function* range (start, end, step) &#123; while (start &lt; end) &#123; yield start start += step &#125;&#125;for (let i of range(0, 10, 2)) &#123; console.log(i) // 0, 2, 4, 6, 8&#125; UnicodeNon-breaking additions to support full Unicode, including new Unicode literal form in strings and new RegExp u mode to handle code points, as well as new APIs to process strings at the 21bit code points level. These additions support building global apps in JavaScript. 可以帮助增加完整的Unicode的支持,包括新的Unicode字符串中的文字形式和新的正则表达式处理代码点“u”模式,以及新的api来处理字符串在21位代码点水平。这些添加支持建立全球JavaScript应用程序。 12345678910111213141516// same as ES5.1&quot;𠮷&quot;.length == 2// new RegExp behaviour, opt-in ‘u’&quot;𠮷&quot;.match(/./u)[0].length == 2// new form&quot;\\u&#123;20BB7&#125;&quot;==&quot;𠮷&quot;==&quot;\\uD842\\uDFB7&quot;// new String ops&quot;𠮷&quot;.codePointAt(0) == 0x20BB7// for-of iterates code pointsfor(var c of &quot;𠮷&quot;) &#123; console.log(c);&#125; ES5与ES6对比 123456789//ES5&quot;𠮷&quot;.length === 2;&quot;𠮷&quot;.match(/(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF][\\uD800-\\uDBFF][\\uDC00-\\uDFFF][\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])(?:[^\\uD800-\\uDBFF]^)[\\uDC00-\\uDFFF])/)[0].length === 2;&quot;𠮷&quot; === &quot;\\uD842\\uDFB7&quot;;//ES6&quot;𠮷&quot;.length === 2&quot;𠮷&quot;.match(/./u)[0].length === 2&quot;\\u&#123;20BB7&#125;&quot; === &quot;𠮷&quot; === &quot;\\uD842\\uDFB7&quot; ModulesLanguage-level support for modules for component definition. Codifies patterns from popular JavaScript module loaders (AMD, CommonJS). Runtime behaviour defined by a host-defined default loader. Implicitly async model – no code executes until requested modules are available and processed. 为组件定义语言级支持模块。汇总模式从流行的JavaScript模块加载器(AMD,CommonJS)。运行时行为由host-defined定义默认加载程序。隐式异步模型——没有代码执行,直到请求模块是可用的和加工。 12345// lib/math.jsexport function sum(x, y) &#123; return x + y;&#125;export var pi = 3.141593; 123// app.jsimport * as math from &quot;lib/math&quot;;alert(&quot;2π = &quot; + math.sum(math.pi, math.pi)); 123// otherApp.jsimport &#123;sum, pi&#125; from &quot;lib/math&quot;;alert(&quot;2π = &quot; + sum(pi, pi)); Some additional features include export default and export *: 123456// lib/mathplusplus.jsexport * from &quot;lib/math&quot;;export var e = 2.71828182846;export default function(x) &#123; return Math.log(x);&#125; 123// app.jsimport ln, &#123;pi, e&#125; from &quot;lib/mathplusplus&quot;;alert(&quot;2π = &quot; + ln(e)*pi*2); ES5与ES6对比 123456789101112131415161718192021//ES5LibMathPP = &#123;&#125;;for (symbol in LibMath) if (LibMath.hasOwnProperty(symbol)) LibMathPP[symbol] = LibMath[symbol];LibMathPP.e = 2.71828182846;LibMathPP.exp = function (x) &#123; return Math.exp(x) &#125;;// someApp.jsvar exp = LibMathPP.exp, pi = LibMathPP.pi, e = libMathPP.e;console.log(&quot;e^&#123;π&#125; = &quot; + exp(pi));//ES6export * from &quot;lib/math&quot;export var e = 2.71828182846export default (x) =&gt; Math.exp(x)// someApp.jsimport exp, &#123; pi, e &#125; from &quot;lib/mathplusplus&quot;console.log(&quot;e^&#123;π&#125; = &quot; + exp(pi)) Module LoadersModule loaders support: Dynamic loading State isolation Global namespace isolation Compilation hooks Nested virtualization The default module loader can be configured, and new loaders can be constructed to evaluate and load code in isolated or constrained contexts. 默认模块加载器可以配置,可以评估和构造新的加载器加载代码隔离或语境的限制。 1234567891011121314// Dynamic loading – ‘System’ is default loaderSystem.import(&#x27;lib/math&#x27;).then(function(m) &#123; alert(&quot;2π = &quot; + m.sum(m.pi, m.pi));&#125;);// Create execution sandboxes – new Loadersvar loader = new Loader(&#123; global: fixup(window) // replace ‘console.log’&#125;);loader.eval(&quot;console.log(&#x27;hello world!&#x27;);&quot;);// Directly manipulate module cacheSystem.get(&#x27;jquery&#x27;);System.set(&#x27;jquery&#x27;, Module(&#123;$: $&#125;)); // WARNING: not yet finalized Map + Set + WeakMap + WeakSetEfficient data structures for common algorithms. WeakMaps provides leak-free object-key’d side tables. 数据结构常用算法效率。WeakMaps提供对象键索引表。 123456789101112131415161718192021// Setsvar s = new Set();s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);s.size === 2;s.has(&quot;hello&quot;) === true;// Mapsvar m = new Map();m.set(&quot;hello&quot;, 42);m.set(s, 34);m.get(s) == 34;// Weak Mapsvar wm = new WeakMap();wm.set(s, &#123; extra: 42 &#125;);wm.size === undefined// Weak Setsvar ws = new WeakSet();ws.add(&#123; data: 42 &#125;);// Because the added object has no other references, it will not be held in the set ES5与ES6对比 123456789101112131415161718192021//ES5var m = &#123;&#125;;m[&quot;hello&quot;] = 42;// no equivalent in ES5// no equivalent in ES5Object.keys(m).length === 2;for (key in m) &#123; if (m.hasOwnProperty(key)) &#123; var val = m[key]; console.log(key + &quot; = &quot; + val); &#125;&#125;//ES6let m = new Map()m.set(&quot;hello&quot;, 42)m.set(s, 34)m.get(s) === 34m.size === 2for (let [ key, val ] of m.entries()) console.log(key + &quot; = &quot; + val) ProxiesProxies enable creation of objects with the full range of behaviors available to host objects. Can be used for interception, object virtualization, logging/profiling, etc. 代理启用创建对象的全部行为可用主机对象。可用于拦截、对象虚拟化,日志/分析等,这是一个新功能。 12345678910// Proxying a normal objectvar target = &#123;&#125;;var handler = &#123; get: function (receiver, name) &#123; return `Hello, $&#123;name&#125;!`; &#125;&#125;;var p = new Proxy(target, handler);p.world === &#x27;Hello, world!&#x27;; 12345678910// Proxying a function objectvar target = function () &#123; return &#x27;I am the target&#x27;; &#125;;var handler = &#123; apply: function (receiver, ...args) &#123; return &#x27;I am the proxy&#x27;; &#125;&#125;;var p = new Proxy(target, handler);p() === &#x27;I am the proxy&#x27;; There are traps available for all of the runtime-level meta-operations: 1234567891011121314151617var handler =&#123; get:..., set:..., has:..., deleteProperty:..., apply:..., construct:..., getOwnPropertyDescriptor:..., defineProperty:..., getPrototypeOf:..., setPrototypeOf:..., enumerate:..., ownKeys:..., preventExtensions:..., isExtensible:...&#125; SymbolsSymbols enable access control for object state. Symbols allow properties to be keyed by either string (as in ES5) or symbol. Symbols are a new primitive type. Optional name parameter used in debugging - but is not part of identity. Symbols are unique (like gensym), but not private since they are exposed via reflection features like Object.getOwnPropertySymbols. 符号启用访问控制对象状态。符号允许键属性的“string”(如ES5)或“symbol”。符号是一个新的原始类型。可选的“name”参数用于调试——但不是身份的一部分。符号是独一无二的(比如gensym),而不是个人,因为他们是通过反射特性,如“Object.getOwnPropertySymbols”。这是也是一个新功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var MyClass = (function() &#123; // module scoped symbol var key = Symbol(&quot;key&quot;); function MyClass(privateData) &#123; this[key] = privateData; &#125; MyClass.prototype = &#123; doStuff: function() &#123; ... this[key] ... &#125; &#125;; return MyClass;&#125;)();var c = new MyClass(&quot;hello&quot;)c[&quot;key&quot;] === undefined### Subclassable Built-insIn ES6, built-ins like `Array`, `Date` and DOM `Element`s can be subclassed.Object construction for a function named `Ctor` now uses two-phases (both virtually dispatched):- Call `Ctor[@@create]` to allocate the object, installing any special behavior- Invoke constructor on new instance to initializeThe known `@@create` symbol is available via `Symbol.create`. Built-ins now expose their `@@create` explicitly.在ES6,应有尽有,如“Array”,“Date”和DOM&quot;Element&quot;的可以派生子类。 对象构造函数名为“Ctor”现在使用两(几乎两派):- 称之为“Ctor(@@create)的分配对象,安装任何特殊的行为- 新实例上调用构造函数来初始化 已知的“@@create”符号是可以通过“Symbol.create”。内置模板现在公开他们的@@create明确。```JavaScript// Pseudo-code of Arrayclass Array &#123; constructor(...args) &#123; /* ... */ &#125; static [Symbol.create]() &#123; // Install special [[DefineOwnProperty]] // to magically update &#x27;length&#x27; &#125;&#125;// User code of Array subclassclass MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;// Two-phase &#x27;new&#x27;:// 1) Call @@create to allocate object// 2) Invoke constructor on new instancevar arr = new MyArray();arr[1] = 12;arr.length == 2 ES5与ES6对比 1234567891011//ES5var obj = &#123; a: 1 &#125;;Object.defineProperty(obj, &quot;b&quot;, &#123; value: 2 &#125;);// no equivalent in ES5Object.getOwnPropertyNames(obj); // [ &quot;a&quot;, &quot;b&quot; ]//ES6let obj = &#123; a: 1 &#125;Object.defineProperty(obj, &quot;b&quot;, &#123; value: 2 &#125;)obj[Symbol(&quot;c&quot;)] = 3Reflect.ownKeys(obj) // [ &quot;a&quot;, &quot;b&quot;, Symbol(c) ] Math + Number + String + Array + Object APIsMany new library additions, including core Math libraries, Array conversion helpers, String helpers, and Object.assign for copying. 许多新图书馆补充,包括核心数学库,数组转换帮手,字符串助手,和对象。分配进行复制。 12345678910111213141516171819202122Number.EPSILONNumber.isInteger(Infinity) // falseNumber.isNaN(&quot;NaN&quot;) // falseMath.acosh(3) // 1.762747174039086Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2&quot;abcde&quot;.includes(&quot;cd&quot;) // true&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;Array.from(document.querySelectorAll(&#x27;*&#x27;)) // Returns a real ArrayArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior[0, 0, 0].fill(7, 1) // [0,7,7][1, 2, 3].find(x =&gt; x == 3) // 3[1, 2, 3].findIndex(x =&gt; x == 2) // 1[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;Object.assign(Point, &#123; origin: new Point(0,0) &#125;) Binary and Octal LiteralsTwo new numeric literal forms are added for binary (b) and octal (o). 添加两个新的数值文字形式为二进制(“b”)和八进制(“o”)。 120b111110111 === 503 // true0o767 === 503 // true ES5与ES6对比 12345678//ES5parseInt(&quot;111110111&quot;, 2) === 503;parseInt(&quot;767&quot;, 8) === 503;0767 === 503; // only in non-strict, backward compatibility mode//ES60b111110111 === 5030o767 === 503 PromisesPromises are a library for asynchronous programming. Promises are a first class representation of a value that may be made available in the future. Promises are used in many existing JavaScript libraries. 承诺模式是异步编程库。承诺是一个一个流的表示的值可能会在未来使用。承诺模式用于许多现有的JavaScript库。 12345678910111213function timeout(duration = 0) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, duration); &#125;)&#125;var p = timeout(1000).then(() =&gt; &#123; return timeout(2000);&#125;).then(() =&gt; &#123; throw new Error(&quot;hmm&quot;);&#125;).catch(err =&gt; &#123; return Promise.all([timeout(100), timeout(200)]);&#125;) ES5与ES6对比 1234567891011121314151617181920212223//ES5function msgAfterTimeout (msg, who, timeout, onDone) &#123; setTimeout(function () &#123; onDone(msg + &quot; Hello &quot; + who + &quot;!&quot;); &#125;, timeout);&#125;msgAfterTimeout(&quot;&quot;, &quot;Foo&quot;, 100, function (msg) &#123; msgAfterTimeout(msg, &quot;Bar&quot;, 200, function (msg) &#123; console.log(&quot;done after 300ms:&quot; + msg); &#125;);&#125;);//ES6function msgAfterTimeout (msg, who, timeout) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(`$&#123;msg&#125; Hello $&#123;who&#125;!`), timeout) &#125;)&#125;msgAfterTimeout(&quot;&quot;, &quot;Foo&quot;, 100).then((msg) =&gt; msgAfterTimeout(msg, &quot;Bar&quot;, 200)).then((msg) =&gt; &#123; console.log(`done after 300ms:$&#123;msg&#125;`)&#125;) Reflect APIFull reflection API exposing the runtime-level meta-operations on objects. This is effectively the inverse of the Proxy API, and allows making calls corresponding to the same meta-operations as the proxy traps. Especially useful for implementing proxies. 完整的反射API公开运行时级meta-operations对象。这是一个有效的反向代理的API,并声明对应相同的meta-operations代理陷阱。实现代理尤其有用。 ES5与ES6对比 1234567891011//ES5var obj = &#123; a: 1 &#125;;Object.defineProperty(obj, &quot;b&quot;, &#123; value: 2 &#125;);// no equivalent in ES5Object.getOwnPropertyNames(obj); // [ &quot;a&quot;, &quot;b&quot; ]//ES6let obj = &#123; a: 1 &#125;Object.defineProperty(obj, &quot;b&quot;, &#123; value: 2 &#125;)obj[Symbol(&quot;c&quot;)] = 3Reflect.ownKeys(obj) // [ &quot;a&quot;, &quot;b&quot;, Symbol(c) ] Tail CallsCalls in tail-position are guaranteed to not grow the stack unboundedly. Makes recursive algorithms safe in the face of unbounded inputs. 在尾部调用保证不是堆栈无限制地增长。使得在面对无限递归算法安全投入。 123456789function factorial(n, acc = 1) &#123; &#x27;use strict&#x27;; if (n &lt;= 1) return acc; return factorial(n - 1, n * acc);&#125;// Stack overflow in most implementations today,// but safe on arbitrary inputs in ES6factorial(100000)","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://blog.jddfe.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"https://blog.jddfe.com/tags/JS/"}]},{"title":"Git常用命令备忘手册","slug":"Git常用命令备忘手册","date":"2016-03-10T12:55:10.000Z","updated":"2020-11-17T12:54:33.329Z","comments":true,"path":"posts/60855/","link":"","permalink":"https://blog.jddfe.com/posts/60855/","excerpt":"","text":"git配置 123456789git config --global user.name &quot;robbin&quot; git config --global user.email &quot;fankai@gmail.com&quot;git config --global color.ui truegit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.br branchgit config --global core.editor &quot;mate -w&quot; # 设置Editor使用textmategit config -l # 列举所有配置 git常用命令:查看、添加、提交、删除、找回，重置修改文件** 1234567891011121314151617181920212223242526git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci .git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am &quot;some comments&quot;git ci --amend # 修改最后一次提交记录git commit --amend #修改最后一次提交注释的，利用–amend参数 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diff** 1234567git diff &lt;file&gt; # 比较当前文件和暂存区文件差异git diffgit diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较 git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息 查看提交记录** 12345git loggit log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat # 查看提交统计信息 gitgit 本地分支管理查看、切换、创建和删除分支 123456789101112131415git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase** 12345git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin&#x2F;master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于：git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; git补丁管理(方便在多台机器上开发同步时用)1234git diff &gt; ..&#x2F;sync.patch # 生成补丁git apply ..&#x2F;sync.patch # 打补丁git apply --check ..&#x2F;sync.patch # 测试补丁能否成功 git暂存管理 1234git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区 git远程分支管理 12345678910111213git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin&#x2F;master # 将远程主分支合并到本地当前分支git co --track origin&#x2F;branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin&#x2F;&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 git远程仓库管理 12345git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@github:robbin&#x2F;robbin_site.git # 添加远程仓库地址git remote set-url origin git@github.com:robbin&#x2F;robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址)git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库 123456789git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@github.com:robbin&#x2F;robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库 12git branch --set-upstream master origin&#x2F;mastergit branch --set-upstream develop origin&#x2F;develop","categories":[{"name":"Git","slug":"Git","permalink":"https://blog.jddfe.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.jddfe.com/tags/Git/"}]},{"title":"Hexo5分钟搞定你的个人博客","slug":"Hexo5分钟搞定你的个人博客","date":"2016-02-28T12:26:41.000Z","updated":"2020-11-17T13:04:09.906Z","comments":true,"path":"posts/42939/","link":"","permalink":"https://blog.jddfe.com/posts/42939/","excerpt":"","text":"新年快乐，祝所有猿类们新的一年撸代码无bug！！！ 新的一年，一切重新开始，重新折腾起来。Hexo 刚有发布了新版本，今天我们一起来通过Hexo快速搭建个人博客，并发布到 github。 废话不多说，进入正题。 开始前提： 安装 Node.js 安装Git 新建仓库github 新建一个仓库，仓库名必须为 &lt; user-name &gt;.github.io 格式，其中 &lt; user-name &gt; 是你 github 的昵称。不要问我为什么，问了也不想告诉你。 全局安装hexo如果你连 npm 是啥都不知道，那对不起，你走吧。 等等等…开个玩笑，有啥问题可以留言。打开命令行，输入下面的命令，全局安装 hexo。 1npm install -g hexo 初始化项目hexo init，就会自动构建一个 hexo 项目，紧接着执行 hexo s，浏览器访问 localhost:4000 就可以看到效果啦！过程一定要快，凉了就不好吃了！ 12345&#x2F;&#x2F; 初始化hexo init &#x2F;&#x2F; 本地运行hexo s 部署到Github在项目根目录下找到 _congif.yml，找到 deploy 字段并填写完整 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy: type: git repo: &lt;你的仓库地址&gt; # https:&#x2F;&#x2F;github.com&#x2F;jddfe&#x2F;jddfe.github.io branch: master 虽然只有一份 Hello World，但是我也想让全世界的人看到，成为最闪耀的那个崽。接下来请开始你最擅长的事情：抄！ 有了自己的内容后，需要额外的一个工具来帮助我们推到仓库上，就是 hexo-deployer-git。 1npm install hexo-deployer-git --save 好了，见证奇迹的时候 12345678&#x2F;&#x2F; 清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo clean&#x2F;&#x2F; 生成静态文件，可简写 hexo ghexo generate&#x2F;&#x2F; 发布，简写 hexo dhexo deploy 查看效果至此，已经完成了个人博客的搭建，可以在浏览器中访问： https://jddfe.github.io 其他hexo使用请参见官方文档","categories":[{"name":"折腾不止","slug":"折腾不止","permalink":"https://blog.jddfe.com/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"}],"tags":[{"name":"Hexo GitPage","slug":"Hexo-GitPage","permalink":"https://blog.jddfe.com/tags/Hexo-GitPage/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"吃瓜","slug":"吃瓜","permalink":"https://blog.jddfe.com/categories/%E5%90%83%E7%93%9C/"},{"name":"每日最佳","slug":"每日最佳","permalink":"https://blog.jddfe.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%80%E4%BD%B3/"},{"name":"懂理财","slug":"懂理财","permalink":"https://blog.jddfe.com/categories/%E6%87%82%E7%90%86%E8%B4%A2/"},{"name":"折腾不止","slug":"折腾不止","permalink":"https://blog.jddfe.com/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"},{"name":"Git","slug":"Git","permalink":"https://blog.jddfe.com/categories/Git/"}],"tags":[{"name":"前端安全 XSS","slug":"前端安全-XSS","permalink":"https://blog.jddfe.com/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8-XSS/"},{"name":"vue 学习笔记","slug":"vue-学习笔记","permalink":"https://blog.jddfe.com/tags/vue-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"工具","slug":"工具","permalink":"https://blog.jddfe.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"ES6","slug":"ES6","permalink":"https://blog.jddfe.com/tags/ES6/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://blog.jddfe.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"},{"name":"蛋壳公寓爆雷","slug":"蛋壳公寓爆雷","permalink":"https://blog.jddfe.com/tags/%E8%9B%8B%E5%A3%B3%E5%85%AC%E5%AF%93%E7%88%86%E9%9B%B7/"},{"name":"微众银行","slug":"微众银行","permalink":"https://blog.jddfe.com/tags/%E5%BE%AE%E4%BC%97%E9%93%B6%E8%A1%8C/"},{"name":"一马币案","slug":"一马币案","permalink":"https://blog.jddfe.com/tags/%E4%B8%80%E9%A9%AC%E5%B8%81%E6%A1%88/"},{"name":"道德经","slug":"道德经","permalink":"https://blog.jddfe.com/tags/%E9%81%93%E5%BE%B7%E7%BB%8F/"},{"name":"每日最佳","slug":"每日最佳","permalink":"https://blog.jddfe.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%80%E4%BD%B3/"},{"name":"全民摆摊","slug":"全民摆摊","permalink":"https://blog.jddfe.com/tags/%E5%85%A8%E6%B0%91%E6%91%86%E6%91%8A/"},{"name":"基金","slug":"基金","permalink":"https://blog.jddfe.com/tags/%E5%9F%BA%E9%87%91/"},{"name":"定投","slug":"定投","permalink":"https://blog.jddfe.com/tags/%E5%AE%9A%E6%8A%95/"},{"name":"投资","slug":"投资","permalink":"https://blog.jddfe.com/tags/%E6%8A%95%E8%B5%84/"},{"name":"防抖","slug":"防抖","permalink":"https://blog.jddfe.com/tags/%E9%98%B2%E6%8A%96/"},{"name":"节流","slug":"节流","permalink":"https://blog.jddfe.com/tags/%E8%8A%82%E6%B5%81/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.jddfe.com/tags/Hexo/"},{"name":"Github Page","slug":"Github-Page","permalink":"https://blog.jddfe.com/tags/Github-Page/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Javascript","slug":"Javascript","permalink":"https://blog.jddfe.com/tags/Javascript/"},{"name":"闭包","slug":"闭包","permalink":"https://blog.jddfe.com/tags/%E9%97%AD%E5%8C%85/"},{"name":"栈和堆","slug":"栈和堆","permalink":"https://blog.jddfe.com/tags/%E6%A0%88%E5%92%8C%E5%A0%86/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.jddfe.com/tags/javascript/"},{"name":"事件","slug":"事件","permalink":"https://blog.jddfe.com/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"event","slug":"event","permalink":"https://blog.jddfe.com/tags/event/"},{"name":"原型链","slug":"原型链","permalink":"https://blog.jddfe.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"面向对象","slug":"面向对象","permalink":"https://blog.jddfe.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"rem","slug":"rem","permalink":"https://blog.jddfe.com/tags/rem/"},{"name":"css","slug":"css","permalink":"https://blog.jddfe.com/tags/css/"},{"name":"适配","slug":"适配","permalink":"https://blog.jddfe.com/tags/%E9%80%82%E9%85%8D/"},{"name":"JS","slug":"JS","permalink":"https://blog.jddfe.com/tags/JS/"},{"name":"Git","slug":"Git","permalink":"https://blog.jddfe.com/tags/Git/"},{"name":"Hexo GitPage","slug":"Hexo-GitPage","permalink":"https://blog.jddfe.com/tags/Hexo-GitPage/"}]}