{"meta":{"title":"JDDFE","subtitle":"just do devFE","description":"简单的前端","author":"Esmiler","url":"https://blog.jddfe.com","root":"/"},"pages":[{"title":"书单","date":"2020-11-09T13:38:40.331Z","updated":"2020-11-09T06:37:15.850Z","comments":false,"path":"books/index.html","permalink":"https://blog.jddfe.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-11-09T13:40:17.085Z","updated":"2020-11-09T06:37:15.850Z","comments":true,"path":"links/index.html","permalink":"https://blog.jddfe.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-10T12:10:26.148Z","updated":"2020-11-09T06:37:15.850Z","comments":false,"path":"categories/index.html","permalink":"https://blog.jddfe.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-10T16:49:26.393Z","updated":"2020-11-09T06:37:15.851Z","comments":false,"path":"tags/index.html","permalink":"https://blog.jddfe.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-15T15:10:40.645Z","updated":"2020-11-15T15:10:40.645Z","comments":false,"path":"about/index.html","permalink":"https://blog.jddfe.com/about/index.html","excerpt":"","text":"1234567891011121314151617181920212223242526&#123; name: &#x27;jddfer&#x27; profession: &#x27;写代码，学理财，没事经常吃吃瓜！！！&#x27;, address: &#x27;帝都&#x27;, github: &#x27;https://github.com/jddfe&#x27;, blog: &#x27;http://blog.jddfe.com&#x27;, email: &#x27;jddfe_com@163.com&#x27;, description: &#x27;不懂理财的吃瓜群众不是好攻城狮~&#x27;, skills: [ [&#x27;Html&#x27;, &#x27;Javascript&#x27;, &#x27;jQuery&#x27;, &#x27;CSS&#x27;, &#x27;ES6&#x27;, &#x27;Node&#x27;], [&#x27;Webpack&#x27;, &#x27;Gulp&#x27;], [&#x27;Less&#x27;,&#x27;Sass&#x27;], [&#x27;Git&#x27;, &#x27;SVN&#x27;], [&#x27;Vue&#x27;], [&#x27;平面设计&#x27;, &#x27;产品设计&#x27;] ], devTools: [ [&#x27;Sublime Text&#x27;, &#x27;Visual Studio Code&#x27;, &#x27;WebStorm&#x27;], [&#x27;Chrome DevTools&#x27;, &#x27;Fiddler&#x27;, &#x27;Charles&#x27;], [&#x27;SourceTree&#x27;, &#x27;TortoiseSVN&#x27;], [&#x27;SwitchHosts&#x27;], [&#x27;Navicat&#x27;, &#x27;XAMPP&#x27;], ] &#125;"},{"title":"","date":"2020-11-15T15:05:10.472Z","updated":"2020-11-15T15:05:10.472Z","comments":true,"path":"tmp-bak.html","permalink":"https://blog.jddfe.com/tmp-bak.html","excerpt":"","text":"关于介绍不是一个人（不是人），而是一个组织。招募热爱前端开发及用户体验设计，喜欢新事物，关注前端动态，对新的技术有追求， 喜欢产品，喜欢Coding 的你一起加入。"}],"posts":[{"title":"基金投资新手入门科普宝典","slug":"基金投资新手入门科普宝典","date":"2020-11-14T15:06:10.000Z","updated":"2020-11-16T16:10:55.404Z","comments":true,"path":"2020/11/14/基金投资新手入门科普宝典/","link":"","permalink":"https://blog.jddfe.com/2020/11/14/%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E7%A7%91%E6%99%AE%E5%AE%9D%E5%85%B8/","excerpt":"","text":"网上关于基金投资教学的文章有很多，但都太过于专业，太过于繁琐，今天就用简单直白的内容重新认识基金。 直接告诉你 怎么买、买多少、怎么卖 开始前先了解下基金的分类 基金的分类注：以下提到的收益率为有专业操作经验的普通投资者的近一年预估收益率。 货币型基金：是以银行存款，短期债券保本型产品为主的类型，一般收益在 2.5%-3.5% 低风险，比如我们常用的余额宝和天天基金的活期宝，适合1年内的资金打理，随取随用。 债券型基金：成分80%以上是国债和企业债，收益在6%-8%，中风险，纯债基金100%投资于债券，不碰股票。特点是波动小，收益比较稳定。适合1-2年资金的打理。 混合型基金：成分现金、债券、股票都有，进可攻退可守，非常灵活，收益在10%-13%中高风险 股票型基金：成分80%以上是股票，收益在12%-30%+，高风险。 指数型基金（被动型基金）：不主动寻求取得超越市场的表现，而是试图复制指数的表现。一般选取特定的指数作为跟踪的对象，因此通常又被称为“指数型基金”。相当于在股票市场上，把每种股票都买一点，最后追求一个市场平均收益率的基金。 ＥＴＦ：交易型开放指数基金，通常又称为“交易所交交易基金”，是一种在交易所上市交易的、基金份额可变的一种开放式基金。 ＬＯＦ：上市开放式基金，是一种既可以在场外市场进行基金份额申购赎回，又可以在交易所（场内市场）进行基金份额交易和基金反而二申购或赎回的开放式基金。是我国对证券投资基金的一种本土化创新。 国内的一些指数 上证50指数：就是把上交所规模最大、流动性最好的50家公司的股票组合在一起。 沪深300指数：就是把上交所和深交所前300只规模最大、流动最好的300家公司的股票组合在一起。 中证500指数：把沪深300指数的前300家大公司排除，剩下的大公司中再选前500只规模最大、流动最好的500家公司的股票统计起来的股票组合在一起。 上证红利指数：从上交所的股票中，挑选现金分红最高的 50 家公司股票组合在一起。 时间越长，分红越高。 创业板指数：限制了成分股的数量，只从创业板上市公司中，挑选出规模最大、流动性最好的100只股票。 接下来直接进入主题，这里就不介绍平台和开户相关前提了 一、怎么买？基金投资的第一步就是选到优秀并且适合自己的基金，上面介绍了基金的分类了，那接下来直接说说如何选基金。 长期投资建议：混合型基金和股票型基金，其次债券型基金 接下来，解释一下原因： （1）货币型基金首先排除掉余额宝等货币型基金，因为收益率过低，甚至跑不赢通货膨胀，不予考虑。 （2）债券型基金债券型基金在一年期内，取得正收益率的概率大于股票型基金，但是其长期和平均收益率要远低于股票型基金。 如果选择长期投资自然是股票型基金更适合。 （3）主动型与被动型基金取舍了股票型和债券型，我们接下来看看股票型基金、混合型基金（二者统称为主动型基金）与指数基金（被动型基金）的对比。 巴菲特说过：“一个什么都不懂的投资者，通过定投指数型基金，就可以战胜大多数的专业投资者。” 这句话确实是金玉良言，但是那是在美国的市场上。 美国市场处于机构博弈的状态，就是基金和基金打架，能从中脱颖而出，战胜大盘平均成绩的基金自然是不多； 但是在中国市场上，是机构和散户博弈，目前市场上近7成的交易量由散户提供，那些基金工作机构相对于散户来说，处于信息和技术层面的绝对优势， 我们再看看数据统计： 被许多人吹捧的指数型基金的年化收益率甚至低于债券基金，并且风险（波动率）还要更大。 如果在中国你选择了指数基金，那就是实实在在的损失掉了一部分收益。 好了，现在我们知道自己要买的是股票型基金和混合型基金了，那么接下来我们该怎么细选呢？ 毕竟这两种基金可有将近4000多只，我们怎么样才能选到那些能给我们带来长期稳定收益的基金呢？ 既然说了是最直白的教程，那在这里就应该直接给大家一份名单，直截了当的告诉你，哪些基金是“陈年好基” 我在这篇回答里，为你直接列举了中国最优秀的基金经理和他们的代表基金（全部都是经过5年以上牛熊市考验的老牌基金，长期平均年化收益率15%以上），并且附有自主选择基金的方法： 链接：国内优秀基金经理及其代表基金推荐 （4）购买方式好了，选择好基金后，我们就要开始购买了，那哪种购买方式最适合我们呢？ 在讲这个问题前，我们要简单的说一下定投的原理： 为了你更好地理解，请你陪我算一道很简单的计算题。 假如我们去菜市场买西红柿，每次买3000元，买三次。第一次买的价格是1.5元1斤，第二次是1元1斤，第三次是0.5元一斤 问：买完3次后，你手中的西红柿成本是几元1斤？ 你可能就要说1元对吧，那让我们来仔细算算这笔账，一共买了3次，花了9000元，第一次买了2000斤，第二次买了3000斤，第三次买了6000斤 细心的朋友到这里就发现了，实际上我们花了9000元，却买了11000斤西红柿。 当西红柿回到1元1斤时，总的来说虽然西红柿的价格没有上涨，但我们还是可以净赚2000元， 这就是定投的魔力。 定投好处就在于①可以在低位时吸收更多筹码②克服人追涨杀跌的天性，规定买入时间。 注意事项： 1、基金的选择和蔬菜一样也讲究荤素搭配、营养全面，我们不能只吃一样，建议你持有4-8只，就可以避免因为一个基金出现问题，而影响我们整体的收益率。 2、不要买支付宝等软件主页面上推荐的基金，被推荐的基金都是在近期涨幅很大，看起来很诱人的基金，但是近期涨幅过大并不是好事，说明两个问题： ①基金经理风格偏激进 ②该基金最近处于高位，后期很大可能跌落。所以一般购买这类基金，有很大的概率是当了接盘侠。 二、买多少那么我们究竟应该买入多少呢？为了充分考虑到所有人，这里我分情况来说，请大家直接看适合自己的那部分即可。 1、学生 从现在开始，给自己定一个长期目标，明确标出每个月需要攒下来的钱。然后每月通过兼职或者从生活费中节省下来该金额。 很多人会说学生不可以理财，钱少不可以理财，现在理财看似只能赚个几十，并且还有一定风险。 但其实不然，如果你能从现在开始积累理财经验，那这对你的后半生会是一个取之不尽的财富。 毕竟劳动无法致富，普通人财务自由的最佳方式，就是早点开始理财。 2、上班族 将自己收入的10%攒下来，定投到你的基金组合当中， 如果你想拥有被动收入，并在未来的某一天脱离这种早出晚归的上班生活的话，建议你从现在开始播种理财。 同样的给自己列一个计划表，有了计划，我们才能一步一步的去实践。 3、有一定/目标压力的人群 明确该目标的预算，然后根据这个数额，来决定每月定投金额以及定投时间。 定投频率：两周一次最佳，每日一投会因为买入时间间隔过短，所以起不到摊低成本的作用，经数据测算，两周一投是收益率最高的方式。 注意事项： 1、短期内要用到的钱不能用于投资。 2、定投贵在坚持，每一次定投都是你在向财务自由迈步。 三、怎么卖 俗话说：“会买的是徒弟，会卖的才是师傅。” 如何把握卖出时机的确是基金投资中，最难掌握的一步，但是不用害怕，这个时候我们已经有了收益，需要做的就是落袋为安，把那个数字转换成实实在在的钱罢了。 下面有几种方法请大家查收，从简单到困难。 （1）目标收益率法在我们入市之前，给自己定下一个目标收益率（15%或者20%）， 当定投的持有收益率达到目标收益率时，卖出20%-30%，然后继续投资。简单粗暴，适合小白操作。 （2）估值表法则支付宝上对于基金估值的判断会有一个红绿灯来表示： （图中基金不作投资参考） 除了指数红绿灯，在支付宝上还可以找到专业机构看法参考： （图中基金不做投资参考） 参考基金估值和机构的看法，来决定是否止盈 但是止盈并不是全部卖出，假设后面有一个大牛市，那么全部卖出就吃不到后面的收益，建议每次止盈**酌情卖出20%、30%**等 （3）市场形势止盈法这个是老基民的方法了，要求个人理财者把握好大的方向： 知道目前市场是牛是熊、市场上的基金是便宜还是贵。如果实在不知道的呢，我建议上证指数2900点以下多买，3300点附近部分卖出。 更进一阶的可以不只分析大盘，也可以分析自己所投资的行业，分别从政策、技术、资金等方面判断市场所处位置，上涨的可能性大还是跌的可能性大。 如果现在不会这种方法，不用担心，在市场上度过一年之后，你就会有自己的看法。 本文整理自知乎-吴机长的回答","categories":[{"name":"懂理财","slug":"懂理财","permalink":"https://blog.jddfe.com/categories/%E6%87%82%E7%90%86%E8%B4%A2/"}],"tags":[{"name":"基金","slug":"基金","permalink":"https://blog.jddfe.com/tags/%E5%9F%BA%E9%87%91/"},{"name":"定投","slug":"定投","permalink":"https://blog.jddfe.com/tags/%E5%AE%9A%E6%8A%95/"},{"name":"投资","slug":"投资","permalink":"https://blog.jddfe.com/tags/%E6%8A%95%E8%B5%84/"}]},{"title":"防抖、节流及应用场景","slug":"防抖、节流及应用场景","date":"2020-11-11T14:27:28.000Z","updated":"2020-11-11T15:09:18.571Z","comments":true,"path":"2020/11/11/防抖、节流及应用场景/","link":"","permalink":"https://blog.jddfe.com/2020/11/11/%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"防抖(debounce) 事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 防抖，顾名思义，防止抖动，什么叫抖动，事件被高频触发，想象你在用鼠标点击按钮操纵一个小人让他有跳跃的动作，你狂点鼠标，小人狂跳，这就是最直观的抖动现象。 直接上代码 12345678910111213141516/** fn [function] 需要防抖的函数* delay [number] 毫秒，防抖期限值*/function debounce(fn, delay) &#123; let timer = null // 借助闭包 return function() &#123; // 当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时 if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(()=&gt;&#123; fn.call(this, arguments); &#125;, delay) &#125;&#125; 节流(throttle) 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 简单的可以理解为指定时间间隔只执行一次任务。 直接看代码： 12345678910111213function throttle(fn,delay)&#123; let valid = true return function() &#123; if(valid)&#123; valid = false &#125; // 工作时间，执行函数并且在间隔期内把状态位设为无效 setTimeout(() =&gt; &#123; fn.call(this, arguments); valid = true; &#125;, delay) &#125;&#125; 注：节流函数并不止上面这种实现方案,例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样。 总结那么你可能会困惑，防抖也有时间间隔，节流还是时间间隔，它俩啥区别？ 上结论： 防抖：超过指定时间间隔，不论点击多少次都只执行一次。 节流：指定时间间隔只执行一次，执行频率不受操作频率影响，但会把所有的都执行完。 应用场景防抖： search搜索联想，用户在不断输入值时，用防抖来节约请求资源。window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 节流： 鼠标不断点击触发，mousedown(单位时间内只触发一次)监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"防抖","slug":"防抖","permalink":"https://blog.jddfe.com/tags/%E9%98%B2%E6%8A%96/"},{"name":"节流","slug":"节流","permalink":"https://blog.jddfe.com/tags/%E8%8A%82%E6%B5%81/"}]},{"title":"Hexo 双线部署到 Coding 和 GitHub 并实现全站 HTTPS","slug":"Hexo-双线部署到-Coding-和-GitHub-并实现全站-HTTPS","date":"2020-11-09T14:56:25.000Z","updated":"2020-11-10T16:46:03.012Z","comments":true,"path":"2020/11/09/Hexo-双线部署到-Coding-和-GitHub-并实现全站-HTTPS/","link":"","permalink":"https://blog.jddfe.com/2020/11/09/Hexo-%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E5%88%B0-Coding-%E5%92%8C-GitHub-%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%85%A8%E7%AB%99-HTTPS/","excerpt":"","text":"GitHub pages是GitHub提供的一项静态站点托管网页，这里就不过多介绍，由于国内网络原因，访问延迟100-300ms，当然这还是在网络较好的时候，在网络差的情况下会很难加载完全网页，令人头疼，于是，针对这个问题做个大致的解决方案，记录分享下。 本文主要从双线部署和实现https自定义域名两个点做分享，并记录一下其中遇到的坑。 所谓双线部署就是将博客同时发布到 Coding 和 Github，博客发布到 Coding 来提升国内访问速度，并可以提交百度收录，GitHub 禁止了百度的爬取，当然可以通过其他方案来解决收录问题，这里就不过多介绍了，感兴趣的可以网上找一下。 实现双线部署首先，你要将 Hexo 成功部署到了 GitHub Pages，如果还没有，可以参考之前的博文专门的教程《Hexo 5分钟搞定你的个人博客》 在成功部署到了 GitHub 后，那么就简单了，关键点就在于发布配置多配置个 Coding 代码库。 上代码： 1234567# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy: type: git repository: coding: https:&#x2F;&#x2F;e.coding.net&#x2F;团队名&#x2F;项目名&#x2F;代码库.git github: https:&#x2F;&#x2F;github.com&#x2F;昵称&#x2F;代码库.git 创建 Coding 项目进入 Coding 官网，点击登录（如果首次使用，需要创建团队-创建用户-完成注册，安装步骤完成） 进入后创建项目，选择 DevOps 项目 （比较关键，决定后面能否静态部署）创建完项目后，新建仓库重点这里，新建静态网站 这里有三种方式： 代码来源-现有仓库，网站类型-静态网站 代码来源-现有仓库，网站类型-Hexo/Jekyll 代码来源-示例仓库，网站类型-Hexo/Jekyll 区别在于是在本地构建编译，还是云构建编译。最终都是把编译后的代码部署到服务。 好，到此，上面双部署就算完成。 自定义域名并HTTPSGithub 自定义域名在 Settings -&gt; GitHub Pages 直接配置 Custom domain。这里要注意一定要在 hexo项目source下新建一个 CNAME 文件，内容为你自定义的域名，解决每次发布的时候 Custom domain 会被重置的问题。 Coding 自定义域名静态网站 -&gt; 自定义域名。 配置同时需要生产SSL证书，并且需要做域名解析的配置。 至此，我们的 Hexo 博客就成功双线部署到 Coding Pages 和 GitHub Pages 了，并且也实现了全站 HPPTS。完成配置后你会明显发现速度的变化。","categories":[{"name":"折腾不止","slug":"折腾不止","permalink":"https://blog.jddfe.com/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.jddfe.com/tags/Hexo/"},{"name":"Github Page","slug":"Github-Page","permalink":"https://blog.jddfe.com/tags/Github-Page/"}]},{"title":"闭包为什么会占用内存","slug":"闭包为什么会占用内存","date":"2016-09-03T14:16:54.000Z","updated":"2020-11-11T08:57:02.166Z","comments":true,"path":"2016/09/03/闭包为什么会占用内存/","link":"","permalink":"https://blog.jddfe.com/2016/09/03/%E9%97%AD%E5%8C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98/","excerpt":"","text":"在试图弄清这个问题之前，先要理解栈内存堆内存和预处理 占用内存，不会销毁的闭包实例例1：123456789var num = 12;function fn() &#123; var num = 100; return function () &#123; console.log(num); &#125;&#125;var f = fn();f(); 例1的图示 未被占用的堆内存才会被销毁 所以，正如图中椭圆形关键点中说明的那样，堆内存xxxfff111被返回给了全局变量f，而全局变量只有在窗口关闭的时候才会销毁，因此堆内存xxxfff111将一直被占用而不会销毁，定义它的局部作用域A也不会被销毁。 例2123456var oDiv = document.getElementById(&quot;div1&quot;);function() &#123; oDiv.onclick = function() &#123; &#125;&#125;(); 这段代码的特点是：私有作用域给dom元素的事件绑定一个方法。 例2的图示： 正如图中椭圆形关键点所说，标签对象的属性里面会自带一个onclick的属性，未被赋值时其值为null。那么，在自执行函数执行的时候，其创建的作用域所占用的堆内存xxxfff111同样也会被全局的堆内存xxxfff000占用（这里要注意，是堆内存占用堆内存），所以堆内存xxxfff111和栈内存A都不会被销毁。 不占用内存，立即销毁的实例只需要将例1稍作修改。 例3：1234567function fn()&#123; var num &#x3D; 100; return function()&#123; console.log(num); &#125;&#125;fn(); &#x2F;&#x2F;主要修改在这里 例3的图示 由于在函数fn中，xxxfff111是被return的，所以栈内存A的预解释不会处理xxxfff111，它只在fn函数执行的时候才会生成，而函数fn的栈内存A每次被执行之后都会被销毁。 暂时占用内存，延时销毁的闭包实例将例3稍作修改，就变成了延时销毁的闭包实例。 例4：1234567function fn()&#123; var num = 100; return function()&#123; &#125;&#125;fn()(); //这里到底发生了什么？其实是执行了一次fn之后，把返回的子函数有执行了一次，所以在子函数执行的时候，栈内存fn()是不能销毁的，但是子函数执行完毕后因为没有被占用，所以最终还是要被销毁的，所以最终fn()还是会被销毁的。 例4的图示： 正如途中椭圆形关键点处所说，fn()()的意思是在执行完fn()之后再把返回的值函数执行一遍。因此在子函数执行的时候，堆内存xxxfff111被占用了，相应的栈内存A也将保留。 可堆内存xxxfff111中保存的子函数在执行完成之后还是会被销毁，接着堆内存xxxfff111就作为未被占用的堆内存而被销毁，最终栈内存A也会被销毁。 所以，栈内存在执行完之后会被保留一段时间，这段时间等于其子函数执行的时间。 参考资料： javascript高级程序设计(第三版)。","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Javascript","slug":"Javascript","permalink":"https://blog.jddfe.com/tags/Javascript/"},{"name":"闭包","slug":"闭包","permalink":"https://blog.jddfe.com/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"栈内存堆内存和预处理","slug":"栈内存堆内存和预处理","date":"2016-09-02T14:10:54.000Z","updated":"2020-11-11T08:51:34.959Z","comments":true,"path":"2016/09/02/栈内存堆内存和预处理/","link":"","permalink":"https://blog.jddfe.com/2016/09/02/%E6%A0%88%E5%86%85%E5%AD%98%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86/","excerpt":"","text":"浏览器是如何运行javascript代码的？JavaScript 是如何运行的？ 看例1： 123456var num = 12;function fn() &#123; var num = 100;&#125;fn();num = 200; 用图解释这一行代码是如何执行的。 这是一个简单的图示，现在我们来增加几个概念：栈内存、堆内存和预处理。 栈内存栈内存用来存放基本数据类型(Number、String、Boolean、Null和Undefined)，在执行完之后销毁。 栈内存与另一个概念息息相关——作用域，即代码的执行环境。上图中左边的栈内存就是全局作用域，而右边的则是局部作用域。全局作用域在浏览器窗口关闭之后才销毁。局部作用域在执行完之后就会销毁。 javascript规定，父作用域不能使用子作用域中变量和方程，而反过来是可以的。这个反过来的方向链条则被称为作用域链。 这里需要注意的是，判断子作用域的父作用域是哪一个，要看这个子作用域是在哪里定义的，而不是在哪里执行。 堆内存堆内存用来存放引用数据类型(object、array、function、date)，在没有被引用之后销毁。 当我们声明和定义了一个引用数据类型之后，这个对象保存在堆内存中，而这个对象的地址则保存在栈内存中以用于引用。 在全局作用域声明和定义的引用数据类型，销毁的方法是手动赋值null。 看一组例子来说明栈内存与堆内存的区别：例2 1234var a &#x3D; 20;var b &#x3D; a;b &#x3D; 30;&#x2F;&#x2F; a等于多少？ 例3 1234var m &#x3D; &#123; a: 10, b: 20 &#125;var n &#x3D; m;n.a &#x3D; 15;&#x2F;&#x2F; m.a的值是分别是什么？ 例2的图解 例3的图解 由上两个图解可见，当基本数据类型传递的时候，其实是复制了一个新的数据给另一个变量；而当引用类型传递的时候，复制的仅仅是引用数据类型的地址，两个变量通过地址指向的是同一个堆内存中的数据。 所以在例3中，当我们改变n.a的时候，m.a也同样改变了。 预处理预处理是浏览器在执行代码前要做的任务，它包括变量的声明和函数声明与定义。 预处理是变量提升的原因。 当我们写了var num = 12这样的一行代码的时候，在执行时其实是分为两步：声明var num和定义num = 12。对于变量，预处理只做声明而不做定义。 而相对于函数function fn()&#123;var num 12&#125;，同样有声明和定义之分，与变量不同的是，预处理时声明和定义全部执行。具体步骤是：声明function fn()，定义fn() = &quot;&#123;var num = 12&#125;&quot;。 理解了栈内存、堆内存和预处理之后，重新画出例1的图示： 这里的堆内存xxxfff000被全局作用域的函数fn引用，而全局作用域只有在浏览器窗口关闭的时候才会销毁，所以，只要浏览器窗口没有关闭，则堆内存xxxfff000一直被引用而不会销毁。 参考资料： javascript高级程序设计(第三版)；","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Javascript","slug":"Javascript","permalink":"https://blog.jddfe.com/tags/Javascript/"},{"name":"栈和堆","slug":"栈和堆","permalink":"https://blog.jddfe.com/tags/%E6%A0%88%E5%92%8C%E5%A0%86/"}]},{"title":"JS 中的事件绑定、事件监听、事件委托","slug":"JS 中的事件绑定、事件监听、事件委托","date":"2016-08-18T12:50:14.000Z","updated":"2020-11-16T16:15:55.791Z","comments":true,"path":"2016/08/18/JS 中的事件绑定、事件监听、事件委托/","link":"","permalink":"https://blog.jddfe.com/2016/08/18/JS%20%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"事件绑定 要想让 javascript 对用户的操作作出响应，首先要对 dom 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称","text":"事件绑定 要想让 javascript 对用户的操作作出响应，首先要对 dom 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称 在javascript中，有三种常用的绑定事件的方法 在dom元素中直接绑定； 在javascript代码中绑定； 绑定事件监听函数 在dom中直接绑定事件1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;hello()&quot;&gt;&lt;script&gt;function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 在javascript代码中绑定事件 在javascript代码中（即script标签内）绑定事件可以使javascript代码与HTML标签分离，文档结构清晰，便于管理和开发 1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn&quot;).onclick = function()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 使用事件监听绑定事件 关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段 起初Netscape制定了javascript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范 W3C规范 语法 1element.addEventListener(event, function, useCapture) event : （必需）事件名，支持所有dom事件。 function：（必需）指定要事件触发时执行的函数。 useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false 注： IE8 以下不支持 12345678&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn1&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn1&quot;).addEventListener(&quot;click&quot;,hello);function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; IE标准 语法： 1element.attachEvent(event, function) event：（必需）事件类型。需加“on“，例如：onclick。 function：（必需）指定要事件触发时执行的函数 12345678&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn2&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn2&quot;).attachEvent(&quot;onclick&quot;,hello);function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 事件监听的优点 可以绑定多个事件 1234567891011&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn3&quot;&gt;&lt;script&gt;var btn3 = document.getElementById(&quot;btn3&quot;);btn3.onclick = function()&#123; alert(&quot;hello 1&quot;); //不执行&#125;btn3.onclick = function()&#123; alert(&quot;hello 2&quot;); //执行&#125;&lt;/script&gt; 常规的事件绑定只执行最后绑定的事件 1234567891011121314&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn4&quot;&gt;&lt;script&gt;var btn4 = document.getElementById(&quot;btn4&quot;);btn4.addEventListener(&quot;click&quot;,hello1);btn4.addEventListener(&quot;click&quot;,hello2);function hello1()&#123; alert(&quot;hello 1&quot;);&#125;function hello2()&#123; alert(&quot;hello 2&quot;);&#125;&lt;/script&gt; 两个事件都执行了 可以解除相应的绑定 123456789101112131415&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;&lt;script&gt;var btn5 = document.getElementById(&quot;btn5&quot;);btn5.addEventListener(&quot;click&quot;,hello1);//执行了btn5.addEventListener(&quot;click&quot;,hello2);//不执行btn5.removeEventListener(&quot;click&quot;,hello2);function hello1()&#123; alert(&quot;hello 1&quot;);&#125;function hello2()&#123; alert(&quot;hello 2&quot;);&#125;&lt;/script&gt; 封装事件监听 12345678910111213141516171819202122232425&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;//绑定监听事件function addEventHandler(target,type,fn)&#123; if(target.addEventListener)&#123; target.addEventListener(type,fn); &#125;else&#123; target.attachEvent(&quot;on&quot;+type,fn); &#125;&#125;//移除监听事件function removeEventHandler(target,type,fn)&#123; if(target.removeEventListener)&#123; target.removeEventListener(type,fn); &#125;else&#123; target.detachEvent(&quot;on&quot;+type,fn); &#125;&#125;//测试var btn5 = document.getElementById(&quot;btn5&quot;);addEventHandler(btn5,&quot;click&quot;,hello1);//添加事件hello1addEventHandler(btn5,&quot;click&quot;,hello2);//添加事件hello2removeEventHandler(btn5,&quot;click&quot;,hello1);//移除事件hello1 事件委托 事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果 12345678910&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn6&quot;&gt;var btn6 = document.getElementById(&quot;btn6&quot;);document.onclick = function(event)&#123; event = event || window.event; var target = event.target || event.srcElement; if(target == btn6)&#123; alert(btn5.value); &#125;&#125; 事件委托优点 提高javascript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用 传统写法 123456789101112131415161718192021&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);item1.onclick = function()&#123; alert(&quot;hello item1&quot;);&#125;item2.onclick = function()&#123; alert(&quot;hello item2&quot;);&#125;item3.onclick = function()&#123; alert(&quot;hello item3&quot;);&#125;&lt;/script&gt; 事件委托 12345678910111213141516171819202122&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123; var target = event.target; if(target == item1)&#123; alert(&quot;hello item1&quot;); &#125;else if(target == item2)&#123; alert(&quot;hello item2&quot;); &#125;else if(target == item3)&#123; alert(&quot;hello item3&quot;); &#125;&#125;)&lt;/script&gt; 动态的添加dom元素，不需要因为元素的改动而修改事件绑定 传统写法 123456789101112131415161718192021222324&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);var item = list.getElementsByTagName(&quot;li&quot;);for(var i=0;i&lt;item.length;i++)&#123; (function(i)&#123; item[i].onclick = function()&#123; alert(item[i].innerHTML); &#125; &#125;)(i)&#125;var node=document.createElement(&quot;li&quot;);var textnode=document.createTextnode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; 点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。 事件委托 12345678910111213141516171819202122&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123; var target = event.target; if(target.nodeName == &quot;LI&quot;)&#123; alert(target.innerHTML); &#125;&#125;)var node=document.createElement(&quot;li&quot;);var textnode=document.createTextnode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; 当点击item4时，item4有事件响应。说明事件委托可以为新添加的dom元素动态的添加事件","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.jddfe.com/tags/javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"事件","slug":"事件","permalink":"https://blog.jddfe.com/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"event","slug":"event","permalink":"https://blog.jddfe.com/tags/event/"}]},{"title":"OOP之原型与原型链","slug":"OOP之原型与原型链","date":"2016-08-17T12:40:20.000Z","updated":"2020-11-11T07:59:25.557Z","comments":true,"path":"2016/08/17/OOP之原型与原型链/","link":"","permalink":"https://blog.jddfe.com/2016/08/17/OOP%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"prototype原型对象 每个函数都有一个默认的prototype属性，其实际上还是一个对象，如果被用在继承中，姑且叫做原型对象 在构造函数中的prototype中定义的属性和方法，会被创建的对象所继承下来。举个栗子：","text":"prototype原型对象 每个函数都有一个默认的prototype属性，其实际上还是一个对象，如果被用在继承中，姑且叫做原型对象 在构造函数中的prototype中定义的属性和方法，会被创建的对象所继承下来。举个栗子： 123456function F()&#123;&#125;F.prototype.work = function()&#123; console.log(&#x27;F is working..&#x27;);&#125;;var f = new F();f.work(); // F is working.. 当你创建函数时，JS会为这个函数自动添加 prototype 属性，值是空对象。而一旦你把这个函数当作构造函数（ constructor ）调用（即通过 new 关键字调用），那么JS就会帮你创建该构造函数的实例，实例继承构造函数 prototype 的所有属性和方法（实例通过设置自己的 __proto__ 指向构造函数的 prototype 来实现这种继承） 神秘的proto JS的对象中都包含了一个__proto__属性，其指向的是创建该对象时的构造函数的原型对象prototype 从上面的输出结果看出，f.__proto__指向了其构造函数F的prototype，而F.prototype本身也是一个对象，其内部也有__proto__属性，其指向的是Object.prototype,直到最后Object.prototype指向null，这条原型链才结束 因此，__proto__这个神秘的属性才是原型链形成的真正原因 原型链 由于原型对象本身也是对象，根据上边的定义，它也有自己的原型，而它自己的原型对象又可以有自己的原型，这样就组成了一条链，这个就是原型链，JavaScritp引擎在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回undefined。原型链一般实现为一个链表，这样就可以按照一定的顺序来查找 从上图看出： Object.prototype是顶级对象，所有对象都继承自它。 Function 继承 Function 本身， Function.prototype 继承 Object.prototype Function.prototype 和 Function.__proto__ 都指向 Function.prototype Object.prototype.__proto__ === null ，说明原型链到 Object.prototype终止","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.jddfe.com/tags/javascript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"原型链","slug":"原型链","permalink":"https://blog.jddfe.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"}]},{"title":"OOP之面向对象","slug":"OOP之面向对象","date":"2016-08-16T12:26:24.000Z","updated":"2020-11-11T07:49:46.148Z","comments":true,"path":"2016/08/16/OOP之面向对象/","link":"","permalink":"https://blog.jddfe.com/2016/08/16/OOP%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"一般面向对象包含：继承，封装，多态，抽象 对象形式的继承 浅拷贝","text":"一般面向对象包含：继承，封装，多态，抽象 对象形式的继承 浅拷贝 12345678910111213141516171819202122232425var Person = &#123; name: &#x27;allin&#x27;, age: 18, address: &#123; home: &#x27;home&#x27;, office: &#x27;office&#x27;, &#125; sclools: [&#x27;x&#x27;,&#x27;z&#x27;],&#125;;var programer = &#123; language: &#x27;js&#x27;,&#125;;function extend(p, c)&#123; var c = c || &#123;&#125;; for( var prop in p)&#123; c[prop] = p[prop]; &#125;&#125;extend(Person, programer);programer.name; // allinprogramer.address.home; // homeprogramer.address.home = &#x27;house&#x27;; //housePerson.address.home; // house 从上面的结果看出，浅拷贝的缺陷在于修改了子对象中引用类型的值，会影响到父对象中的值，因为在浅拷贝中对引用类型的拷贝只是拷贝了地址，指向了内存中同一个副本 深拷贝 1234567891011function extendDeeply(p, c)&#123; var c = c || &#123;&#125;; for (var prop in p)&#123; if(typeof p[prop] === &quot;object&quot;)&#123; c[prop] = (p[prop].constructor === Array)?[]:&#123;&#125;; extendDeeply(p[prop], c[prop]); &#125;else&#123; c[prop] = p[prop]; &#125; &#125;&#125; 利用递归进行深拷贝，这样子对象的修改就不会影响到父对象 123extendDeeply(Person, programer);programer.address.home = &#x27;allin&#x27;;Person.address.home; // home 利用call和apply继承 12345678function Parent()&#123; this.name = &quot;abc&quot;; this.address = &#123;home: &quot;home&quot;&#125;;&#125;function Child()&#123; Parent.call(this); this.language = &quot;js&quot;; &#125; ES5中的Object.create()123var p = &#123; name : &#x27;allin&#x27;&#125;;var obj = Object.create(o);obj.name; // allin Object.create()作为new操作符的替代方案是ES5之后才出来的。我们也可以自己模拟该方法： 12345678910//模拟Object.create()方法function myCreate(o)&#123; function F()&#123;&#125;; F.prototype = o; o = new F(); return o;&#125;var p = &#123; name : &#x27;allin&#x27;&#125;;var obj = myCreate(o);obj.name; // allin 目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署 1234567 if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;; &#125; 类的继承 Object.create() 123456789function Person(name, age)&#123;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123; console.log(&#x27;eating...&#x27;);&#125;function Programmer(name, age, title)&#123;&#125;Programmer.prototype = Object.create(Person.prototype); //建立继承关系Programmer.prototype.constructor = Programmer; // 修改constructor的指向 调用父类方法 12345678910111213141516171819202122function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123; console.log(&#x27;eating...&#x27;);&#125;function Programmer(name, age, title)&#123; Person.apply(this, arguments); // 调用父类的构造器&#125;Programmer.prototype = Object.create(Person.prototype);Programmer.prototype.constructor = Programmer;Programmer.prototype.language = &quot;js&quot;;Programmer.prototype.work = function()&#123; console.log(&#x27;i am working code in &#x27;+ this.language); Person.prototype.eat.apply(this, arguments); // 调用父类上的方法&#125; 封装 命名空间 js是没有命名空间的，因此可以用对象模拟 12345678910var app = &#123;&#125;; // 命名空间app//模块1app.module1 = &#123; name: &#x27;allin&#x27;, f: function()&#123; console.log(&#x27;hi robot&#x27;); &#125;&#125;;app.module1.name; // &quot;allin&quot;app.module1.f(); // hi robot 静态成员 123456789function Person(name)&#123; var age = 100; this.name = name;&#125;//静态成员Person.walk = function()&#123; console.log(&#x27;static&#x27;);&#125;;Person.walk(); // static 私有与公有 1234567891011121314151617function Person(id)&#123; // 私有属性与方法 var name = &#x27;allin&#x27;; var work = function()&#123; console.log(this.id); &#125;; //公有属性与方法 this.id = id; this.say = function()&#123; console.log(&#x27;say hello&#x27;); work.call(this); &#125;;&#125;;var p1 = new Person(123);p1.name; // undefinedp1.id; // 123p1.say(); // say hello 123 模块化 1234567891011var moduleA;moduleA = function() &#123; var prop = 1; function func() &#123;&#125; return &#123; func: func, prop: prop &#125;;&#125;(); // 立即执行匿名函数 多态 模拟方法重载 arguments属性可以取得函数调用的实参个数，可以利用这一点模拟方法的重载 12345678function demo(a, b )&#123; console.log(demo.length); // 得到形参个数 console.log(arguments.length); //得到实参个数 console.log(arguments[0]); // 第一个实参 4 console.log(arguments[1]); // 第二个实参 5&#125;demo(4, 5, 6); 123456789101112131415161718192021222324252627282930313233343536373839//实现可变长度实参的相加function add()&#123; var total = 0; for( var i = arguments.length - 1; i &gt;= 0; i--)&#123; total += arguments[i]; &#125; return total;&#125;console.log(add(1)); // 1console.log(add(1, 2, 3)); // 7// 参数不同的情况function fontSize()&#123; var ele = document.getElementById(&#x27;js&#x27;); if(arguments.length == 0)&#123; return ele.style.fontSize; &#125;else&#123; ele.style.fontSize = arguments[0]; &#125;&#125;fontSize(18);console.log(fontSize());// 类型不同的情况function setting()&#123; var ele = document.getElementById(&#x27;js&#x27;); if(typeof arguments[0] === &quot;object&quot;)&#123; for(var p in arguments[0])&#123; ele.style[p] = arguments[0][p]; &#125; &#125;else&#123; ele.style.fontSize = arguments[0]; ele.style.backgroundColor = arguments[1]; &#125;&#125;setting(18, &#x27;red&#x27;);setting(&#123;fontSize:20, backgroundColor: &#x27;green&#x27;&#125;); 方法重写 1234567891011function F()&#123;&#125;var f = new F();F.prototype.run = function()&#123; console.log(&#x27;F&#x27;);&#125;f.run(); // Ff.run = function()&#123; console.log(&#x27;fff&#x27;);&#125;f.run(); // fff 抽象类 在构造器中 throw new Error(&#39;&#39;); 抛异常。这样防止这个类被直接调用 12345678910111213141516171819202122232425function DetectorBase() &#123; throw new Error(&#x27;Abstract class can not be invoked directly!&#x27;);&#125;DetectorBase.prototype.detect = function() &#123; console.log(&#x27;Detection starting...&#x27;);&#125;;DetectorBase.prototype.stop = function() &#123; console.log(&#x27;Detection stopped.&#x27;);&#125;;DetectorBase.prototype.init = function() &#123; throw new Error(&#x27;Error&#x27;);&#125;;// var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!function LinkDetector() &#123;&#125;LinkDetector.prototype = Object.create(DetectorBase.prototype);LinkDetector.prototype.constructor = LinkDetector;var l = new LinkDetector();console.log(l); //LinkDetector &#123;&#125;__proto__: LinkDetectorl.detect(); //Detection starting...l.init(); //Uncaught Error: Error","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.jddfe.com/tags/javascript/"},{"name":"面向对象","slug":"面向对象","permalink":"https://blog.jddfe.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"OOP之类与对象","slug":"OOP之类与对象","date":"2016-08-15T12:55:24.000Z","updated":"2020-11-11T07:46:49.484Z","comments":true,"path":"2016/08/15/OOP之类与对象/","link":"","permalink":"https://blog.jddfe.com/2016/08/15/OOP%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"对象 对象的含义 所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成","text":"对象 对象的含义 所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成 对象的创建 使用new运算符创建Object 12var p = new Object();p.name = &quot;Tony&quot;; 使用对象字面量的形式 12345678910111213141516171819//对象字面量形式var p =&#123; name: &quot;tony&quot;, work: function()&#123; console.log(&quot;working....&quot;); &#125;, _age: 18, get age()&#123; return this._age; &#125;, set age(val)&#123; if( val &lt;0 || val &gt; 150)&#123; throw new Error(&quot;invalid value&quot;); &#125;else&#123; this._age = val; &#125; &#125;&#125;console.log(p.name); 对象的基本操作 成员属性的添加 123456789101112// Object.defineProperty()方法Object.defineProperty(p, &quot;age&quot;,&#123;value: 18, writable: false&#125;);//Object.defineProperties()方法 添加多个属性Object.defineProperties(p, &#123; salary:&#123; value: 1000, writable: false &#125;, gender:&#123; value: true &#125;&#125;); 成员的遍历 使用 for..in语句 Object.keys()方法 返回一个包含对象键名的字符串数组 1234567var o =&#123;&#125;;o.name = &quot;jack&quot;;o.age = 20;for(var i in o)&#123; console.log(o[i]);&#125; // jack, 20Object.keys(o); // [&quot;name&quot;, &quot;age&quot;] 检查对象是否有某个属性 in 操作符 Object.hasOwnProperty()方法 123var o = &#123;name: &quot;mariya&quot;&#125;&quot;name&quot; in o; // trueo.hasOwnProperty(&quot;name&quot;); // true 得到对象的属性特性描述 Object.getOwnPropertyDescriptor(obj,property) 1234Object.getOwnPropertyDescriptor(o, &quot;name&quot;);//Object &#123;// value: &quot;mariya&quot;, writable: true, enumerable: true, configurable: true&#125; 删除属性 delete运算符,但有些对象的属性是删除不了的 12delete o.name; //trueo.name; // undefined Constructor属性 constructor始终指向创建当前对象的构造函数 12345678var arr = [];console.log(arr.constructor === Array); // truevar Foo = function() &#123;&#125;;console.log(Foo.constructor === Function); // true// 由构造函数实例化一个obj对象var obj = new Foo();console.log(obj.constructor === Foo); // trueconsole.log(obj.constructor.constructor === Function); // true 每个函数都有一个默认的属性prototype，而这个prototype的constructor默认指向这个函数 类的创建 虽然js是门基于对象的语言，但是没有类这一概念的，虽然保留了class的关键字，但在ES6之前是无法使用的。所以，可以用构造函数模拟类的创建，也就是伪类。 所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上 每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承 12345678910//构造函数模式function Person(age, name)&#123; //Class this.age = age; this.name = name;&#125;//将公共的属性或方法放在prototype属性上Person.prototype.headCount = 1;//创建实例对象var p = new Person(19, &#x27;johnsom&#x27;);var p1 = new Person(20, &#x27;allen&#x27;); this this表示当前对象，如果在全局作用范围内使用this，则指代当前页面对象window； 如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用apply和call两个全局方法来改变函数中this的具体指向 全局代码中的this1console.log(this === window); //true 全局范围内使用this指向window对象 普通的函数调用123function f()&#123;this.name = &quot;tony&quot;; // this在运行时指向window对象,在严格模式下则是undefined&#125; 在对象中使用123456var o = &#123; name: &quot;tony&quot;, print: function()&#123; console.log(this.name); //this指向对象o，但是可以改变其指向 &#125;&#125;; 作为构造函数1new F(); // 函数内部的this指向新创建的对象。 多层嵌套的内部函数1234567891011var name = &quot;global&quot;;var person = &#123; name : &quot;person&quot;, hello : function(sth)&#123; var sayhello = function(sth) &#123; console.log(this.name + &quot; says &quot; + sth); &#125;; sayhello(sth); &#125;&#125;person.hello(&quot;hello world&quot;);//global says hello world 在内部函数中，this没有按预想的绑定到外层函数对象上，而是绑定到了全局对象。这里普遍被认为是javascript语言的设计错误，因为没有人想让内部函数中的this指向全局对象。一般的处理方式是将this作为变量保存下来，一般约定为that或者self： 123456789101112var name = &quot;global&quot;;var person = &#123; name : &quot;person&quot;, hello : function(sth)&#123; var that = this; var sayhello = function(sth) &#123; console.log(that.name + &quot; says &quot; + sth); &#125;; sayhello(sth); &#125;&#125;person.hello(&quot;hello world&quot;);//person says hello world 事件中的this1234var ele = document.getElementById(&quot;id&quot;);ele.addEventListener(&#x27;click&#x27;,function()&#123; console.log(this); //this指向dom元素&#125;); 使用apply和call改变this的指向 apply和call类似，只是后面的参数是通过一个数组传入，而不是分开传入。两者都是将某个函数绑定到某个具体对象上使用，自然此时的this会被显式的设置为第一个参数。两者的方法定义： 12call( thisArg [，arg1，arg2，… ] ); // 参数列表，arg1，arg2，...apply(thisArg [，argArray] ); // 参数数组，argArray 1234567891011var name = &#x27;global&#x27;;var o = &#123; name: &#x27;job&#x27;, getName: function()&#123; console.log(this.name); &#125;&#125;;o.getName(); // job//用call或apply改变函数中this的指向o.getName.call(this); // global 简单的总结： 当函数作为对象的方法调用时，this指向该对象。 构造函数中的this指向新创建的对象 嵌套函数中的this不会继承上层函数的this，如果需要，可以用一个变量保存上层函数的this bind（） 该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数. 12$(&quot;#ele&quot;).click(person.hello.bind(person));//相应元素被点击时，输出person says hello world","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.jddfe.com/tags/javascript/"},{"name":"面向对象","slug":"面向对象","permalink":"https://blog.jddfe.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"移动端自适应适配实现方案","slug":"移动端自适应适配实现方案","date":"2016-06-16T07:21:47.000Z","updated":"2020-11-11T07:37:04.218Z","comments":true,"path":"2016/06/16/移动端自适应适配实现方案/","link":"","permalink":"https://blog.jddfe.com/2016/06/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94%E9%80%82%E9%85%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","excerpt":"","text":"最近招聘面试过程中，我经常会问到这个移动端自适应适配是怎么实现的，大部分候选人都能说初rem的方式，但是很少有能说出原理的。 rem 实现弹性布局原理根据屏幕宽度动态改变 html 根字体的大小。 （1）rem + js 实现弹性布局 rem 和 em 两者都是 css 的相对单位，但是两者有明显的区别：当作为font-size单位时，em 表示相对于父元素字体的大小；当作为其他单位时，表示自身字体大小，比如首行缩紧2个字符 text-indent:2em; 。当作为非根元素的时，rem 是相对于根字体的大小；当作为根元素时，相对于初始字体大小的。💡em 容易造成“牵一发而动全身”，可以用作于行高、首行缩紧等；rem 最大的特点是统一参考系，其实现弹性布局的本质是等比缩放（通常是基于宽度）。 （2）更高级的单位 vw 实现弹性布局 如果把屏幕宽度分为 100 份，每一份就是宽度的 1% ，如果以这一份为单位 就可以实现弹性布局了。利用 rem 相对于根字体这个特性，可以间接地实现这样的单位。 根字体的大小通常是通过 js 获取屏幕宽度设置的。但是 CSS3 引入了一个新的单位 vw ，vw —— 视口宽度的 1/100，其实正是上面我们想办法实现的那个每一份的单位。 vw 允许不通过 js 也能实现根据屏幕宽度的弹性布局。 （3）vw + rem实现弹性布局 我们完全可以通过 vw 实现弹性布局，当然 vw 结合 rem 同样可以实现弹性布局。 媒体查询移动端设备的屏幕大小差别很大，为了避免因为屏幕过宽或过窄造成字体过大或过小，需要结合媒体查询 根据不同屏幕的宽度，设定相对单位的大小。这个时候就需要利用 rem 实现了。 1234//当屏幕宽度小于 320px 的时候，规定字体大小 64px 。@media screen and (max-width: 320px) &#123; font-size: 64px; &#125; 1234//当屏幕宽度大于 540px 的时候，规定字体大小 108px 。@media screen and (min-width: 540px) &#123; font-size: 108px; &#125; 💡响应式布局是不同设备、屏幕展示的样式不同。弹性布局则是等比缩放，高度还原。弹性布局属于响应式布局的一种。使用 rem 实现弹性布局不允许用户设置字体大小，所以 rem 通常适用于图标类活动页，而不是适用于纯文本的页面。 css 预处理器语言 scssscss 是 css 预处理器语言，语法规则和 css 类似。比如，变量使用 $ 符表示，如 $m_fontsize:75 。可以定义函数等。具体规则可查看sass官方文档。 rem + vw + 媒体查询方式实现弹性布局的完整代码实例12345678910111213141516&#x2F;&#x2F;通常设计稿以 iphone6 为模型来设计的。因为 iphone6 屏幕宽度是 750px ，所以 iphone6 的屏宽尺寸设置根元素大小基准值 75px ，这里 75px 只是用来计算的，完全可以设置成其他的值$m_fontsize: 75; @function rem($px) &#123; @return ($px &#x2F; $m_fontsize) * 1rem; &#125; $m_design: 750; html &#123; font-size: ($m_fontsize &#x2F; ($m_design &#x2F; 2)) * 100vw; &#x2F;&#x2F; 通过媒体查询限制屏幕过宽过窄造成的页面内容过大和过小的问题 @media screen and (max-width: 320px) &#123; font-size: 64px; &#125; @media screen and (min-width: 540px) &#123; font-size: 110px; &#125; &gt;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"rem","slug":"rem","permalink":"https://blog.jddfe.com/tags/rem/"},{"name":"css","slug":"css","permalink":"https://blog.jddfe.com/tags/css/"},{"name":"适配","slug":"适配","permalink":"https://blog.jddfe.com/tags/%E9%80%82%E9%85%8D/"}]},{"title":"ES6从入门到精通之常量与变量(一)","slug":"ES6从入门到精通之常量与变量(一)","date":"2016-04-03T12:30:22.000Z","updated":"2020-11-10T14:25:50.053Z","comments":true,"path":"2016/04/03/ES6从入门到精通之常量与变量(一)/","link":"","permalink":"https://blog.jddfe.com/2016/04/03/ES6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E4%B9%8B%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F(%E4%B8%80)/","excerpt":"","text":"ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。 Mozilla公司将在这个标准的基础上，推出JavaScript 2.而ES6有着强大的目标，是使得JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。 对ES6的支持可以查看http://kangax.github.io/compat-table/es6/，在这里可以清晰的了解到不同版本的浏览器对ES6功能的支持情况。如果你想现在就在浏览器使用ES6的特性，还可以通过引用兼容包的方式提前尝尝鲜。 https://github.com/paulmillr/es6-shim。 环境支持推荐用js工具babel来编译http://babeljs.io/。变量与字符串 let是ES6中新增关键字。它的作用类似于var，用来声明变量，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#x2F;*E1*&#x2F;if(true)&#123; var a &#x3D; 1; let b &#x3D; 2;&#125;document.write(a+&#39;&lt;br&#x2F;&gt;&#39;);document.write(b+&#39;&lt;br&#x2F;&gt;&#39;); &#x2F;&#x2F; Uncaught ReferenceError: b is not defined Example2 123456789101112&#x2F;*E2*&#x2F;function f1() &#123; var a &#x3D; 8; let n &#x3D; 5; if (true) &#123; let n &#x3D; 10; var a &#x3D; 20 &#125; document.write(n); &#x2F;&#x2F; 5 document.write(a); &#x2F;&#x2F; 20&#125;f1(); Q1：用let声明a变量默认为5，在if判断中let声明a为10，看a输出结果。 123456&#x2F;*Exercises1*&#x2F;let a &#x3D; 5;if (true) &#123; let a &#x3D; 10;&#125;document.write(a);&#x2F;&#x2F;5 for循环的计数器，就很合适使用let命令。 12345678910111213141516&#x2F;*E3*&#x2F;var a &#x3D; [];for (var i &#x3D; 0; i &lt; 10; i++) &#123; a[i] &#x3D; function () &#123; document.write(i); &#125;;&#125;a[6](); var a &#x3D; [];for (let i &#x3D; 0; i &lt; 10; i++) &#123; a[i] &#x3D; function () &#123; document.write(i); &#125;;&#125;a[6](); constconst 声明的是常量，一旦声明，值将是不可变的。 12345678const PI &#x3D; 3.1415;PI &#x2F;&#x2F; 3.1415 PI &#x3D; 3;PI &#x2F;&#x2F; 3.1415 const PI &#x3D; 3.1;PI &#x2F;&#x2F; 3.1415 const 也具有块级作用域 12345678910&#x2F;*E4*&#x2F;if (true) &#123; const max &#x3D; 5;&#125;document.write(max); &#x2F;&#x2F;Uncaught ReferenceError: max is not definedif (true) &#123; const max &#x3D; 5; document.write(max); &#x2F;&#x2F;5&#125; const 不可重复声明 /* E5*/ 12345var message &#x3D; &quot;Hello!&quot;;let age &#x3D; 25; const message &#x3D; &quot;Goodbye!&quot;;const age &#x3D; 30;&#x2F;&#x2F;cli:Duplicate declaration &quot;age&quot; const 指令指向变量所在的地址，所以对该变量进行属性设置是可行的（未改变变量地址），如果想完全不可变化（包括属性），那么可以使用冻结 /* E6*/ 12345678const C1 &#x3D; &#123;&#125;;C1.a &#x3D; 1;document.write(C1.a); &#x2F;&#x2F; 1 C1 &#x3D; &#123;&#125;; &#x2F;&#x2F; cli: C1 &#x3D; &#123;&#125;; &#x2F;&#x2F; 报错 重新赋值，地址改变const C2 &#x3D; Object.freeze(&#123;&#125;); C2.a &#x3D; 1; document.write(C2.a);&#x2F;&#x2F;Uncaught TypeError: Can&#39;t add property a, object is not extensible Q2:在if (true) { 声明一个const变量a，并为赋值为5， }在块级作用域中和外面，分别打印变量a看结果。 123456&#x2F;*Exercises2*&#x2F;if(true)&#123; const a&#x3D;5; document.write(&#39;a1:&#39;+a);&#125;document.write(&#39;a2:&#39;+a);&#x2F;&#x2F;Uncaught ReferenceError: a is not defined 是否包含字符串三种新方法传统上，JavaScript只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 12345var str &#x3D; &quot;Hello world!&quot;; str.startsWith(&quot;Hello&quot;) &#x2F;&#x2F; truestr.endsWith(&quot;!&quot;) &#x2F;&#x2F; truestr.includes(&quot;o&quot;) &#x2F;&#x2F; true 这三个方法都支持第二个参数，表示开始搜索的位置。 上面代码表示，使用第二个参数n时，endsWith 的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 12345var str &#x3D; &quot;Hello world!&quot;; str.startsWith(&quot;world&quot;, 6) &#x2F;&#x2F; truestr.endsWith(&quot;Hello&quot;, 5) &#x2F;&#x2F; truestr.includes(&quot;Hello&quot;, 6) &#x2F;&#x2F; false repeat()原字符串重复 12345var str &#x3D; &quot;x&quot;;str.repeat(3) &#x2F;&#x2F; &quot;xxx&quot; var str1 &#x3D; &quot;hello&quot;;str1.repeat(2) &#x2F;&#x2F; &quot;hellohello&quot; 标签模板模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 1234var a &#x3D; 5;var b &#x3D; 10; tag&#96;Hello $&#123; a + b &#125; world $&#123; a * b &#125;&#96;; tag函数所有参数的实际值如下。 第一个参数：[‘Hello ‘, ‘ world ‘] 第二个参数: 15 第三个参数：50 也就是说，tag函数实际上以下面的形式调用。 1tag([&#39;Hello &#39;, &#39; world &#39;], 15, 50) tag用法 12345678910111213141516171819&#x2F;*E7*&#x2F;var a &#x3D; 5;var b &#x3D; 10; function tag(s, v1, v2) &#123; document.write(s[0]+&#39;&lt;br&#x2F;&gt;&#39;); document.write(s[1]+&#39;&lt;br&#x2F;&gt;&#39;); document.write(v1+&#39;&lt;br&#x2F;&gt;&#39;); document.write(v2+&#39;&lt;br&#x2F;&gt;&#39;); return &quot;OK&quot;;&#125; tag&#96;Hello $&#123; a + b &#125; world $&#123; a * b&#125;&#96;;&#x2F;&#x2F; &quot;Hello &quot;&#x2F;&#x2F; &quot; world &quot;&#x2F;&#x2F; 15&#x2F;&#x2F; 50&#x2F;&#x2F; &quot;OK&quot; 模板字符串可以是原始的ES6还为原生的String对象，提供了一个raw方法。若使用String.raw 作为模板字符串的前缀，则模板字符串可以是原始(raw)的。反斜线也不再是特殊字符，\\n 也不会被解释成换行符： 1234567&#x2F;*E8*&#x2F;var raw &#x3D;String(&#39;Not a newline: \\n&#39;);document.write(raw &#x3D;&#x3D;&#x3D; &#39;Not a newline: \\\\n&#39;);&#x2F;&#x2F; false let raw &#x3D; String.raw&#96;Not a newline: \\n&#96;; document.write(raw &#x3D;&#x3D;&#x3D; &#39;Not a newline: \\\\n&#39;); &#x2F;&#x2F; true 有兴趣的小伙伴们还可以看下下面文档: let和const命令-阮一峰 let和const命令-阮一峰2 ES6harmony babeljs","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://blog.jddfe.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"https://blog.jddfe.com/tags/JS/"}]},{"title":"初探ES6新功能","slug":"初探ES6新功能","date":"2016-04-02T12:09:10.000Z","updated":"2020-11-10T14:22:20.674Z","comments":true,"path":"2016/04/02/初探ES6新功能/","link":"","permalink":"https://blog.jddfe.com/2016/04/02/%E5%88%9D%E6%8E%A2ES6%E6%96%B0%E5%8A%9F%E8%83%BD/","excerpt":"","text":"ECMAScript 6 git.io/es6features介绍ECMAScript 6，2015年也被称为ECMAScript 标准的最新版本。标志着最新的语言，是及2009年ES5发布后相继6年出的版本。这些功能的实现主要的JavaScript引擎统计如右边链接(现在正在完善)(http://kangax.github.io/es5-compat-table/es6/) ES6的完整规范如左边网址下ES6 standard。 ES6包括以下几个新功能: arrows classes enhanced object literals template strings destructuring default + rest + spread let + const iterators + for..of generators unicode modules module loaders map + set + weakmap + weakset proxies symbols subclassable built-ins promises math + number + string + array + object APIs binary and octal literals reflect api tail calls ECMAScript 6 功能ArrowsArrows are a function shorthand using the =&gt; syntax. They are syntactically similar to the related feature in C#, Java 8 and CoffeeScript. They support both statement block bodies as well as expression bodies which return the value of the expression. Unlike functions, arrows share the same lexical this as their surrounding code. 箭头函数简单的说是用＝&gt;语法。其语法的相关特性类似于c,Java 8和CoffeeScript。他们同时支持声明块体以及表达身体的返回值的表达式。与方法不同，箭头函数分享了相同语法的this以及它周边代码 1234567891011121314151617181920&#x2F;&#x2F; Expression bodiesvar odds &#x3D; evens.map(v &#x3D;&gt; v + 1);var nums &#x3D; evens.map((v, i) &#x3D;&gt; v + i);var pairs &#x3D; evens.map(v &#x3D;&gt; (&#123;even: v, odd: v + 1&#125;));&#x2F;&#x2F; Statement bodiesnums.forEach(v &#x3D;&gt; &#123; if (v % 5 &#x3D;&#x3D;&#x3D; 0) fives.push(v);&#125;);&#x2F;&#x2F; Lexical thisvar bob &#x3D; &#123; _name: &quot;Bob&quot;, _friends: [], printFriends() &#123; this._friends.forEach(f &#x3D;&gt; console.log(this._name + &quot; knows &quot; + f)); &#125;&#125; ES5与ES6对比 1234567891011//ES5nums.forEach(function (v) &#123; if (v % 5 === 0) fives.push(v);&#125;);//ES6nums.forEach(v =&gt; &#123; if (v % 5 === 0) fives.push(v)&#125;) ClassesES6 classes are a simple sugar over the prototype-based OO pattern. Having a single convenient declarative form makes class patterns easier to use, and encourages interoperability. Classes support prototype-based inheritance, super calls, instance and static methods and constructors. ES6类是一个简单基于原型的面向对象模式。它以类模式声明,并鼓励互操作性。类支持基于原型的继承、超级调用实例和静态方法和构造函数。 1234567891011121314151617181920212223class SkinnedMesh extends THREE.Mesh &#123; constructor(geometry, materials) &#123; super(geometry, materials); this.idMatrix = SkinnedMesh.defaultMatrix(); this.bones = []; this.boneMatrices = []; //... &#125; update(camera) &#123; //... super.update(); &#125; get boneCount() &#123; return this.bones.length; &#125; set matrixType(matrixType) &#123; this.idMatrix = SkinnedMesh[matrixType](); &#125; static defaultMatrix() &#123; return new THREE.Matrix4(); &#125;&#125; ES5与ES6对比 12345678910111213141516171819202122//ES5var Shape = function (id, x, y) &#123; this.id = id; this.move(x, y);&#125;;Shape.prototype.move = function (x, y) &#123; this.x = x; this.y = y;&#125;;//ES6class Shape &#123; constructor (id, x, y) &#123; this.id = id this.move(x, y) &#125; move (x, y) &#123; this.x = x this.y = y &#125;&#125; Enhanced Object LiteralsObject literals are extended to support setting the prototype at construction, shorthand for foo: foo assignments, defining methods, making super calls, and computing property names with expressions. Together, these also bring object literals and class declarations closer together, and let object-based design benefit from some of the same conveniences. 对象文本扩展为支持设置原型结构,简称“foo:foo”模式,定义方法,使超级调用,和计算属性名表达式。在一起,这些也将文本对象和类声明更紧密地联系在一起,并让基于对象的设计更加便利的使用在一起。 12345678910111213var obj = &#123; // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Methods toString() &#123; // Super calls return &quot;d &quot; + super.toString(); &#125;, // Computed (dynamic) property names [ &#x27;prop_&#x27; + (() =&gt; 42)() ]: 42&#125;; ES5与ES6对比 1234567891011//ES5obj = &#123; foo: &quot;bar&quot;&#125;;obj[ &quot;prop_&quot; + foo() ] = 42;//ES6obj = &#123; foo: &quot;bar&quot;, [ &quot;prop_&quot; + foo() ]: 42&#125; Template StringsTemplate strings provide syntactic sugar for constructing strings. This is similar to string interpolation features in Perl, Python and more. Optionally, a tag can be added to allow the string construction to be customized, avoiding injection attacks or constructing higher level data structures from string contents. 模板构建字符串的字符串提供更简便的写法。这类似于字符串插值特性在Perl、Python和更多。可选地,可以添加一个标签允许自定义字符串建设,避免注入攻击或从字符串构造更高层次数据结构的内容。 1234567891011121314151617// Basic literal string creation`In JavaScript &#x27;\\n&#x27; is a line-feed.`// Multiline strings`In JavaScript this is not legal.`// String interpolationvar name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`// Construct an HTTP request prefix is used to interpret the replacements and constructionGET`http://foo.org/bar?a=$&#123;a&#125;&amp;b=$&#123;b&#125; Content-Type: application/json X-Credentials: $&#123;credentials&#125; &#123; &quot;foo&quot;: $&#123;foo&#125;, &quot;bar&quot;: $&#123;bar&#125;&#125;`(myOnReadyStateChangeHandler); ES5与ES6对比 12345678910111213//ES5var customer = &#123; name: &quot;Foo&quot; &#125;;var card = &#123; amount: 7, product: &quot;Bar&quot;, unitprice: 42 &#125;;message = &quot;Hello &quot; + customer.name + &quot;,\\n&quot; +&quot;want to buy &quot; + card.amount + &quot; &quot; + card.product + &quot; for\\n&quot; +&quot;a total of &quot; + (card.amount * card.unitprice) + &quot; bucks?&quot;;//ES6var customer = &#123; name: &quot;Foo&quot; &#125;var card = &#123; amount: 7, product: &quot;Bar&quot;, unitprice: 42 &#125;message = `Hello $&#123;customer.name&#125;,want to buy $&#123;card.amount&#125; $&#123;card.product&#125; fora total of $&#123;card.amount * card.unitprice&#125; bucks?` DestructuringDestructuring allows binding using pattern matching, with support for matching arrays and objects. Destructuring is fail-soft, similar to standard object lookup foo[&quot;bar&quot;], producing undefined values when not found. 解构允许绑定使用模式匹配,支持匹配数组和对象。解构是可以让故障弱化,类似于标准对象查找foo(“bar”),生产时没有发现未定义的值‘undefined’。 123456789101112131415161718192021222324// list matchingvar [a, , b] = [1,2,3];// object matchingvar &#123; op: a, lhs: &#123; op: b &#125;, rhs: c &#125; = getASTNode()// object matching shorthand// binds `op`, `lhs` and `rhs` in scopevar &#123;op, lhs, rhs&#125; = getASTNode()// Can be used in parameter positionfunction g(&#123;name: x&#125;) &#123; console.log(x);&#125;g(&#123;name: 5&#125;)// Fail-soft destructuringvar [a] = [];a === undefined;// Fail-soft destructuring with defaultsvar [a = 1] = [];a === 1; ES5与ES6对比 123456789101112131415161718192021222324252627282930313233343536373839404142//ES5var &#123; op: a, lhs: &#123; op: b &#125;, rhs: c &#125; = getASTNode()//ES6var tmp = getASTNode();var a = tmp.op;var b = tmp.lhs.op;var c = tmp.rhs;//ES5function f (arg) &#123; var name = arg[0]; var val = arg[1]; console.log(name, val);&#125;;function g (arg) &#123; var n = arg.name; var v = arg.val; console.log(n, v);&#125;;function h (arg) &#123; var name = arg.name; var val = arg.val; console.log(name, val);&#125;;f([ &quot;bar&quot;, 42 ]);g(&#123; name: &quot;foo&quot;, val: 7 &#125;);h(&#123; name: &quot;bar&quot;, val: 42 &#125;);//ES6function f ([ name, val ]) &#123; console.log(name, val)&#125;function g (&#123; name: n, val: v &#125;) &#123; console.log(n, v)&#125;function h (&#123; name, val &#125;) &#123; console.log(name, val)&#125;f([ &quot;bar&quot;, 42 ])g(&#123; name: &quot;foo&quot;, val: 7 &#125;)h(&#123; name: &quot;bar&quot;, val: 42 &#125;) Default + Rest + SpreadCallee-evaluated default parameter values. Turn an array into consecutive arguments in a function call. Bind trailing parameters to an array. Rest replaces the need for arguments and addresses common cases more directly. Callee-evaluated默认参数值。把一个数组转化为连续函数调用的参数。剩余的参数绑定到一个数组中。其他取代了需要的参数和地址一般情况下更直接。 12345function f(x, y=12) &#123; // y is 12 if not passed (or passed as undefined) return x + y;&#125;f(3) == 15 12345function f(x, ...y) &#123; // y is an Array return x * y.length;&#125;f(3, &quot;hello&quot;, true) == 6 12345function f(x, y, z) &#123; return x + y + z;&#125;// Pass each elem of array as argumentf(...[1,2,3]) == 6 ES5与ES6对比 123456789101112131415//ES5var params = [ &quot;hello&quot;, true, 7 ];var other = [ 1, 2 ].concat(params); // [ 1, 2, &quot;hello&quot;, true, 7 ]f.apply(undefined, [ 1, 2 ].concat(params)) === 9;var str = &quot;foo&quot;;var chars = str.split(&quot;&quot;); // [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ]//ES6var params = [ &quot;hello&quot;, true, 7 ]var other = [ 1, 2, ...params ] // [ 1, 2, &quot;hello&quot;, true, 7 ]f(1, 2, ...params) === 9var str = &quot;foo&quot;var chars = [ ...str ] // [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ] Let + ConstBlock-scoped binding constructs. let is the new var. const is single-assignment. Static restrictions prevent use before assignment. Block-scoped绑定结构。let”是新的“var”。“常量”是单一赋值消息快。静态限制防止作业之前使用。 12345678910111213function f() &#123; &#123; let x; &#123; // okay, block scoped name const x = &quot;sneaky&quot;; // error, const x = &quot;foo&quot;; &#125; // error, already declared in block let x = &quot;inner&quot;; &#125;&#125; ES5与ES6对比 123456789101112//ES5Object.defineProperty(typeof global === &quot;object&quot; ? global : window, &quot;PI&quot;, &#123; value: 3.141593, enumerable: true, writable: false, configurable: false&#125;)PI &gt; 3.0;//ES6const PI = 3.141593PI &gt; 3.0 Iterators + For..OfIterator objects enable custom iteration like CLR IEnumerable or Java Iterable. Generalize for..in to custom iterator-based iteration with for..of. Don’t require realizing an array, enabling lazy design patterns like LINQ. 迭代器对象启用自定义迭代就像CLR IEnumerable或Java Iterable。概括的. .概括来说它就是将‘fo..in’等循环用‘for..of’来写。不需要实现一个数组,使懒惰像LINQ设计模式。 123456789101112131415161718let fibonacci = &#123; [Symbol.iterator]() &#123; let pre = 0, cur = 1; return &#123; next() &#123; [pre, cur] = [cur, pre + cur]; return &#123; done: false, value: cur &#125; &#125; &#125; &#125;&#125;for (var n of fibonacci) &#123; // truncate the sequence at 1000 if (n &gt; 1000) break; console.log(n);&#125; Iteration is based on these duck-typed interfaces (using TypeScript type syntax for exposition only): 12345678910interface IteratorResult &#123; done: boolean; value: any;&#125;interface Iterator &#123; next(): IteratorResult;&#125;interface Iterable &#123; [Symbol.iterator](): Iterator&#125; ES5与ES6对比 123456789101112131415161718192021222324252627282930313233343536373839//ES5var fibonacci = &#123; next: ((function () &#123; var pre = 0, cur = 1; return function () &#123; tmp = pre; pre = cur; cur += tmp; return cur; &#125;; &#125;)();&#125;;var n;for (;;) &#123; n = fibonacci.next(); if (n &gt; 1000) break; console.log(n);&#125;//ES6let fibonacci = &#123; [Symbol.iterator]() &#123; let pre = 0, cur = 1 return &#123; next () &#123; [ pre, cur ] = [ cur, pre + cur ] return &#123; done: false, value: cur &#125; &#125; &#125; &#125;&#125;for (let n of fibonacci) &#123; if (n &gt; 1000) break console.log(n)&#125; GeneratorsGenerators simplify iterator-authoring using function* and yield. A function declared as function* returns a Generator instance. Generators are subtypes of iterators which include additional next and throw. These enable values to flow back into the generator, so yield is an expression form which returns a value (or throws). 生成器简化iterator-authoring使用“function”和“yield”。一个函数声明为函数返回一个生成器实例。生成器是迭代器的子类型,包括额外的“next”和“throw”。这可使用的值回流到生成器,因此“产量”是一种表达形式返回一个值(或抛出)。 Note: Can also be used to enable ‘await’-like async programming, see also ES7 await proposal. 123456789101112131415161718var fibonacci = &#123; [Symbol.iterator]: function*() &#123; var pre = 0, cur = 1; for (;;) &#123; var temp = pre; pre = cur; cur += temp; yield cur; &#125; &#125;&#125;for (var n of fibonacci) &#123; // truncate the sequence at 1000 if (n &gt; 1000) break; console.log(n);&#125; The generator interface is (using TypeScript type syntax for exposition only): 1234interface Generator extends Iterator &#123; next(value?: any): IteratorResult; throw(exception: any);&#125; ES5与ES6对比 1234567891011121314151617181920212223242526//ES5function range (start, end, step) &#123; var list = []; while (start &lt; end) &#123; list.push(start); start += step; &#125; return list;&#125;var r = range(0, 10, 2);for (var i = 0; i &lt; r.length; i++) &#123; console.log(r[i]); // 0, 2, 4, 6, 8&#125;//ES6function* range (start, end, step) &#123; while (start &lt; end) &#123; yield start start += step &#125;&#125;for (let i of range(0, 10, 2)) &#123; console.log(i) // 0, 2, 4, 6, 8&#125; UnicodeNon-breaking additions to support full Unicode, including new Unicode literal form in strings and new RegExp u mode to handle code points, as well as new APIs to process strings at the 21bit code points level. These additions support building global apps in JavaScript. 可以帮助增加完整的Unicode的支持,包括新的Unicode字符串中的文字形式和新的正则表达式处理代码点“u”模式,以及新的api来处理字符串在21位代码点水平。这些添加支持建立全球JavaScript应用程序。 12345678910111213141516// same as ES5.1&quot;𠮷&quot;.length == 2// new RegExp behaviour, opt-in ‘u’&quot;𠮷&quot;.match(/./u)[0].length == 2// new form&quot;\\u&#123;20BB7&#125;&quot;==&quot;𠮷&quot;==&quot;\\uD842\\uDFB7&quot;// new String ops&quot;𠮷&quot;.codePointAt(0) == 0x20BB7// for-of iterates code pointsfor(var c of &quot;𠮷&quot;) &#123; console.log(c);&#125; ES5与ES6对比 123456789//ES5&quot;𠮷&quot;.length === 2;&quot;𠮷&quot;.match(/(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF][\\uD800-\\uDBFF][\\uDC00-\\uDFFF][\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])(?:[^\\uD800-\\uDBFF]^)[\\uDC00-\\uDFFF])/)[0].length === 2;&quot;𠮷&quot; === &quot;\\uD842\\uDFB7&quot;;//ES6&quot;𠮷&quot;.length === 2&quot;𠮷&quot;.match(/./u)[0].length === 2&quot;\\u&#123;20BB7&#125;&quot; === &quot;𠮷&quot; === &quot;\\uD842\\uDFB7&quot; ModulesLanguage-level support for modules for component definition. Codifies patterns from popular JavaScript module loaders (AMD, CommonJS). Runtime behaviour defined by a host-defined default loader. Implicitly async model – no code executes until requested modules are available and processed. 为组件定义语言级支持模块。汇总模式从流行的JavaScript模块加载器(AMD,CommonJS)。运行时行为由host-defined定义默认加载程序。隐式异步模型——没有代码执行,直到请求模块是可用的和加工。 12345// lib/math.jsexport function sum(x, y) &#123; return x + y;&#125;export var pi = 3.141593; 123// app.jsimport * as math from &quot;lib/math&quot;;alert(&quot;2π = &quot; + math.sum(math.pi, math.pi)); 123// otherApp.jsimport &#123;sum, pi&#125; from &quot;lib/math&quot;;alert(&quot;2π = &quot; + sum(pi, pi)); Some additional features include export default and export *: 123456// lib/mathplusplus.jsexport * from &quot;lib/math&quot;;export var e = 2.71828182846;export default function(x) &#123; return Math.log(x);&#125; 123// app.jsimport ln, &#123;pi, e&#125; from &quot;lib/mathplusplus&quot;;alert(&quot;2π = &quot; + ln(e)*pi*2); ES5与ES6对比 123456789101112131415161718192021//ES5LibMathPP = &#123;&#125;;for (symbol in LibMath) if (LibMath.hasOwnProperty(symbol)) LibMathPP[symbol] = LibMath[symbol];LibMathPP.e = 2.71828182846;LibMathPP.exp = function (x) &#123; return Math.exp(x) &#125;;// someApp.jsvar exp = LibMathPP.exp, pi = LibMathPP.pi, e = libMathPP.e;console.log(&quot;e^&#123;π&#125; = &quot; + exp(pi));//ES6export * from &quot;lib/math&quot;export var e = 2.71828182846export default (x) =&gt; Math.exp(x)// someApp.jsimport exp, &#123; pi, e &#125; from &quot;lib/mathplusplus&quot;console.log(&quot;e^&#123;π&#125; = &quot; + exp(pi)) Module LoadersModule loaders support: Dynamic loading State isolation Global namespace isolation Compilation hooks Nested virtualization The default module loader can be configured, and new loaders can be constructed to evaluate and load code in isolated or constrained contexts. 默认模块加载器可以配置,可以评估和构造新的加载器加载代码隔离或语境的限制。 1234567891011121314// Dynamic loading – ‘System’ is default loaderSystem.import(&#x27;lib/math&#x27;).then(function(m) &#123; alert(&quot;2π = &quot; + m.sum(m.pi, m.pi));&#125;);// Create execution sandboxes – new Loadersvar loader = new Loader(&#123; global: fixup(window) // replace ‘console.log’&#125;);loader.eval(&quot;console.log(&#x27;hello world!&#x27;);&quot;);// Directly manipulate module cacheSystem.get(&#x27;jquery&#x27;);System.set(&#x27;jquery&#x27;, Module(&#123;$: $&#125;)); // WARNING: not yet finalized Map + Set + WeakMap + WeakSetEfficient data structures for common algorithms. WeakMaps provides leak-free object-key’d side tables. 数据结构常用算法效率。WeakMaps提供对象键索引表。 123456789101112131415161718192021// Setsvar s = new Set();s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);s.size === 2;s.has(&quot;hello&quot;) === true;// Mapsvar m = new Map();m.set(&quot;hello&quot;, 42);m.set(s, 34);m.get(s) == 34;// Weak Mapsvar wm = new WeakMap();wm.set(s, &#123; extra: 42 &#125;);wm.size === undefined// Weak Setsvar ws = new WeakSet();ws.add(&#123; data: 42 &#125;);// Because the added object has no other references, it will not be held in the set ES5与ES6对比 123456789101112131415161718192021//ES5var m = &#123;&#125;;m[&quot;hello&quot;] = 42;// no equivalent in ES5// no equivalent in ES5Object.keys(m).length === 2;for (key in m) &#123; if (m.hasOwnProperty(key)) &#123; var val = m[key]; console.log(key + &quot; = &quot; + val); &#125;&#125;//ES6let m = new Map()m.set(&quot;hello&quot;, 42)m.set(s, 34)m.get(s) === 34m.size === 2for (let [ key, val ] of m.entries()) console.log(key + &quot; = &quot; + val) ProxiesProxies enable creation of objects with the full range of behaviors available to host objects. Can be used for interception, object virtualization, logging/profiling, etc. 代理启用创建对象的全部行为可用主机对象。可用于拦截、对象虚拟化,日志/分析等,这是一个新功能。 12345678910// Proxying a normal objectvar target = &#123;&#125;;var handler = &#123; get: function (receiver, name) &#123; return `Hello, $&#123;name&#125;!`; &#125;&#125;;var p = new Proxy(target, handler);p.world === &#x27;Hello, world!&#x27;; 12345678910// Proxying a function objectvar target = function () &#123; return &#x27;I am the target&#x27;; &#125;;var handler = &#123; apply: function (receiver, ...args) &#123; return &#x27;I am the proxy&#x27;; &#125;&#125;;var p = new Proxy(target, handler);p() === &#x27;I am the proxy&#x27;; There are traps available for all of the runtime-level meta-operations: 1234567891011121314151617var handler =&#123; get:..., set:..., has:..., deleteProperty:..., apply:..., construct:..., getOwnPropertyDescriptor:..., defineProperty:..., getPrototypeOf:..., setPrototypeOf:..., enumerate:..., ownKeys:..., preventExtensions:..., isExtensible:...&#125; SymbolsSymbols enable access control for object state. Symbols allow properties to be keyed by either string (as in ES5) or symbol. Symbols are a new primitive type. Optional name parameter used in debugging - but is not part of identity. Symbols are unique (like gensym), but not private since they are exposed via reflection features like Object.getOwnPropertySymbols. 符号启用访问控制对象状态。符号允许键属性的“string”(如ES5)或“symbol”。符号是一个新的原始类型。可选的“name”参数用于调试——但不是身份的一部分。符号是独一无二的(比如gensym),而不是个人,因为他们是通过反射特性,如“Object.getOwnPropertySymbols”。这是也是一个新功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var MyClass = (function() &#123; // module scoped symbol var key = Symbol(&quot;key&quot;); function MyClass(privateData) &#123; this[key] = privateData; &#125; MyClass.prototype = &#123; doStuff: function() &#123; ... this[key] ... &#125; &#125;; return MyClass;&#125;)();var c = new MyClass(&quot;hello&quot;)c[&quot;key&quot;] === undefined### Subclassable Built-insIn ES6, built-ins like `Array`, `Date` and DOM `Element`s can be subclassed.Object construction for a function named `Ctor` now uses two-phases (both virtually dispatched):- Call `Ctor[@@create]` to allocate the object, installing any special behavior- Invoke constructor on new instance to initializeThe known `@@create` symbol is available via `Symbol.create`. Built-ins now expose their `@@create` explicitly.在ES6,应有尽有,如“Array”,“Date”和DOM&quot;Element&quot;的可以派生子类。 对象构造函数名为“Ctor”现在使用两(几乎两派):- 称之为“Ctor(@@create)的分配对象,安装任何特殊的行为- 新实例上调用构造函数来初始化 已知的“@@create”符号是可以通过“Symbol.create”。内置模板现在公开他们的@@create明确。```JavaScript// Pseudo-code of Arrayclass Array &#123; constructor(...args) &#123; /* ... */ &#125; static [Symbol.create]() &#123; // Install special [[DefineOwnProperty]] // to magically update &#x27;length&#x27; &#125;&#125;// User code of Array subclassclass MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;// Two-phase &#x27;new&#x27;:// 1) Call @@create to allocate object// 2) Invoke constructor on new instancevar arr = new MyArray();arr[1] = 12;arr.length == 2 ES5与ES6对比 1234567891011//ES5var obj = &#123; a: 1 &#125;;Object.defineProperty(obj, &quot;b&quot;, &#123; value: 2 &#125;);// no equivalent in ES5Object.getOwnPropertyNames(obj); // [ &quot;a&quot;, &quot;b&quot; ]//ES6let obj = &#123; a: 1 &#125;Object.defineProperty(obj, &quot;b&quot;, &#123; value: 2 &#125;)obj[Symbol(&quot;c&quot;)] = 3Reflect.ownKeys(obj) // [ &quot;a&quot;, &quot;b&quot;, Symbol(c) ] Math + Number + String + Array + Object APIsMany new library additions, including core Math libraries, Array conversion helpers, String helpers, and Object.assign for copying. 许多新图书馆补充,包括核心数学库,数组转换帮手,字符串助手,和对象。分配进行复制。 12345678910111213141516171819202122Number.EPSILONNumber.isInteger(Infinity) // falseNumber.isNaN(&quot;NaN&quot;) // falseMath.acosh(3) // 1.762747174039086Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2&quot;abcde&quot;.includes(&quot;cd&quot;) // true&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;Array.from(document.querySelectorAll(&#x27;*&#x27;)) // Returns a real ArrayArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior[0, 0, 0].fill(7, 1) // [0,7,7][1, 2, 3].find(x =&gt; x == 3) // 3[1, 2, 3].findIndex(x =&gt; x == 2) // 1[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;Object.assign(Point, &#123; origin: new Point(0,0) &#125;) Binary and Octal LiteralsTwo new numeric literal forms are added for binary (b) and octal (o). 添加两个新的数值文字形式为二进制(“b”)和八进制(“o”)。 120b111110111 === 503 // true0o767 === 503 // true ES5与ES6对比 12345678//ES5parseInt(&quot;111110111&quot;, 2) === 503;parseInt(&quot;767&quot;, 8) === 503;0767 === 503; // only in non-strict, backward compatibility mode//ES60b111110111 === 5030o767 === 503 PromisesPromises are a library for asynchronous programming. Promises are a first class representation of a value that may be made available in the future. Promises are used in many existing JavaScript libraries. 承诺模式是异步编程库。承诺是一个一个流的表示的值可能会在未来使用。承诺模式用于许多现有的JavaScript库。 12345678910111213function timeout(duration = 0) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, duration); &#125;)&#125;var p = timeout(1000).then(() =&gt; &#123; return timeout(2000);&#125;).then(() =&gt; &#123; throw new Error(&quot;hmm&quot;);&#125;).catch(err =&gt; &#123; return Promise.all([timeout(100), timeout(200)]);&#125;) ES5与ES6对比 1234567891011121314151617181920212223//ES5function msgAfterTimeout (msg, who, timeout, onDone) &#123; setTimeout(function () &#123; onDone(msg + &quot; Hello &quot; + who + &quot;!&quot;); &#125;, timeout);&#125;msgAfterTimeout(&quot;&quot;, &quot;Foo&quot;, 100, function (msg) &#123; msgAfterTimeout(msg, &quot;Bar&quot;, 200, function (msg) &#123; console.log(&quot;done after 300ms:&quot; + msg); &#125;);&#125;);//ES6function msgAfterTimeout (msg, who, timeout) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(`$&#123;msg&#125; Hello $&#123;who&#125;!`), timeout) &#125;)&#125;msgAfterTimeout(&quot;&quot;, &quot;Foo&quot;, 100).then((msg) =&gt; msgAfterTimeout(msg, &quot;Bar&quot;, 200)).then((msg) =&gt; &#123; console.log(`done after 300ms:$&#123;msg&#125;`)&#125;) Reflect APIFull reflection API exposing the runtime-level meta-operations on objects. This is effectively the inverse of the Proxy API, and allows making calls corresponding to the same meta-operations as the proxy traps. Especially useful for implementing proxies. 完整的反射API公开运行时级meta-operations对象。这是一个有效的反向代理的API,并声明对应相同的meta-operations代理陷阱。实现代理尤其有用。 ES5与ES6对比 1234567891011//ES5var obj = &#123; a: 1 &#125;;Object.defineProperty(obj, &quot;b&quot;, &#123; value: 2 &#125;);// no equivalent in ES5Object.getOwnPropertyNames(obj); // [ &quot;a&quot;, &quot;b&quot; ]//ES6let obj = &#123; a: 1 &#125;Object.defineProperty(obj, &quot;b&quot;, &#123; value: 2 &#125;)obj[Symbol(&quot;c&quot;)] = 3Reflect.ownKeys(obj) // [ &quot;a&quot;, &quot;b&quot;, Symbol(c) ] Tail CallsCalls in tail-position are guaranteed to not grow the stack unboundedly. Makes recursive algorithms safe in the face of unbounded inputs. 在尾部调用保证不是堆栈无限制地增长。使得在面对无限递归算法安全投入。 123456789function factorial(n, acc = 1) &#123; &#x27;use strict&#x27;; if (n &lt;= 1) return acc; return factorial(n - 1, n * acc);&#125;// Stack overflow in most implementations today,// but safe on arbitrary inputs in ES6factorial(100000)","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://blog.jddfe.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"https://blog.jddfe.com/tags/JS/"}]},{"title":"Git常用命令备忘手册","slug":"Git常用命令备忘手册","date":"2016-03-10T12:55:10.000Z","updated":"2020-11-10T13:49:03.329Z","comments":true,"path":"2016/03/10/Git常用命令备忘手册/","link":"","permalink":"https://blog.jddfe.com/2016/03/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E6%89%8B%E5%86%8C/","excerpt":"","text":"git配置 123456789git config --global user.name &quot;robbin&quot; git config --global user.email &quot;fankai@gmail.com&quot;git config --global color.ui truegit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.br branchgit config --global core.editor &quot;mate -w&quot; # 设置Editor使用textmategit config -l # 列举所有配置 git常用命令:查看、添加、提交、删除、找回，重置修改文件** 1234567891011121314151617181920212223242526git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci .git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am &quot;some comments&quot;git ci --amend # 修改最后一次提交记录git commit --amend #修改最后一次提交注释的，利用–amend参数 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diff** 1234567git diff &lt;file&gt; # 比较当前文件和暂存区文件差异git diffgit diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较 git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息 查看提交记录** 12345git loggit log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat # 查看提交统计信息 gitgit 本地分支管理查看、切换、创建和删除分支 123456789101112131415git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase** 12345git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin&#x2F;master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于：git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; git补丁管理(方便在多台机器上开发同步时用)1234git diff &gt; ..&#x2F;sync.patch # 生成补丁git apply ..&#x2F;sync.patch # 打补丁git apply --check ..&#x2F;sync.patch # 测试补丁能否成功 git暂存管理 1234git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区 git远程分支管理 12345678910111213git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin&#x2F;master # 将远程主分支合并到本地当前分支git co --track origin&#x2F;branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin&#x2F;&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 git远程仓库管理 12345git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@github:robbin&#x2F;robbin_site.git # 添加远程仓库地址git remote set-url origin git@github.com:robbin&#x2F;robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址)git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库 123456789git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@github.com:robbin&#x2F;robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库 12git branch --set-upstream master origin&#x2F;mastergit branch --set-upstream develop origin&#x2F;develop","categories":[{"name":"Git","slug":"Git","permalink":"https://blog.jddfe.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.jddfe.com/tags/Git/"}]},{"title":"Hexo 5分钟搞定你的个人博客","slug":"Hexo 5分钟搞定你的个人博客","date":"2016-02-28T12:26:41.000Z","updated":"2020-11-10T16:11:43.338Z","comments":true,"path":"2016/02/28/Hexo 5分钟搞定你的个人博客/","link":"","permalink":"https://blog.jddfe.com/2016/02/28/Hexo%205%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9A%E4%BD%A0%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"新年快乐，祝所有猿类们新的一年撸代码无bug！！！ 新的一年，一切重新开始，重新折腾起来。Hexo 刚有发布了新版本，今天我们一起来通过Hexo快速搭建个人博客，并发布到 github。 废话不多说，进入正题。 开始前提： 安装 Node.js 安装Git 新建仓库github 新建一个仓库，仓库名必须为 &lt; user-name &gt;.github.io 格式，其中 &lt; user-name &gt; 是你 github 的昵称。不要问我为什么，问了也不想告诉你。 全局安装hexo如果你连 npm 是啥都不知道，那对不起，你走吧。 等等等…开个玩笑，有啥问题可以留言。打开命令行，输入下面的命令，全局安装 hexo。 1npm install -g hexo 初始化项目hexo init，就会自动构建一个 hexo 项目，紧接着执行 hexo s，浏览器访问 localhost:4000 就可以看到效果啦！过程一定要快，凉了就不好吃了！ 12345&#x2F;&#x2F; 初始化hexo init &#x2F;&#x2F; 本地运行hexo s 部署到Github在项目根目录下找到 _congif.yml，找到 deploy 字段并填写完整 123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy: type: git repo: &lt;你的仓库地址&gt; # https:&#x2F;&#x2F;github.com&#x2F;jddfe&#x2F;jddfe.github.io branch: master 虽然只有一份 Hello World，但是我也想让全世界的人看到，成为最闪耀的那个崽。接下来请开始你最擅长的事情：抄！ 有了自己的内容后，需要额外的一个工具来帮助我们推到仓库上，就是 hexo-deployer-git。 1npm install hexo-deployer-git --save 好了，见证奇迹的时候 12345678&#x2F;&#x2F; 清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo clean&#x2F;&#x2F; 生成静态文件，可简写 hexo ghexo generate&#x2F;&#x2F; 发布，简写 hexo dhexo deploy 查看效果至此，已经完成了个人博客的搭建，可以在浏览器中访问： https://jddfe.github.io 其他hexo使用请参见官方文档","categories":[{"name":"折腾不止","slug":"折腾不止","permalink":"https://blog.jddfe.com/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"}],"tags":[{"name":"Hexo GitPage","slug":"Hexo-GitPage","permalink":"https://blog.jddfe.com/tags/Hexo-GitPage/"}]}],"categories":[{"name":"懂理财","slug":"懂理财","permalink":"https://blog.jddfe.com/categories/%E6%87%82%E7%90%86%E8%B4%A2/"},{"name":"前端","slug":"前端","permalink":"https://blog.jddfe.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"折腾不止","slug":"折腾不止","permalink":"https://blog.jddfe.com/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"},{"name":"Git","slug":"Git","permalink":"https://blog.jddfe.com/categories/Git/"}],"tags":[{"name":"基金","slug":"基金","permalink":"https://blog.jddfe.com/tags/%E5%9F%BA%E9%87%91/"},{"name":"定投","slug":"定投","permalink":"https://blog.jddfe.com/tags/%E5%AE%9A%E6%8A%95/"},{"name":"投资","slug":"投资","permalink":"https://blog.jddfe.com/tags/%E6%8A%95%E8%B5%84/"},{"name":"防抖","slug":"防抖","permalink":"https://blog.jddfe.com/tags/%E9%98%B2%E6%8A%96/"},{"name":"节流","slug":"节流","permalink":"https://blog.jddfe.com/tags/%E8%8A%82%E6%B5%81/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.jddfe.com/tags/Hexo/"},{"name":"Github Page","slug":"Github-Page","permalink":"https://blog.jddfe.com/tags/Github-Page/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.jddfe.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Javascript","slug":"Javascript","permalink":"https://blog.jddfe.com/tags/Javascript/"},{"name":"闭包","slug":"闭包","permalink":"https://blog.jddfe.com/tags/%E9%97%AD%E5%8C%85/"},{"name":"栈和堆","slug":"栈和堆","permalink":"https://blog.jddfe.com/tags/%E6%A0%88%E5%92%8C%E5%A0%86/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.jddfe.com/tags/javascript/"},{"name":"事件","slug":"事件","permalink":"https://blog.jddfe.com/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"event","slug":"event","permalink":"https://blog.jddfe.com/tags/event/"},{"name":"原型链","slug":"原型链","permalink":"https://blog.jddfe.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"面向对象","slug":"面向对象","permalink":"https://blog.jddfe.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"rem","slug":"rem","permalink":"https://blog.jddfe.com/tags/rem/"},{"name":"css","slug":"css","permalink":"https://blog.jddfe.com/tags/css/"},{"name":"适配","slug":"适配","permalink":"https://blog.jddfe.com/tags/%E9%80%82%E9%85%8D/"},{"name":"ES6","slug":"ES6","permalink":"https://blog.jddfe.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"https://blog.jddfe.com/tags/JS/"},{"name":"Git","slug":"Git","permalink":"https://blog.jddfe.com/tags/Git/"},{"name":"Hexo GitPage","slug":"Hexo-GitPage","permalink":"https://blog.jddfe.com/tags/Hexo-GitPage/"}]}